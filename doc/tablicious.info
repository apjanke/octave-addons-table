This is tablicious.info, produced by makeinfo version 6.6 from
tablicious.texi.

This manual is for Tablicious, version 0.1.0.

   Copyright © 2019 Andrew Janke

     Permission is granted to make and distribute verbatim copies of
     this manual provided the copyright notice and this permission
     notice are preserved on all copies.

     Permission is granted to copy and distribute modified versions of
     this manual under the conditions for verbatim copying, provided
     that the entire resulting derived work is distributed under the
     terms of a permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
     manual into another language, under the same conditions as for
     modified versions.


File: tablicious.info,  Node: Top,  Next: Introduction

Tablicious for GNU Octave
*************************

This manual is for Tablicious, version 0.1.0.

* Menu:

* Introduction::
* Getting Started::
* Table Representation::
* Date Representation::
* Time Zones::
* Durations::
* Validation Functions::
* Missing Functionality::
* API Reference::
* Copying::


File: tablicious.info,  Node: Introduction,  Next: Getting Started,  Up: Top

1 Introduction
**************

     Time is an illusion.  Lunchtime doubly so.

                           — _Douglas Adams_

   This is the manual for the Tablicious package version 0.1.0 for GNU
Octave.

   Tablicious provides Matlab-compatible tabular data and date/time
support for GNU Octave.  This includes a ‘table’ class with support for
filtering and join operations; ‘datetime’, ‘duration’, and related
classes; Missing Data support; ‘string’ and ‘categorical’ data types;
and other miscellaneous things.

   This document is a work in progress.  You are invited to help improve
it and submit patches.

   Tablicious’s classes are designed to be convenient to use while still
being efficient.  The data representations used by Tablicious are
designed to be efficient and suitable for working with large-ish data
sets.  A “large-ish” data set is one that can have millions of elements
or rows, but still fits in main computer memory.  Tablicious’s main
relational and arithmetic operations are all implemented using
vectorized operations on primitive Octave data types.

   Tablicious was written by Andrew Janke <<floss@apjanke.net>>.
Support can be found on the Tablicious project GitHub page
(https://github.com/apjanke/octave-tablicious).


File: tablicious.info,  Node: Getting Started,  Next: Table Representation,  Prev: Introduction,  Up: Top

2 Getting Started
*****************

The easiest way to obtain Tablicious is by using Octave’s ‘pkg’ package
manager.  To install the development prerelease of Tablicious, run this
in Octave:

     pkg install https://github.com/apjanke/octave-tablicious/releases/download/v0.1.0/tablicious-0.1.0.tar.gz

   (Check the releases page at
<https://github.com/apjanke/octave-tablicious/releases> to find out what
the actual latest release number is.)

   For development, you can obtain the source code for Tablicious from
the project repo on GitHub at
<https://github.com/apjanke/octave-tablicious>.  Make a local clone of
the repo.  Then add the ‘inst’ directory in the repo to your Octave
path.


File: tablicious.info,  Node: Table Representation,  Next: Date Representation,  Prev: Getting Started,  Up: Top

3 Table Representation
**********************

Tablicious provides the ‘table’ class for representing tabular data.

* Menu:

* table Class::


File: tablicious.info,  Node: table Class,  Up: Table Representation

3.1 ‘table’ Class
=================

A ‘table’ is an array object that represents a tabular data structure.
It holds multiple named “variables”, each of which is a column vector,
or a 2-D matrix whose rows are read as records.


File: tablicious.info,  Node: Date Representation,  Next: Time Zones,  Prev: Table Representation,  Up: Top

4 Date Representation
*********************

Chrono provides the ‘datetime’ class for representing points in time.

* Menu:

* datetime Class::


File: tablicious.info,  Node: datetime Class,  Up: Date Representation

4.1 ‘datetime’ Class
====================

A ‘datetime’ is an array object that represents points in time in the
familiar Gregorian calendar.

   This is an attempt to reproduce the functionality of Matlab’s
‘datetime’.  It also contains some Octave-specific extensions.

   The underlying representation is that of a datenum (a ‘double’
containing the number of days since the Matlab epoch), but encapsulating
it in an object provides several benefits: friendly human-readable
display, type safety, automatic type conversion, and time zone support.
In addition to the underlying datenum array, a ‘datetime’ inclues an
optional ‘TimeZone’ property indicating what time zone the datetimes are
in.

* Menu:

* datenum Compatibility::


File: tablicious.info,  Node: datenum Compatibility,  Up: datetime Class

4.1.1 ‘datenum’ Compatibility
-----------------------------

While the underlying data representation of ‘datetime’ is compatible
with (in fact, identical to) that of datenums, you cannot directly
combine them via assignment, concatenation, or most arithmetic
operations.

   This is because of the signature of the ‘datetime’ constructor.  When
combining objects and primitive types like ‘double’, the primitive type
is promoted to an object by calling the other object’s one-argument
constructor on it.  However, the one-argument numeric-input consstructor
for ‘datetime’ does not accept datenums: it interprets its input as
datevecs instead.  This is due to a design decision on Matlab’s part;
for compatibility, Octave does not alter that interface.

   To combine ‘datetime’s with datenums, you can convert the datenums to
‘datetime’s by calling ‘datetime.ofDatenum’ or ‘datetime(x,
'ConvertFrom', 'datenum')’, or you can convert the ‘datetime’s to
datenums by accessing its ‘dnums’ field with ‘x.dnums’.

   Examples:

     dt = datetime('2011-03-04')
     dn = datenum('2017-01-01')
     [dt dn]
         ⇒ error: datenum: expected date vector containing [YEAR, MONTH, DAY, HOUR, MINUTE, SECOND]
     [dt datetime.ofDatenum(dn)]
         ⇒ 04-Mar-2011   01-Jan-2017

   Also, if you have a zoned ‘datetime’, you can’t combine it with a
datenum, because datenums do not carry time zone information.


File: tablicious.info,  Node: Time Zones,  Next: Durations,  Prev: Date Representation,  Up: Top

5 Time Zones
************

Chrono has support for representing dates in time zones and for
converting between time zones.

   A ‘datetime’ may be "zoned" or "zoneless".  A zoneless ‘datetime’
does not have a time zone associated with it.  This is represented by an
empty ‘TimeZone’ property on the ‘datetime’ object.  A zoneless
‘datetime’ represents the local time in some unknown time zone, and
assumes a continuous time scale (no DST shifts).

   A zoned ‘datetime’ is associated with a time zone.  It is represented
by having the time zone’s IANA zone identifier (e.g.  ‘'UTC'’ or
‘'America/New_York'’) in its ‘TimeZone’ property.  A zoned ‘datetime’
represents the local time in that time zone.

   By default, the ‘datetime’ constructor creates unzoned ‘datetime’s.
To make a zoned ‘datetime’, either pass the ‘'TimeZone'’ option to the
constructor, or set the ‘TimeZone’ property after object creation.
Setting the ‘TimeZone’ property on a zoneless ‘datetime’ declares that
it’s a local time in that time zone.  Setting the ‘TimeZone’ property on
a zoned ‘datetime’ turns it back into a zoneless ‘datetime’ without
changing the local time it represents.

   You can tell a zoned from a zoneless time zone in the object display
because the time zone is included for zoned ‘datetime’s.

     % Create an unzoned datetime
     d = datetime('2011-03-04 06:00:00')
         ⇒  04-Mar-2011 06:00:00

     % Create a zoned datetime
     d_ny = datetime('2011-03-04 06:00:00', 'TimeZone', 'America/New_York')
         ⇒  04-Mar-2011 06:00:00 America/New_York
     % This is equivalent
     d_ny = datetime('2011-03-04 06:00:00');
     d_ny.TimeZone = 'America/New_York'
         ⇒  04-Mar-2011 06:00:00 America/New_York

     % Convert it to Chicago time
     d_chi.TimeZone = 'America/Chicago'
         ⇒  04-Mar-2011 05:00:00 America/Chicago

   When you combine two zoned ‘datetime’s via concatenation, assignment,
or arithmetic, if their time zones differ, they are converted to the
time zone of the left-hand input.

     d_ny = datetime('2011-03-04 06:00:00', 'TimeZone', 'America/New_York')
     d_la = datetime('2011-03-04 06:00:00', 'TimeZone', 'America/Los_Angeles')
     d_la - d_ny
         ⇒ 03:00:00

   You cannot combine a zoned and an unzoned ‘datetime’.  This results
in an error being raised.

     Warning: Normalization of "nonexistent" times (like between 02:00
     and 03:00 on a "spring forward" DST change day) is not implemented
     yet.  The results of converting a zoneless local time into a time
     zone where that local time did not exist are currently undefined.

* Menu:

* Defined Time Zones::


File: tablicious.info,  Node: Defined Time Zones,  Up: Time Zones

5.1 Defined Time Zones
======================

Chrono’s time zone data is drawn from the IANA Time Zone Database
(https://www.iana.org/time-zones), also known as the “Olson Database”.
Chrono includes a copy of this database in its distribution so it can
work on Windows, which does not supply it like Unix systems do.

   You can use the ‘timezones’ function to list the time zones known to
Chrono.  These will be all the time zones in the IANA database on your
system (for Linux and macOS) or in the IANA time zone database
redistributed with Chrono (for Windows).

     Note: The IANA Time Zone Database only covers dates from about the
     year 1880 to 2038.  Converting time zones for ‘datetime’s outside
     that range is currently unimplemented.  (Chrono needs to add
     support for proleptic POSIX time zone rules, which are used to
     govern behavior outside that date range.)


File: tablicious.info,  Node: Durations,  Next: Validation Functions,  Prev: Time Zones,  Up: Top

6 Durations
***********

* Menu:

* duration Class::
* calendarDuration Class::


File: tablicious.info,  Node: duration Class,  Next: calendarDuration Class,  Up: Durations

6.1 ‘duration’ Class
====================

A ‘duration’ represents a period of time in fixed-length seconds (or
minutes, hours, or whatever you want to measure it in.)

   A ‘duration’ has a resolution of about a nanosecond for typical
dates.  The underlying representation is a ‘double’ representing the
number of days elapsed, similar to a datenum, except it’s interpreted as
relative to some other reference point you provide, instead of being
relative to the Matlab/Octave epoch.

   You can add or subtract a ‘duration’ to a ‘datetime’ to get another
‘datetime’.  You can also add or subtract ‘durations’ to each other.


File: tablicious.info,  Node: calendarDuration Class,  Prev: duration Class,  Up: Durations

6.2 ‘calendarDuration’ Class
============================

A ‘calendarDuration’ represents a period of time in variable-length
calendar components.  For example, years and months can have varying
numbers of days, and days in time zones with Daylight Saving Time have
varying numbers of hours.  A ‘calendarDuration’ does arithmetic with
"whole" calendar periods.

   ‘calendarDuration’s and ‘duration’s cannot be directly combined,
because they are not semantically equivalent.  (This may be relaxed in
the future to allow ‘duration’s to be interpreted as numbers of days
when combined with ‘calendarDuration’s.)

     d = datetime('2011-03-04 00:00:00')
         ⇒ 04-Mar-2011
     cdur = calendarDuration(1, 3, 0)
         ⇒ 1y 3mo
     d2 = d + cdur
         ⇒ 04-Jun-2012


File: tablicious.info,  Node: Validation Functions,  Next: Missing Functionality,  Prev: Durations,  Up: Top

7 Validation Functions
**********************

Tablicious provides several validation functions which can be used to
check properties of function arguments, variables, object properties,
and other expressions.  These can be used to express invariants in your
program and catch problems due to input errors, incorrect function
usage, or other bugs.

   These validation functions are named following the pattern
‘mustBeXxx’, where ‘Xxx’ is some property of the input it is testing.
Validation functions may check the type, size, or other aspects of their
inputs.

   The most common place for validation functions to be used will
probably be at the beginning of functions, to check the input arguments
and ensure that the contract of the function is not being violated.  If
in the future Octave gains the ability to declaratively express object
property constraints, they will also be of use there.

   Be careful not to get too aggressive with the use of validation
functions: while using them can make sure invariants are followed and
your program is correct, they also reduce the code’s ability to make use
of duck typing, reducing its flexibility.  Whether you want to make this
trade-off is a design decision you will have to consider.

   When a validation function’s condition is violated, it raises an
error that includes a description of the violation in the error message.
This message will include a label for the input that describes what is
being tested.  By default, this label is initialized with ‘inputname()’,
so when you are calling a validator on a function argument or variable,
you will generally not need to supply a label.  But if you’re calling it
on an object property or an expression more complex than a simple
variable reference, the validator cannot automatically detect the input
name for use in the label.  In this case, make use of the optional
trailing argument(s) to the functions to manually supply a label for the
value being tested.

     % Validation of a simple variable does not need a label
     mustBeScalar (x);
     % Validation of a field or property reference does need a label
     mustBeScalar (this.foo, 'this.foo');


File: tablicious.info,  Node: Missing Functionality,  Next: API Reference,  Prev: Validation Functions,  Up: Top

8 Missing Functionality
***********************

Tablicious is based on Matlab’s table and date/time APIs and supports
most of their major functionality.  But not all of it is implemented
yet.  The missing parts are currently:

   • ‘timetable’
   • Moving window methods in ‘fillmissing’
   • ‘summary()’ for ‘table’ and ‘categorical’
   • Assignment to table variables using ‘.’-indexing
   • File I/O like ‘readtable()’ and ‘writetable()’
   • POSIX time zone support for years outside the IANA time zone
     database coverage
   • Week-of-year (ISO calendar) calculations
   • Various ‘'ConvertFrom'’ forms for ‘datetime’ and ‘duration’
   • Support for LDML formatting for ‘datetime’
   • Various functions: ‘between’, ‘caldiff’, ‘dateshift’, ‘week’
   • ‘isdst’, ‘isweekend’
   • ‘calendarDuration.split’
   • ‘duration.Format’ support
   • ‘UTCOffset’ and ‘DSTOffset’ fields in the output of ‘timezones()’
   • Plotting support

   It is the author’s hope that all these will be implemented some day.


File: tablicious.info,  Node: API Reference,  Next: Copying,  Prev: Missing Functionality,  Up: Top

9 API Reference
***************

* Menu:

* API by Category::
* API Alphabetically::


File: tablicious.info,  Node: API by Category,  Next: API Alphabetically,  Up: API Reference

9.1 API by Category
===================

9.1.1 Tables
------------

*note table::
     Tabular data array containing multiple columnar variables.

*note array2table::
     Convert an array to a table.

*note cell2table::
     Convert a cell array to a table.

*note struct2table::
     Convert struct to a table.

*note tableOuterFillValue::
     Outer fill value for variable within a table.

9.1.2 Data Types
----------------

*note string::
     A string array of Unicode strings.

*note startsWith::
     Test if strings start with a pattern.

*note endsWith::
     Test if strings end with a pattern.

*note contains::
     Test if strings contain a pattern.

*note categorical::
     Categorical variable array.

*note discretize::
     Group data into discrete bins or categories.

9.1.3 Dates
-----------

*note datetime::
     Represents points in time using the Gregorian calendar.

*note localdate::
     Represents a complete day using the Gregorian calendar.

*note isdatetime::
     True if input is a ’datetime’ array, false otherwise.

*note NaT::
     “Not-a-Time”.

9.1.4 Durations
---------------

*note calendarDuration::
     Durations of time using variable-length calendar periods, such as
     days, months, and years, which may vary in length over time.

*note calmonths::
     Create a ’calendarDuration’ that is a given number of calendar
     months long.

*note calyears::
     Construct a ’calendarDuration’ a given number of years long.

*note days::
     Duration in days.

*note duration::
     Represents durations or periods of time as an amount of
     fixed-length time (i.e.

*note hours::
     Create a ’duration’ X hours long, or get the hours in a ’duration’
     X.

*note isduration::
     True if input is a ’duration’ array, false otherwise.

*note milliseconds::
     Create a ’duration’ X milliseconds long, or get the milliseconds in
     a ’duration’ X.

*note minutes::
     Create a ’duration’ X hours long, or get the hours in a ’duration’
     X.

*note seconds::
     Create a ’duration’ X seconds long, or get the seconds in a
     ’duration’ X.

*note timezones::
     List all the time zones defined on this system.

*note years::
     Create a ’duration’ X years long, or get the years in a ’duration’
     X.

9.1.5 Missing Data
------------------

*note fillmissing::
     Fill missing values.

*note ismissing::
     Find missing values.

*note rmmissing::
     Remove missing values.

*note standardizeMissing::
     Insert standard missing values.

*note missing::
     Generic auto-converting missing value.

*note isnannish::
     Test if elements are NaN or NaN-like

*note eqn::
     Determine element-wise equality, treating NaNs as equal

9.1.6 Validation Functions
--------------------------

*note mustBeA::
     Requires that input is of a given type.

*note mustBeCellstr::
     Requires that input is a cellstr.

*note mustBeCharvec::
     Requires that input is a char row vector.

*note mustBeFinite::
     Requires that input is finite.

*note mustBeInteger::
     Requires that input is integer-valued (but not necessarily
     integer-typed).

*note mustBeMember::
     Requires that input is a member of a set of given valid values.

*note mustBeNonempty::
     Requires that input is nonempty.

*note mustBeNumeric::
     Requires that input is numeric.

*note mustBeReal::
     Requires that input is finite.

*note mustBeSameSize::
     Requires that the inputs are the same size.

*note mustBeScalar::
     Requires that input is scalar.

*note mustBeScalarLogical::
     Requires that input is a scalar logical.

*note mustBeVector::
     Requires that input is a vector or empty.

9.1.7 Miscellaneous
-------------------

*note colvecfun::
     Apply a function to column vectors in array.

*note dispstrs::
     Display strings for array.

*note isfile::
     Test whether file exists and is not a folder.

*note isfolder::
     Test whether file exists and is a folder.

*note pp::
     Alias for prettyprint, for interactive use.

*note scalarexpand::

*note size2str::

*note vecfun::
     Apply function to vectors in array along arbitrary dimension.

9.1.8 Uncategorized
-------------------

*note octave.chrono.dummy_function::
     A dummy function just for testing the doco tools.

*note octave.chrono.DummyClass::
     A do-nothing class just for testing the doco tools.

*note octave.dataset::
     The ’dataset’ class provides convenient access to the various
     datasets included with Tablicious.

*note octave.datasets::
     Example dataset collection.

*note vartype::
     Filter by variable type for use in suscripting.


File: tablicious.info,  Node: API Alphabetically,  Prev: API by Category,  Up: API Reference

9.2 API Alphabetically
======================

* Menu:

* array2table:: Convert an array to a table.
* calendarDuration::	Durations of time using variable-length calendar
		periods, such as days, months, and years, which may vary in
		length over time.
* calmonths::	Create a ’calendarDuration’ that is a given number of
		calendar months long.
* calyears::	Construct a ’calendarDuration’ a given number of years
		long.
* categorical:: Categorical variable array.
* cell2table::	Convert a cell array to a table.
* colvecfun::	Apply a function to column vectors in array.
* contains::	Test if strings contain a pattern.
* datetime::	Represents points in time using the Gregorian calendar.
* days::	Duration in days.
* discretize::	Group data into discrete bins or categories.
* dispstrs::	Display strings for array.
* duration::	Represents durations or periods of time as an amount of
		fixed-length time (i.e.
* endsWith::	Test if strings end with a pattern.
* eqn:: Determine element-wise equality, treating NaNs as equal
* fillmissing:: Fill missing values.
* hours::	Create a ’duration’ X hours long, or get the hours in a
		’duration’ X.
* isdatetime::	True if input is a ’datetime’ array, false otherwise.
* isduration::	True if input is a ’duration’ array, false otherwise.
* isfile::	Test whether file exists and is not a folder.
* isfolder::	Test whether file exists and is a folder.
* ismissing::	Find missing values.
* isnannish::	Test if elements are NaN or NaN-like
* localdate::	Represents a complete day using the Gregorian calendar.
* milliseconds::	Create a ’duration’ X milliseconds long, or get the
		milliseconds in a ’duration’ X.
* minutes::	Create a ’duration’ X hours long, or get the hours in a
		’duration’ X.
* missing::	Generic auto-converting missing value.
* mustBeA::	Requires that input is of a given type.
* mustBeCellstr::	Requires that input is a cellstr.
* mustBeCharvec::	Requires that input is a char row vector.
* mustBeFinite::	Requires that input is finite.
* mustBeInteger::	Requires that input is integer-valued (but not
		necessarily integer-typed).
* mustBeMember::	Requires that input is a member of a set of given
		valid values.
* mustBeNonempty::	Requires that input is nonempty.
* mustBeNumeric::	Requires that input is numeric.
* mustBeReal::	Requires that input is finite.
* mustBeSameSize::	Requires that the inputs are the same size.
* mustBeScalar::	Requires that input is scalar.
* mustBeScalarLogical:: Requires that input is a scalar logical.
* mustBeVector::	Requires that input is a vector or empty.
* NaT:: “Not-a-Time”.
* octave.chrono.dummy_function::	A dummy function just for testing
		the doco tools.
* octave.chrono.DummyClass::	A do-nothing class just for testing the
		doco tools.
* octave.dataset::	The ’dataset’ class provides convenient access to
		the various datasets included with Tablicious.
* octave.datasets::	Example dataset collection.
* pp::	Alias for prettyprint, for interactive use.
* rmmissing::	Remove missing values.
* scalarexpand::
* seconds::	Create a ’duration’ X seconds long, or get the seconds in a
		’duration’ X.
* size2str::
* standardizeMissing::	Insert standard missing values.
* startsWith::	Test if strings start with a pattern.
* string::	A string array of Unicode strings.
* struct2table::	Convert struct to a table.
* table::	Tabular data array containing multiple columnar variables.
* tableOuterFillValue:: Outer fill value for variable within a table.
* timezones::	List all the time zones defined on this system.
* vartype::	Filter by variable type for use in suscripting.
* vecfun::	Apply function to vectors in array along arbitrary
		dimension.
* years::	Create a ’duration’ X years long, or get the years in a
		’duration’ X.


File: tablicious.info,  Node: array2table,  Next: calendarDuration,  Up: API Alphabetically

9.2.1 array2table
-----------------

 -- Function: OUT = array2table (C)
 -- Function: OUT = array2table (..., ‘'VariableNames'’, VARIABLENAMES)
 -- Function: OUT = array2table (..., ‘'RowNames'’, ROWNAMES)

     Convert an array to a table.

     Converts a 2-D array to a table, with columns in the array becoming
     variables in the output table.  This is typically used on numeric
     arrays, but it can be applied to any type of array.

     You may not want to use this on cell arrays, though, because you
     will end up with a table that has all its variables of type cell.
     If you use ‘cell2table’ instead, columns of the cell array which
     can be condensed into primitive arrays will be.  With
     ‘array2table’, they won’t be.

     See also: *note cell2table::, *note table::, *note struct2table::


File: tablicious.info,  Node: calendarDuration,  Next: calmonths,  Prev: array2table,  Up: API Alphabetically

9.2.2 calendarDuration
----------------------

 -- Class: calendarDuration

     Durations of time using variable-length calendar periods, such as
     days, months, and years, which may vary in length over time.  (For
     example, a calendar month may have 28, 30, or 31 days.)

 -- Instance Variable of calendarDuration: ‘char’ Sign

     The sign (1 or -1) of this duration, which indicates whether it is
     a positive or negative span of time.

 -- Instance Variable of calendarDuration: ‘char’ Years

     The number of whole calendar years in this duration.  Must be
     integer-valued.

 -- Instance Variable of calendarDuration: ‘char’ Months

     The number of whole calendar months in this duration.  Must be
     integer-valued.

 -- Instance Variable of calendarDuration: ‘char’ Days

     The number of whole calendar days in this duration.  Must be
     integer-valued.

 -- Instance Variable of calendarDuration: ‘char’ Hours

     The number of whole hours in this duration.  Must be
     integer-valued.

 -- Instance Variable of calendarDuration: ‘char’ Minutes

     The number of whole minutes in this duration.  Must be
     integer-valued.

 -- Instance Variable of calendarDuration: ‘char’ Seconds

     The number of seconds in this duration.  May contain fractional
     values.

 -- Instance Variable of calendarDuration: ‘char’ Format

     The format to display this ‘calendarDuration’ in.  Currently
     unsupported.

     This is a single value that applies to the whole array.

* Menu:

* calendarDuration.calendarDuration::
* calendarDuration.sizeof::
* calendarDuration.isnat::
* calendarDuration.uminus::
* calendarDuration.plus::
* calendarDuration.times::
* calendarDuration.minus::
* calendarDuration.dispstrs::
* calendarDuration.isnan::


File: tablicious.info,  Node: calendarDuration.calendarDuration,  Next: calendarDuration.sizeof,  Up: calendarDuration

9.2.2.1 calendarDuration.calendarDuration
.........................................

 -- Constructor: OBJ = calendarDuration ()

     Constructs a new scalar ‘calendarDuration’ of zero elapsed time.

 -- Constructor: OBJ = calendarDuration (Y, M, D)
 -- Constructor: OBJ = calendarDuration (Y, M, D, H, MI, S)

     Constructs new ‘calendarDuration’ arrays based on input values.


File: tablicious.info,  Node: calendarDuration.sizeof,  Next: calendarDuration.isnat,  Prev: calendarDuration.calendarDuration,  Up: calendarDuration

9.2.2.2 calendarDuration.sizeof
...............................

 -- Method: OUT = sizeof (OBJ)

     Size of array in bytes.


File: tablicious.info,  Node: calendarDuration.isnat,  Next: calendarDuration.uminus,  Prev: calendarDuration.sizeof,  Up: calendarDuration

9.2.2.3 calendarDuration.isnat
..............................

 -- Method: OUT = isnat (OBJ)

     True if input elements are NaT.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: calendarDuration.uminus,  Next: calendarDuration.plus,  Prev: calendarDuration.isnat,  Up: calendarDuration

9.2.2.4 calendarDuration.uminus
...............................

 -- Method: OUT = uminus (OBJ)

     Unary minus.  Negates the sign of OBJ.


File: tablicious.info,  Node: calendarDuration.plus,  Next: calendarDuration.times,  Prev: calendarDuration.uminus,  Up: calendarDuration

9.2.2.5 calendarDuration.plus
.............................

 -- Method: OUT = plus (A, B)

     Addition: add two ‘calendarDuration’s.

     All the calendar elements (properties) of the two inputs are added
     together.  No normalization is done across the elements, aside from
     the normalization of NaNs.

     If B is numeric, it is converted to a ‘calendarDuration’ using
     ‘calendarDuration.ofDays’.

     Returns a ‘calendarDuration’.


File: tablicious.info,  Node: calendarDuration.times,  Next: calendarDuration.minus,  Prev: calendarDuration.plus,  Up: calendarDuration

9.2.2.6 calendarDuration.times
..............................

 -- Method: OUT = times (OBJ, B)

     Multiplication: Multiplies a ‘calendarDuration’ by a numeric
     factor.

     Returns a ‘calendarDuration’.


File: tablicious.info,  Node: calendarDuration.minus,  Next: calendarDuration.dispstrs,  Prev: calendarDuration.times,  Up: calendarDuration

9.2.2.7 calendarDuration.minus
..............................

 -- Method: OUT = times (A, B)

     Subtraction: Subtracts one ‘calendarDuration’ from another.

     Returns a ‘calendarDuration’.


File: tablicious.info,  Node: calendarDuration.dispstrs,  Next: calendarDuration.isnan,  Prev: calendarDuration.minus,  Up: calendarDuration

9.2.2.8 calendarDuration.dispstrs
.................................

 -- Method: OUT = dispstrs (OBJ)

     Get display strings for each element of OBJ.

     Returns a cellstr the same size as OBJ.


File: tablicious.info,  Node: calendarDuration.isnan,  Prev: calendarDuration.dispstrs,  Up: calendarDuration

9.2.2.9 calendarDuration.isnan
..............................

 -- Method: OUT = isnan (OBJ)

     True if input elements are NaT. This is just an alias for ‘isnat’,
     provided for compatibility and polymorphic programming purposes.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: calmonths,  Next: calyears,  Prev: calendarDuration,  Up: API Alphabetically

9.2.3 calmonths
---------------

 -- Function File: OUT = calmonths (X)
     Create a ‘calendarDuration’ that is a given number of calendar
     months long.

     Input X is a numeric array specifying the number of calendar
     months.

     This is a shorthand alternative to calling the ‘calendarDuration’
     constructor with ‘calendarDuration(0, x, 0)’.

     Returns a new ‘calendarDuration’ object of the same size as X.

     *Note calendarDuration::.


File: tablicious.info,  Node: calyears,  Next: categorical,  Prev: calmonths,  Up: API Alphabetically

9.2.4 calyears
--------------

 -- Function: OUT = calyears (X)

     Construct a ‘calendarDuration’ a given number of years long.

     This is a shorthand for calling ‘calendarDuration(X, 0, 0)’.

     *Note calendarDuration::.


File: tablicious.info,  Node: categorical,  Next: cell2table,  Prev: calyears,  Up: API Alphabetically

9.2.5 categorical
-----------------

 -- Class: categorical

     Categorical variable array.

     A ‘categorical’ array represents an array of values of a
     categorical variable.  Each ‘categorical’ array stores the element
     values along with a list of the categories, and indicators of
     whether the categories are ordinal (that is, they have a meaningful
     mathematical ordering), and whether the set of categories is
     protected (preventing new categories from being added to the
     array).

     In addition to the categories defined in the array, a categorical
     array may have elements of "undefined" value.  This is not
     considered a category; rather, it is the absence of any known
     value.  It is analagous to a ‘NaN’ value.

     This class is not fully implemented yet.  Missing stuff: - gt, ge,
     lt, le - Ordinal support in general - countcats - summary

 -- Instance Variable of categorical: ‘uint16’ code

     The numeric codes of the array element values.  These are indexes
     into the ‘cats’ category list.

     This is a planar property.

 -- Instance Variable of categorical: ‘logical’ tfMissing

     A logical mask indicating whether each element of the array is
     missing (that is, undefined).

     This is a planar property.

 -- Instance Variable of categorical: ‘cellstr’ cats

     The names of the categories in this array.  This is the list into
     which the ‘code’ values are indexes.

 -- Instance Variable of categorical: ‘scalar_logical’ isOrdinal

     A scalar logical indicating whether the categories in this array
     have an ordinal relationship.

* Menu:

* categorical.categorical::
* categorical.sizeof::
* categorical.categories::
* categorical.iscategory::
* categorical.isordinal::
* categorical.string::
* categorical.cellstr::
* categorical.dispstrs::
* categorical.summary::
* categorical.addcats::
* categorical.removecats::
* categorical.mergecats::
* categorical.renamecats::
* categorical.reordercats::
* categorical.setcats::
* categorical.isundefined::
* categorical.ismissing::
* categorical.isnannish::
* categorical.squeezecats::


File: tablicious.info,  Node: categorical.categorical,  Next: categorical.sizeof,  Up: categorical

9.2.5.1 categorical.categorical
...............................

 -- Constructor: OBJ = categorical ()

     Constructs a new scalar categorical whose value is undefined.

 -- Constructor: OBJ = categorical (VALS)
 -- Constructor: OBJ = categorical (VALS, VALUESET)
 -- Constructor: OBJ = categorical (VALS, VALUESET, CATEGORY_NAMES)
 -- Constructor: OBJ = categorical (..., ‘'Ordinal'’, ORDINAL)
 -- Constructor: OBJ = categorical (..., ‘'Protected'’, PROTECTED)

     Constructs a new categorical array from the given values.

     VALS is the array of values to convert to categoricals.

     VALUESET is the set of all values from which VALS is drawn.  If
     omitted, it defaults to the unique values in VALS.

     CATEGORY_NAMES is a list of category names corresponding to
     VALUESET.  If omitted, it defaults to VALUESET, converted to
     strings.

     ORDINAL is a logical indicating whether the category values in OBJ
     have a numeric ordering relationship.  Defaults to false.

     PROTECTED indicates whether OBJ should be protected, which prevents
     the addition of new categories to the array.  Defaults to false.


File: tablicious.info,  Node: categorical.sizeof,  Next: categorical.categories,  Prev: categorical.categorical,  Up: categorical

9.2.5.2 categorical.sizeof
..........................

 -- Method: OUT = sizeof (OBJ)

     Size of array in bytes.


File: tablicious.info,  Node: categorical.categories,  Next: categorical.iscategory,  Prev: categorical.sizeof,  Up: categorical

9.2.5.3 categorical.categories
..............................

 -- Method: OUT = categories (OBJ)

     Get a list of the categories in OBJ.

     Gets a list of the categories in OBJ, identified by their category
     names.

     Returns a cellstr column vector.


File: tablicious.info,  Node: categorical.iscategory,  Next: categorical.isordinal,  Prev: categorical.categories,  Up: categorical

9.2.5.4 categorical.iscategory
..............................

 -- Method: OUT = iscategory (OBJ, CATNAMES)

     Test whether input is a category on a categorical array.

     CATNAMES is a cellstr listing the category names to check against
     OBJ.

     Returns a logical array the same size as CATNAMES.


File: tablicious.info,  Node: categorical.isordinal,  Next: categorical.string,  Prev: categorical.iscategory,  Up: categorical

9.2.5.5 categorical.isordinal
.............................

 -- Method: OUT = isordinal (OBJ)

     Whether OBJ is ordinal.

     Returns true if OBJ is ordinal (as determined by its ‘IsOrdinal’
     property), and false otherwise.


File: tablicious.info,  Node: categorical.string,  Next: categorical.cellstr,  Prev: categorical.isordinal,  Up: categorical

9.2.5.6 categorical.string
..........................

 -- Method: OUT = string (OBJ)

     Convert to string array.

     Converts OBJ to a string array.  The strings will be the category
     names for corresponding values, or <missing> for undefined values.

     Returns a ‘string’ array the same size as OBJ.


File: tablicious.info,  Node: categorical.cellstr,  Next: categorical.dispstrs,  Prev: categorical.string,  Up: categorical

9.2.5.7 categorical.cellstr
...........................

 -- Method: OUT = cellstr (OBJ)

     Convert to cellstr.

     Converts OBJ to a cellstr array.  The strings will be the category
     names for corresponding values, or ‘''’ for undefined values.

     Returns a cellstr array the same size as OBJ.


File: tablicious.info,  Node: categorical.dispstrs,  Next: categorical.summary,  Prev: categorical.cellstr,  Up: categorical

9.2.5.8 categorical.dispstrs
............................

 -- Method: OUT = dispstrs (OBJ)

     Display strings.

     Gets display strings for each element in OBJ.  The display strings
     are either the category string, or ‘'<undefined>'’ for undefined
     values.

     Returns a cellstr array the same size as OBJ.


File: tablicious.info,  Node: categorical.summary,  Next: categorical.addcats,  Prev: categorical.dispstrs,  Up: categorical

9.2.5.9 categorical.summary
...........................

 -- Method: summary (OBJ)

     Display summary of array’s values.

     Displays a summary of the values in this categorical array.  The
     output may contain info like the number of categories, number of
     undefined values, and frequency of each category.


File: tablicious.info,  Node: categorical.addcats,  Next: categorical.removecats,  Prev: categorical.summary,  Up: categorical

9.2.5.10 categorical.addcats
............................

 -- Method: OUT = addcats (OBJ, NEWCATS)

     Add categories to categorical array.

     Adds the specified categories to OBJ, without changing any of its
     values.

     NEWCATS is a cellstr listing the category names to add to OBJ.


File: tablicious.info,  Node: categorical.removecats,  Next: categorical.mergecats,  Prev: categorical.addcats,  Up: categorical

9.2.5.11 categorical.removecats
...............................

 -- Method: OUT = removecats (OBJ)

     Removes all unused categories from OBJ.  This is equivalent to ‘out
     = squeezecats (obj)’.

 -- Method: OUT = removecats (OBJ, OLDCATS)

     Remove categories from categorical array.

     Removes the specified categories from OBJ.  Elements of OBJ whose
     values belonged to those categories are replaced with undefined.

     NEWCATS is a cellstr listing the category names to add to OBJ.


File: tablicious.info,  Node: categorical.mergecats,  Next: categorical.renamecats,  Prev: categorical.removecats,  Up: categorical

9.2.5.12 categorical.mergecats
..............................

 -- Method: OUT = mergecats (OBJ, OLDCATS)
 -- Method: OUT = mergecats (OBJ, OLDCATS, NEWCAT)

     Merge multiple categories.

     Merges the categories OLDCATS into a single category.  If NEWCAT is
     specified, that new category is added if necessary, and all of
     OLDCATS are merged into it.  NEWCAT must be an existing category in
     OBJ if OBJ is ordinal.

     If NEWCAT is not provided, all of ODCATS are merged into
     ‘oldcats{1}’.


File: tablicious.info,  Node: categorical.renamecats,  Next: categorical.reordercats,  Prev: categorical.mergecats,  Up: categorical

9.2.5.13 categorical.renamecats
...............................

 -- Method: OUT = renamecats (OBJ, NEWCATS)
 -- Method: OUT = renamecats (OBJ, OLDCATS, NEWCATS)

     Rename categories.

     Renames some or all of the categories in OBJ, without changing any
     of its values.


File: tablicious.info,  Node: categorical.reordercats,  Next: categorical.setcats,  Prev: categorical.renamecats,  Up: categorical

9.2.5.14 categorical.reordercats
................................

 -- Method: OUT = reordercats (OBJ)
 -- Method: OUT = reordercats (OBJ, NEWCATS)

     Reorder categories.

     Reorders the categories in OBJ to match NEWCATS.

     NEWCATS is a cellstr that must be a reordering of OBJ’s existing
     category list.  If NEWCATS is not supplied, sorts the categories in
     alphabetical order.


File: tablicious.info,  Node: categorical.setcats,  Next: categorical.isundefined,  Prev: categorical.reordercats,  Up: categorical

9.2.5.15 categorical.setcats
............................

 -- Method: OUT = setcats (OBJ, NEWCATS)

     Set categories for categorical array.

     Sets the categories to use for OBJ.  If any current categories are
     absent from the NEWCATS list, current values of those categories
     become undefined.


File: tablicious.info,  Node: categorical.isundefined,  Next: categorical.ismissing,  Prev: categorical.setcats,  Up: categorical

9.2.5.16 categorical.isundefined
................................

 -- Method: OUT = isundefined (OBJ)

     Test whether elements are undefined.

     Checks whether each element in OBJ is undefined.  "Undefined" is a
     special value defined by ‘categorical’.  It is equivalent to a
     ‘NaN’ or a ‘missing’ value.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: categorical.ismissing,  Next: categorical.isnannish,  Prev: categorical.isundefined,  Up: categorical

9.2.5.17 categorical.ismissing
..............................

 -- Method: OUT = ismissing (OBJ)

     Test whether elements are missing.

     For categorical arrays, undefined elements are considered to be
     missing.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: categorical.isnannish,  Next: categorical.squeezecats,  Prev: categorical.ismissing,  Up: categorical

9.2.5.18 categorical.isnannish
..............................

 -- Method: OUT = isnannish (OBJ)

     Test whethere elements are NaN-ish.

     Checks where each element in OBJ is NaN-ish.  For categorical
     arrays, undefined values are considered NaN-ish; any other value is
     not.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: categorical.squeezecats,  Prev: categorical.isnannish,  Up: categorical

9.2.5.19 categorical.squeezecats
................................

 -- Method: OUT = squeezecats (OBJ)

     Remove unused categories.

     Removes all categories which have no corresponding values in OBJ’s
     elements.

     This is currently unimplemented.


File: tablicious.info,  Node: cell2table,  Next: colvecfun,  Prev: categorical,  Up: API Alphabetically

9.2.6 cell2table
----------------

 -- Function: OUT = cell2table (C)
 -- Function: OUT = cell2table (..., ‘'VariableNames'’, VARIABLENAMES)
 -- Function: OUT = cell2table (..., ‘'RowNames'’, ROWNAMES)

     Convert a cell array to a table.

     Converts a 2-dimensional cell matrix into a table.  Each column in
     the input C becomes a variable in OUT.  For columns that contain
     all scalar values of ‘cat’-compatible types, they are “popped out”
     of their cells and condensed into a homogeneous array of the
     contained type.

     See also: *note array2table::, *note table::, *note struct2table::


File: tablicious.info,  Node: colvecfun,  Next: contains,  Prev: cell2table,  Up: API Alphabetically

9.2.7 colvecfun
---------------

 -- Function: OUT = colvecfun (FCN, X)

     Apply a function to column vectors in array.

     Applies the given function FCN to each column vector in the array
     X, by iterating over the indexes along all dimensions except
     dimension 1.  Collects the function return values in an output
     array.

     FCN must be a function which takes a column vector and returns a
     column vector of the same size.  It does not have to return the
     same type as X.

     Returns the result of applying fcn to each column in x, all
     concatenated together in the same shape as x.


File: tablicious.info,  Node: contains,  Next: datetime,  Prev: colvecfun,  Up: API Alphabetically

9.2.8 contains
--------------

 -- Function: OUT = colvecfun (STR, PATTERN)
 -- Function: OUT = colvecfun (..., ‘'IgnoreCase'’, IGNORECASE)

     Test if strings contain a pattern.

     Tests whether the given strings contain the given pattern(s).

     STR (char, cellstr, or string) is a list of strings to compare
     against pattern.

     PATTERN (char, cellstr, or string) is a list of patterns to match.
     These are literal plain string patterns, not regex patterns.  If
     more than one pattern is supplied, the return value is true if the
     string matched any of them.

     Returns a logical array of the same size as the string array
     represented by STR.


File: tablicious.info,  Node: datetime,  Next: days,  Prev: contains,  Up: API Alphabetically

9.2.9 datetime
--------------

 -- Class: datetime

     Represents points in time using the Gregorian calendar.

     The underlying values are doubles representing the number of days
     since the Matlab epoch of "January 0, year 0".  This has a
     precision of around nanoseconds for typical times.

     A ‘datetime’ array is an array of date/time values, with each
     element holding a complete date/time.  The overall array may also
     have a TimeZone and a Format associated with it, which apply to all
     elements in the array.

     This is an attempt to reproduce the functionality of Matlab’s
     ‘datetime’.  It also contains some Octave-specific extensions.

 -- Instance Variable of datetime: ‘double’ dnums

     The underlying datenums that represent the points in time.  These
     are always in UTC.

     This is a planar property: the size of ‘dnums’ is the same size as
     the containing ‘datetime’ array object.

 -- Instance Variable of datetime: ‘char’ TimeZone

     The time zone this ‘datetime’ array is in.  Empty if this does not
     have a time zone associated with it (“unzoned”).  The name of an
     IANA time zone if this does.

     Setting the ‘TimeZone’ of a ‘datetime’ array changes the time zone
     it is presented in for strings and broken-down times, but does not
     change the underlying UTC times that its elements represent.

 -- Instance Variable of datetime: ‘char’ Format

     The format to display this ‘datetime’ in.  Currently unsupported.

* Menu:

* datetime.datetime::
* datetime.ofDatenum::
* datetime.ofDatestruct::
* datetime.NaT::
* datetime.posix2datenum::
* datetime.datenum2posix::
* datetime.sizeof::
* datetime.proxyKeys::
* datetime.ymd::
* datetime.hms::
* datetime.ymdhms::
* datetime.timeofday::
* datetime.week::
* datetime.dispstrs::
* datetime.datestr::
* datetime.datestrs::
* datetime.datestruct::
* datetime.posixtime::
* datetime.datenum::
* datetime.gmtime::
* datetime.localtime::
* datetime.isnat::
* datetime.isnan::
* datetime.lt::
* datetime.le::
* datetime.ne::
* datetime.eq::
* datetime.ge::
* datetime.gt::
* datetime.plus::
* datetime.minus::
* datetime.diff::
* datetime.isbetween::
* datetime.linspace::
* datetime.convertDatenumTimeZone::


File: tablicious.info,  Node: datetime.datetime,  Next: datetime.ofDatenum,  Up: datetime

9.2.9.1 datetime.datetime
.........................

 -- Constructor: OBJ = datetime ()

     Constructs a new scalar ‘datetime’ containing the current local
     time, with no time zone attached.

 -- Constructor: OBJ = datetime (DATEVEC)
 -- Constructor: OBJ = datetime (DATESTRS)
 -- Constructor: OBJ = datetime (IN, ‘'ConvertFrom'’, INTYPE)
 -- Constructor: OBJ = datetime (Y, M, D, H, MI, S)
 -- Constructor: OBJ = datetime (Y, M, D, H, MI, MS)
 -- Constructor: OBJ = datetime (..., ‘'Format'’, FORMAT,
          ‘'InputFormat'’, INPUTFORMAT, ‘'Locale'’, INPUTLOCALE,
          ‘'PivotYear'’, PIVOTYEAR, ‘'TimeZone'’, TIMEZONE)

     Constructs a new ‘datetime’ array based on input values.


File: tablicious.info,  Node: datetime.ofDatenum,  Next: datetime.ofDatestruct,  Prev: datetime.datetime,  Up: datetime

9.2.9.2 datetime.ofDatenum
..........................

 -- Static Method: OBJ = datetime.ofDatenum (DNUMS)

     Converts a datenum array to a datetime array.

     Returns an unzoned ‘datetime’ array of the same size as the input.


File: tablicious.info,  Node: datetime.ofDatestruct,  Next: datetime.NaT,  Prev: datetime.ofDatenum,  Up: datetime

9.2.9.3 datetime.ofDatestruct
.............................

 -- Static Method: OBJ = datetime.ofDatestruct (DSTRUCT)

     Converts a datestruct to a datetime array.

     A datestruct is a special struct format used by Chrono that has
     fields Year, Month, Day, Hour, Minute, and Second.  It is not a
     standard Octave datatype.

     Returns an unzoned ‘datetime’ array.


File: tablicious.info,  Node: datetime.NaT,  Next: datetime.posix2datenum,  Prev: datetime.ofDatestruct,  Up: datetime

9.2.9.4 datetime.NaT
....................

 -- Static Method: OUT = datetime.NaT ()
 -- Static Method: OUT = datetime.NaT (SZ)

     “Not-a-Time”: Creates NaT-valued arrays.

     Constructs a new ‘datetime’ array of all ‘NaT’ values of the given
     size.  If no input SZ is given, the result is a scalar ‘NaT’.

     ‘NaT’ is the ‘datetime’ equivalent of ‘NaN’.  It represents a
     missing or invalid value.  ‘NaT’ values never compare equal to,
     greater than, or less than any value, including other ‘NaT’s.
     Doing arithmetic with a ‘NaT’ and any other value results in a
     ‘NaT’.


File: tablicious.info,  Node: datetime.posix2datenum,  Next: datetime.datenum2posix,  Prev: datetime.NaT,  Up: datetime

9.2.9.5 datetime.posix2datenum
..............................

 -- Static Method: DNUMS = datetime.posix2datenum (PDATES)

     Converts POSIX (Unix) times to datenums

     Pdates (numeric) is an array of POSIX dates.  A POSIX date is the
     number of seconds since January 1, 1970 UTC, excluding leap
     seconds.  The output is implicitly in UTC.


File: tablicious.info,  Node: datetime.datenum2posix,  Next: datetime.sizeof,  Prev: datetime.posix2datenum,  Up: datetime

9.2.9.6 datetime.datenum2posix
..............................

 -- Static Method: OUT = datetime.datenum2posix (DNUMS)

     Converts Octave datenums to Unix dates.

     The input datenums are assumed to be in UTC.

     Returns a double, which may have fractional seconds.


File: tablicious.info,  Node: datetime.sizeof,  Next: datetime.proxyKeys,  Prev: datetime.datenum2posix,  Up: datetime

9.2.9.7 datetime.sizeof
.......................

 -- Method: OUT = sizeof (OBJ)

     Size of array in bytes.


File: tablicious.info,  Node: datetime.proxyKeys,  Next: datetime.ymd,  Prev: datetime.sizeof,  Up: datetime

9.2.9.8 datetime.proxyKeys
..........................

 -- Method: [KEYSA, KEYSB] = proxyKeys (A, B)

     Computes proxy key values for two datetime arrays.  Proxy keys are
     numeric values whose rows have the same equivalence relationships
     as the elements of the inputs.

     This is primarily for Chrono’s internal use; users will typically
     not need to call it or know how it works.

     Returns two 2-D numeric matrices of size n-by-k, where n is the
     number of elements in the corresponding input.


File: tablicious.info,  Node: datetime.ymd,  Next: datetime.hms,  Prev: datetime.proxyKeys,  Up: datetime

9.2.9.9 datetime.ymd
....................

 -- Method: [Y, M, D] = ymd (OBJ)

     Get the Year, Month, and Day components of OBJ.

     For zoned ‘datetime’s, these will be local times in the associated
     time zone.

     Returns double arrays the same size as ‘obj’.


File: tablicious.info,  Node: datetime.hms,  Next: datetime.ymdhms,  Prev: datetime.ymd,  Up: datetime

9.2.9.10 datetime.hms
.....................

 -- Method: [H, M, S] = hms (OBJ)

     Get the Hour, Minute, and Second components of a OBJ.

     For zoned ‘datetime’s, these will be local times in the associated
     time zone.

     Returns double arrays the same size as ‘obj’.


File: tablicious.info,  Node: datetime.ymdhms,  Next: datetime.timeofday,  Prev: datetime.hms,  Up: datetime

9.2.9.11 datetime.ymdhms
........................

 -- Method: [Y, M, D, H, MI, S] = ymdhms (OBJ)

     Get the Year, Month, Day, Hour, Minute, and Second components of a
     OBJ.

     For zoned ‘datetime’s, these will be local times in the associated
     time zone.

     Returns double arrays the same size as ‘obj’.


File: tablicious.info,  Node: datetime.timeofday,  Next: datetime.week,  Prev: datetime.ymdhms,  Up: datetime

9.2.9.12 datetime.timeofday
...........................

 -- Method: OUT = timeofday (OBJ)

     Get the time of day (elapsed time since midnight).

     For zoned ‘datetime’s, these will be local times in the associated
     time zone.

     Returns a ‘duration’ array the same size as ‘obj’.


File: tablicious.info,  Node: datetime.week,  Next: datetime.dispstrs,  Prev: datetime.timeofday,  Up: datetime

9.2.9.13 datetime.week
......................

 -- Method: OUT = week (OBJ)

     Get the week of the year.

     This method is unimplemented.


File: tablicious.info,  Node: datetime.dispstrs,  Next: datetime.datestr,  Prev: datetime.week,  Up: datetime

9.2.9.14 datetime.dispstrs
..........................

 -- Method: OUT = dispstrs (OBJ)

     Get display strings for each element of OBJ.

     Returns a cellstr the same size as OBJ.


File: tablicious.info,  Node: datetime.datestr,  Next: datetime.datestrs,  Prev: datetime.dispstrs,  Up: datetime

9.2.9.15 datetime.datestr
.........................

 -- Method: OUT = datestr (OBJ)
 -- Method: OUT = datestr (OBJ, ...)

     Format OBJ as date strings.  Supports all arguments that core
     Octave’s ‘datestr’ does.

     Returns date strings as a 2-D char array.


File: tablicious.info,  Node: datetime.datestrs,  Next: datetime.datestruct,  Prev: datetime.datestr,  Up: datetime

9.2.9.16 datetime.datestrs
..........................

 -- Method: OUT = datestrs (OBJ)
 -- Method: OUT = datestrs (OBJ, ...)

     Format OBJ as date strings, returning cellstr.  Supports all
     arguments that core Octave’s ‘datestr’ does.

     Returns a cellstr array the same size as OBJ.


File: tablicious.info,  Node: datetime.datestruct,  Next: datetime.posixtime,  Prev: datetime.datestrs,  Up: datetime

9.2.9.17 datetime.datestruct
............................

 -- Method: OUT = datestruct (OBJ)

     Converts this to a "datestruct" broken-down time structure.

     A "datestruct" is a format of struct that Chrono came up with.  It
     is a scalar struct with fields Year, Month, Day, Hour, Minute, and
     Second, each containing a double array the same size as the date
     array it represents.

     The values in the returned broken-down time are those of the local
     time in this’ defined time zone, if it has one.

     Returns a struct with fields Year, Month, Day, Hour, Minute, and
     Second.  Each field contains a double array of the same size as
     this.


File: tablicious.info,  Node: datetime.posixtime,  Next: datetime.datenum,  Prev: datetime.datestruct,  Up: datetime

9.2.9.18 datetime.posixtime
...........................

 -- Method: OUT = posixtime (OBJ)

     Converts this to POSIX time values (seconds since the Unix epoch)

     Converts this to POSIX time values that represent the same time.
     The returned values will be doubles that may include fractional
     second values.  POSIX times are, by definition, in UTC.

     Returns double array of same size as this.


File: tablicious.info,  Node: datetime.datenum,  Next: datetime.gmtime,  Prev: datetime.posixtime,  Up: datetime

9.2.9.19 datetime.datenum
.........................

 -- Method: OUT = datenum (OBJ)

     Convert this to datenums that represent the same local time

     Returns double array of same size as this.


File: tablicious.info,  Node: datetime.gmtime,  Next: datetime.localtime,  Prev: datetime.datenum,  Up: datetime

9.2.9.20 datetime.gmtime
........................

 -- Method: OUT = gmtime (OBJ)

     Convert to TM_STRUCT structure in UTC time.

     Converts OBJ to a TM_STRUCT style structure array.  The result is
     in UTC time.  If OBJ is unzoned, it is assumed to be in UTC time.

     Returns a struct array in TM_STRUCT style.


File: tablicious.info,  Node: datetime.localtime,  Next: datetime.isnat,  Prev: datetime.gmtime,  Up: datetime

9.2.9.21 datetime.localtime
...........................

 -- Method: OUT = localtime (OBJ)

     Convert to TM_STRUCT structure in UTC time.

     Converts OBJ to a TM_STRUCT style structure array.  The result is a
     local time in the system default time zone.  Note that the system
     default time zone is always used, regardless of what TimeZone is
     set on OBJ.

     If OBJ is unzoned, it is assumed to be in UTC time.

     Returns a struct array in TM_STRUCT style.

     Example:
          dt = datetime;
          dt.TimeZone = datetime.SystemTimeZone;
          tm_struct = localtime (dt);


File: tablicious.info,  Node: datetime.isnat,  Next: datetime.isnan,  Prev: datetime.localtime,  Up: datetime

9.2.9.22 datetime.isnat
.......................

 -- Method: OUT = isnat (OBJ)

     True if input elements are NaT.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.isnan,  Next: datetime.lt,  Prev: datetime.isnat,  Up: datetime

9.2.9.23 datetime.isnan
.......................

 -- Method: OUT = isnan (OBJ)

     True if input elements are NaT. This is an alias for ‘isnat’ to
     support type compatibility and polymorphic programming.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.lt,  Next: datetime.le,  Prev: datetime.isnan,  Up: datetime

9.2.9.24 datetime.lt
....................

 -- Method: OUT = lt (A, B)

     True if A is less than B.  This defines the ‘<’ operator for
     ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.le,  Next: datetime.ne,  Prev: datetime.lt,  Up: datetime

9.2.9.25 datetime.le
....................

 -- Method: OUT = le (A, B)

     True if A is less than or equal toB.  This defines the ‘<=’
     operator for ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.ne,  Next: datetime.eq,  Prev: datetime.le,  Up: datetime

9.2.9.26 datetime.ne
....................

 -- Method: OUT = ne (A, B)

     True if A is not equal to B.  This defines the ‘!=’ operator for
     ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.eq,  Next: datetime.ge,  Prev: datetime.ne,  Up: datetime

9.2.9.27 datetime.eq
....................

 -- Method: OUT = eq (A, B)

     True if A is equal to B.  This defines the ‘==’ operator for
     ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.ge,  Next: datetime.gt,  Prev: datetime.eq,  Up: datetime

9.2.9.28 datetime.ge
....................

 -- Method: OUT = ge (A, B)

     True if A is greater than or equal to B.  This defines the ‘>=’
     operator for ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.gt,  Next: datetime.plus,  Prev: datetime.ge,  Up: datetime

9.2.9.29 datetime.gt
....................

 -- Method: OUT = gt (A, B)

     True if A is greater than B.  This defines the ‘>’ operator for
     ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.plus,  Next: datetime.minus,  Prev: datetime.gt,  Up: datetime

9.2.9.30 datetime.plus
......................

 -- Method: OUT = plus (A, B)

     Addition (‘+’ operator).  Adds a ‘duration’, ‘calendarDuration’, or
     numeric B to a ‘datetime’ A.

     A must be a ‘datetime’.

     Numeric B inputs are implicitly converted to ‘duration’ using
     ‘duration.ofDays’.

     Returns ‘datetime’ array the same size as A.


File: tablicious.info,  Node: datetime.minus,  Next: datetime.diff,  Prev: datetime.plus,  Up: datetime

9.2.9.31 datetime.minus
.......................

 -- Method: OUT = minus (A, B)

     Subtraction (‘-’ operator).  Subtracts a ‘duration’,
     ‘calendarDuration’ or numeric B from a ‘datetime’ A, or subtracts
     two ‘datetime’s from each other.

     If both inputs are ‘datetime’, then the output is a ‘duration’.
     Otherwise, the output is a ‘datetime’.

     Numeric B inputs are implicitly converted to ‘duration’ using
     ‘duration.ofDays’.

     Returns an array the same size as A.


File: tablicious.info,  Node: datetime.diff,  Next: datetime.isbetween,  Prev: datetime.minus,  Up: datetime

9.2.9.32 datetime.diff
......................

 -- Method: OUT = diff (OBJ)

     Differences between elements.

     Computes the difference between each successive element in OBJ, as
     a ‘duration’.

     Returns a ‘duration’ array the same size as OBJ.


File: tablicious.info,  Node: datetime.isbetween,  Next: datetime.linspace,  Prev: datetime.diff,  Up: datetime

9.2.9.33 datetime.isbetween
...........................

 -- Method: OUT = isbetween (OBJ, LOWER, UPPER)

     Tests whether the elements of OBJ are between LOWER and UPPER.

     All inputs are implicitly converted to ‘datetime’ arrays, and are
     subject to scalar expansion.

     Returns a logical array the same size as the scalar expansion of
     the inputs.


File: tablicious.info,  Node: datetime.linspace,  Next: datetime.convertDatenumTimeZone,  Prev: datetime.isbetween,  Up: datetime

9.2.9.34 datetime.linspace
..........................

 -- Method: OUT = linspace (FROM, TO, N)

     Linearly-spaced values in date/time space.

     Constructs a vector of ‘datetime’s that represent linearly spaced
     points starting at FROM and going up to TO, with N points in the
     vector.

     FROM and TO are implicitly converted to ‘datetime’s.

     N is how many points to use.  If omitted, defaults to 100.

     Returns an N-long ‘datetime’ vector.


File: tablicious.info,  Node: datetime.convertDatenumTimeZone,  Prev: datetime.linspace,  Up: datetime

9.2.9.35 datetime.convertDatenumTimeZone
........................................

 -- Static Method: OUT = datetime.convertDatenumTimeZone (DNUM,
          FROMZONEID, TOZONEID)

     Convert a datenum from one time zone to another.

     DNUM is a datenum array to convert.

     FROMZONEID is a charvec containing the IANA Time Zone identifier
     for the time zone to convert from.

     TOZONEID is a charvec containing the IANA Time Zone identifier for
     the time zone to convert to.

     Returns a datenum array the same size as DNUM.


File: tablicious.info,  Node: days,  Next: discretize,  Prev: datetime,  Up: API Alphabetically

9.2.10 days
-----------

 -- Function: OUT = days (X)

     Duration in days.

     If X is numeric, then OUT is a ‘duration’ array in units of
     fixed-length 24-hour days, with the same size as X.

     If X is a ‘duration’, then returns a ‘double’ array the same size
     as X indicating the number of fixed-length days that each duration
     is.


File: tablicious.info,  Node: discretize,  Next: dispstrs,  Prev: days,  Up: API Alphabetically

9.2.11 discretize
-----------------

 -- Function: [Y, E] = discretize (X, N)
 -- Function: [Y, E] = discretize (X, EDGES)
 -- Function: [Y, E] = discretize (X, DUR)
 -- Function: [Y, E] = discretize (..., ‘'categorical'’)
 -- Function: [Y, E] = discretize (..., ‘'IncludedEdge'’, INCLUDEDEDGE)

     Group data into discrete bins or categories.

     N is the number of bins to group the values into.

     EDGES is an array of edge values defining the bins.

     DUR is a ‘duration’ value indicating the length of time of each
     bin.

     If ‘'categorical'’ is specified, the resulting values are a
     ‘categorical’ array instead of a numeric array of bin indexes.

     Returns: Y - the bin index or category of each value from X E - the
     list of bin edge values


File: tablicious.info,  Node: dispstrs,  Next: duration,  Prev: discretize,  Up: API Alphabetically

9.2.12 dispstrs
---------------

 -- Function: OUT = dispstrs (X)

     Display strings for array.

     Gets the display strings for each element of X.  The display
     strings should be short, one-line, human-presentable strings
     describing the value of that element.

     The default implementation of ‘dispstrs’ can accept input of any
     type, and has decent implementations for Octave’s standard built-in
     types, but will have opaque displays for most user-defined objects.

     This is a polymorphic method that user-defined classes may override
     with their own custom display that is more informative.

     Returns a cell array the same size as X.


File: tablicious.info,  Node: duration,  Next: endsWith,  Prev: dispstrs,  Up: API Alphabetically

9.2.13 duration
---------------

 -- Class: duration

     Represents durations or periods of time as an amount of
     fixed-length time (i.e.  fixed-length seconds).  It does not care
     about calendar things like months and days that vary in length over
     time.

     This is an attempt to reproduce the functionality of Matlab’s
     ‘duration’.  It also contains some Octave-specific extensions.

 -- Instance Variable of duration: ‘double’ days

     The underlying datenums that represent the durations, as number of
     (whole and fractional) days.  These are uniform 24-hour days, not
     calendar days.

     This is a planar property: the size of ‘days’ is the same size as
     the containing ‘duration’ array object.

 -- Instance Variable of duration: ‘char’ Format

     The format to display this ‘duration’ in.  Currently unsupported.

* Menu:

* duration.ofDays::
* duration.sizeof::
* duration.years::
* duration.hours::
* duration.minutes::
* duration.seconds::
* duration.milliseconds::
* duration.dispstrs::
* duration.char::
* duration.linspace::


File: tablicious.info,  Node: duration.ofDays,  Up: duration

9.2.13.1 duration.ofDays
........................

9.2.13.2 duration.ofDays
........................

 -- Static Method: OBJ = duration.ofDays (DNUMS)

     Converts a double array representing durations in whole and
     fractional days to a ‘duration’ array.  This is the method that is
     used for implicit conversion of numerics in many cases.

     Returns a ‘duration’ array of the same size as the input.


File: tablicious.info,  Node: duration.sizeof,  Next: duration.years,  Up: duration

9.2.13.3 duration.sizeof
........................

 -- Method: OUT = sizeof (OBJ)

     Size of array in bytes.


File: tablicious.info,  Node: duration.years,  Prev: duration.sizeof,  Up: duration

9.2.13.4 duration.years
.......................

9.2.13.5 duration.years
.......................

 -- Method: OUT = years (OBJ)

     Equivalent number of years.

     Gets the number of fixed-length 365.2425-day years that is
     equivalent to this duration.

     Returns double array the same size as OBJ.


File: tablicious.info,  Node: duration.hours,  Up: duration

9.2.13.6 duration.hours
.......................

9.2.13.7 duration.hours
.......................

 -- Method: OUT = hours (OBJ)

     Equivalent number of hours.

     Gets the number of fixed-length 60-minute hours that is equivalent
     to this duration.

     Returns double array the same size as OBJ.


File: tablicious.info,  Node: duration.minutes,  Up: duration

9.2.13.8 duration.minutes
.........................

9.2.13.9 duration.minutes
.........................

 -- Method: OUT = minutes (OBJ)

     Equivalent number of minutes.

     Gets the number of fixed-length 60-second minutes that is
     equivalent to this duration.

     Returns double array the same size as OBJ.


File: tablicious.info,  Node: duration.seconds,  Up: duration

9.2.13.10 duration.seconds
..........................

9.2.13.11 duration.seconds
..........................

 -- Method: OUT = seconds (OBJ)

     Equivalent number of seconds.

     Gets the number of seconds that is equivalent to this duration.

     Returns double array the same size as OBJ.


File: tablicious.info,  Node: duration.milliseconds,  Up: duration

9.2.13.12 duration.milliseconds
...............................

9.2.13.13 duration.milliseconds
...............................

 -- Method: OUT = milliseconds (OBJ)

     Equivalent number of milliseconds.

     Gets the number of milliseconds that is equivalent to this
     duration.

     Returns double array the same size as OBJ.


File: tablicious.info,  Node: duration.dispstrs,  Up: duration

9.2.13.14 duration.dispstrs
...........................

9.2.13.15 duration.dispstrs
...........................

 -- Method: OUT = duration (OBJ)

     Get display strings for each element of OBJ.

     Returns a cellstr the same size as OBJ.


File: tablicious.info,  Node: duration.char,  Up: duration

9.2.13.16 duration.char
.......................

9.2.13.17 duration.char
.......................

 -- Method: OUT = char (OBJ)

     Convert to char.  The contents of the strings will be the same as
     returned by ‘dispstrs’.

     This is primarily a convenience method for use on scalar OBJs.

     Returns a 2-D char array with one row per element in OBJ.


File: tablicious.info,  Node: duration.linspace,  Up: duration

9.2.13.18 duration.linspace
...........................

9.2.13.19 duration.linspace
...........................

 -- Method: OUT = linspace (FROM, TO, N)

     Linearly-spaced values in time duration space.

     Constructs a vector of ‘duration’s that represent linearly spaced
     points starting at FROM and going up to TO, with N points in the
     vector.

     FROM and TO are implicitly converted to ‘duration’s.

     N is how many points to use.  If omitted, defaults to 100.

     Returns an N-long ‘datetime’ vector.


File: tablicious.info,  Node: endsWith,  Next: eqn,  Prev: duration,  Up: API Alphabetically

9.2.14 endsWith
---------------

 -- Function: OUT = endsWith (STR, PATTERN)
 -- Function: OUT = endsWith (..., ‘'IgnoreCase'’, IGNORECASE)

     Test if strings end with a pattern.

     Tests whether the given strings end with the given pattern(s).

     STR (char, cellstr, or string) is a list of strings to compare
     against PATTERN.

     PATTERN (char, cellstr, or string) is a list of patterns to match.
     These are literal plain string patterns, not regex patterns.  If
     more than one pattern is supplied, the return value is true if the
     string matched any of them.

     Returns a logical array of the same size as the string array
     represented by STR.


File: tablicious.info,  Node: eqn,  Next: fillmissing,  Prev: endsWith,  Up: API Alphabetically

9.2.15 eqn
----------

 -- Function: OUT = eqn (A, B)

     Determine element-wise equality, treating NaNs as equal

     out = eqn (A, B)

     ‘eqn’ is just like ‘eq’ (the function that implements the ‘==’
     operator), except that it considers NaN and NaN-like values to be
     equal.  This is the element-wise equivalent of ‘isequaln’.

     ‘eqn’ uses ‘isnannish’ to test for NaN and NaN-like values, which
     means that NaNs and NaTs are considered to be NaN-like, and string
     arrays’ “missing” and categorical objects’ “undefined” values are
     considered equal, because they are NaN-ish.

     Developer’s note: the name “‘eqn’” is a little unfortunate, because
     “eqn” could also be an abbreviation for “equation”.  But this name
     follows the ‘isequaln’ pattern of appending an “n” to the
     corresponding non-NaN-equivocating function.

     See also: ‘eq’, ‘isequaln’, *note isnannish::


File: tablicious.info,  Node: fillmissing,  Next: hours,  Prev: eqn,  Up: API Alphabetically

9.2.16 fillmissing
------------------

 -- Function: [OUT, TFFILLED] = fillmissing (X, METHOD)
 -- Function: [OUT, TFFILLED] = fillmissing (X, ‘'constant'’, FILL_VAL)
 -- Function: [OUT, TFFILLED] = fillmissing (X, MOVMETHOD, WINDOW)

     Fill missing values.

     Fills missing values in X according to the method specified by
     METHOD.

     This method is only partially implemented.

     METHOD may be: ‘'constant'’ ‘'previous'’ ‘'next'’ ‘'nearest'’
     ‘'linear'’ ‘'spline'’ ‘'pchip'’ MOVMETHOD may be: ‘'movmean'’
     ‘'movmedian'’

     Returns OUT, which is X but with missing values filled in, and
     TFFILLED, a logical array the same size as X which indicates which
     elements were filled.


File: tablicious.info,  Node: hours,  Next: isdatetime,  Prev: fillmissing,  Up: API Alphabetically

9.2.17 hours
------------

 -- Function File: OUT = hours (X)
     Create a ‘duration’ X hours long, or get the hours in a ‘duration’
     X.

     If input is numeric, returns a ‘duration’ array that is that many
     hours in time.

     If input is a ‘duration’, converts the ‘duration’ to a number of
     hours.

     Returns an array the same size as X.


File: tablicious.info,  Node: isdatetime,  Next: isduration,  Prev: hours,  Up: API Alphabetically

9.2.18 isdatetime
-----------------

 -- Function: TF = isdatetime (X)

     True if input is a ‘datetime’ array, false otherwise.

     Returns a logical array the same size as X.


File: tablicious.info,  Node: isduration,  Next: isfile,  Prev: isdatetime,  Up: API Alphabetically

9.2.19 isduration
-----------------

 -- Function: TF = isduration (X)

     True if input is a ‘duration’ array, false otherwise.

     Returns a logical array the same size as X.


File: tablicious.info,  Node: isfile,  Next: isfolder,  Prev: isduration,  Up: API Alphabetically

9.2.20 isfile
-------------

 -- Function: OUT = isfile (FILE)

     Test whether file exists and is not a folder.

     Tests whether the given file path FILE exists on the filesystem,
     and is not a folder (aka “directory”).  Files of any type except
     for directories are considered files by this function.

     TODO: Handling of symlinks is undetermined as of yet.

     FILE is a charvec containing the path to the file to test.  It may
     be an absolute or relative path.

     This is a new, more specific replacement for ‘exist(file, "file")’.
     Unlike ‘exist’, ‘isfile’ will not search the Octave load path for
     files.

     The underlying logic defers to ‘stat(file)’ for determining file
     existence and attributes, so any paths supported by ‘stat’ are also
     supported by ‘isfile’.  In particular, it seems that the ‘~’ alias
     for the home directory is supported, at least on Unix platforms.

     See also: *note isfolder::, ‘exist’


File: tablicious.info,  Node: isfolder,  Next: ismissing,  Prev: isfile,  Up: API Alphabetically

9.2.21 isfolder
---------------

 -- Function: OUT = isfolder (FILE)

     Test whether file exists and is a folder.

     Tests whether the given file path FILE exists on the filesystem,
     and is a folder (aka “directory”).

     FILE is a charvec containing the path to the file to test.  It may
     be an absolute or relative path.

     This is a new, more specific replacement for ‘exist(file, "dir")’.
     Unlike ‘exist’, ‘isfolder’ will not search the Octave load path for
     files.

     The underlying logic defers to ‘stat(file)’ for determining file
     existence and attributes, so any paths supported by ‘stat’ are also
     supported by ‘isfolder’.  In particular, it seems that the ‘~’
     alias for the home directory is supported, at least on Unix
     platforms.

     See also: *note isfile::, ‘exist’


File: tablicious.info,  Node: ismissing,  Next: isnannish,  Prev: isfolder,  Up: API Alphabetically

9.2.22 ismissing
----------------

 -- Function: OUT = ismissing (X)
 -- Function: OUT = ismissing (X, INDICATOR)

     Find missing values.

     Determines which elements of X contain missing values.  If an
     indicator input is not provided, standard missing values depending
     on the input type of X are used.

     Standard missing values depend on the data type: * NaN for double,
     single, duration, and calendarDuration * NaT for datetime * ‘' '’
     for char * ‘{''}’ for cellstrs * Integer numeric types have no
     standard missing value; they are never considered missing.  *
     Structs are never considered missing.  * Logicals are never
     considered missing.  * Other types have no standard missing value;
     it is currently an error to call ‘ismissing’ on them without
     providing an indicator.  * This includes cells which are not
     cellstrs; calling ‘ismissing’ on them results in an error.  * TODO:
     Determine whether this should really be an error, or if it should
     default to never considering those types as missing.  * TODO:
     Decide whether, for classdef objects, ‘ismissing’ should
     polymorphically detect isnan()/isnat()/isnannish() methods and use
     those, or whether we should require classes to override ismissing()
     itself.

     If INDICATOR is supplied, it is an array containing multiple
     values, all of which are considered to be missing values.  Only
     indicator values that are type-compatible with the input are
     considered; other indicator value types are silently ignored.  This
     is by design, so you can pass an indicator that holds sentinel
     values for disparate types in to ismissing() used for any type, or
     for compound types like table.

     Indicators are currently not supported for struct or logical
     inputs.  This is probably a bug.

     Table defines its own ismissing() method which respects individual
     variables’ data types; see *note table.ismissing::.


File: tablicious.info,  Node: isnannish,  Next: localdate,  Prev: ismissing,  Up: API Alphabetically

9.2.23 isnannish
----------------

 -- Function: OUT = isnannish (X)

     Test if elements are NaN or NaN-like

     Tests if input elements are NaN, NaT, or otherwise NaN-like.  This
     is true if isnan() or isnat() returns true, and is false for types
     that do not support isnan() or isnat().

     This function only exists because:

     a) Matlab decided to call their NaN values for datetime "NaT"
     instead, and test for them with a different "isnat()" function, and
     b) isnan() errors out for some types that do not support isnan(),
     like cells.

     isnannish() smooths over those differences so you can call it
     polymorphically on any input type.

     Under normal operation, isnannish() should not throw an error for
     any type or value of input.

     See also: ‘isnan’, ‘isnat’, *note ismissing::, *note eqn::,
     ‘isequaln’


File: tablicious.info,  Node: localdate,  Next: milliseconds,  Prev: isnannish,  Up: API Alphabetically

9.2.24 localdate
----------------

 -- Class: localdate

     Represents a complete day using the Gregorian calendar.

     This class is useful for indexing daily-granularity data or
     representing time periods that cover an entire day in local time
     somewhere.  The major purpose of this class is "type safety", to
     prevent time-of-day values from sneaking in to data sets that
     should be daily only.  As a secondary benefit, this uses less
     memory than datetimes.

 -- Instance Variable of localdate: ‘double’ dnums

     The underlying datenum values that represent the days.  The
     datenums are at the midnight that is at the start of the day it
     represents.

     These are doubles, but they are restricted to be integer-valued, so
     they represent complete days, with no time-of-day component.

 -- Instance Variable of localdate: ‘char’ Format

     The format to display this ‘localdate’ in.  Currently unsupported.

* Menu:

* localdate.localdate::
* localdate.NaT::
* localdate.ymd::
* localdate.dispstrs::
* localdate.datestr::
* localdate.datestrs::
* localdate.datestruct::
* localdate.posixtime::
* localdate.datenum::
* localdate.isnat::
* localdate.isnan::


File: tablicious.info,  Node: localdate.localdate,  Next: localdate.NaT,  Up: localdate

9.2.24.1 localdate.localdate
............................

 -- Constructor: OBJ = localdate ()

     Constructs a new scalar ‘localdate’ containing the current local
     date.

 -- Constructor: OBJ = localdate (DATENUMS)
 -- Constructor: OBJ = localdate (DATESTRS)
 -- Constructor: OBJ = localdate (Y, M, D)
 -- Constructor: OBJ = localdate (..., ‘'Format'’, FORMAT)

     Constructs a new ‘localdate’ array based on input values.


File: tablicious.info,  Node: localdate.NaT,  Next: localdate.ymd,  Prev: localdate.localdate,  Up: localdate

9.2.24.2 localdate.NaT
......................

 -- Static Method: OUT = localdate.NaT ()
 -- Static Method: OUT = localdate.NaT (SZ)

     “Not-a-Time”: Creates NaT-valued arrays.

     Constructs a new ‘datetime’ array of all ‘NaT’ values of the given
     size.  If no input SZ is given, the result is a scalar ‘NaT’.

     ‘NaT’ is the ‘datetime’ equivalent of ‘NaN’.  It represents a
     missing or invalid value.  ‘NaT’ values never compare equal to,
     greater than, or less than any value, including other ‘NaT’s.
     Doing arithmetic with a ‘NaT’ and any other value results in a
     ‘NaT’.

     This static method is provided because the global ‘NaT’ function
     creates ‘datetime’s, not ‘localdate’s


File: tablicious.info,  Node: localdate.ymd,  Next: localdate.dispstrs,  Prev: localdate.NaT,  Up: localdate

9.2.24.3 localdate.ymd
......................

 -- Method: [Y, M, D] = ymd (OBJ)

     Get the Year, Month, and Day components of OBJ.

     Returns double arrays the same size as ‘obj’.


File: tablicious.info,  Node: localdate.dispstrs,  Next: localdate.datestr,  Prev: localdate.ymd,  Up: localdate

9.2.24.4 localdate.dispstrs
...........................

 -- Method: OUT = dispstrs (OBJ)

     Get display strings for each element of OBJ.

     Returns a cellstr the same size as OBJ.


File: tablicious.info,  Node: localdate.datestr,  Next: localdate.datestrs,  Prev: localdate.dispstrs,  Up: localdate

9.2.24.5 localdate.datestr
..........................

 -- Method: OUT = datestr (OBJ)
 -- Method: OUT = datestr (OBJ, ...)

     Format OBJ as date strings.  Supports all arguments that core
     Octave’s ‘datestr’ does.

     Returns date strings as a 2-D char array.


File: tablicious.info,  Node: localdate.datestrs,  Next: localdate.datestruct,  Prev: localdate.datestr,  Up: localdate

9.2.24.6 localdate.datestrs
...........................

 -- Method: OUT = datestrs (OBJ)
 -- Method: OUT = datestrs (OBJ, ...)

     Format OBJ as date strings, returning cellstr.  Supports all
     arguments that core Octave’s ‘datestr’ does.

     Returns a cellstr array the same size as OBJ.


File: tablicious.info,  Node: localdate.datestruct,  Next: localdate.posixtime,  Prev: localdate.datestrs,  Up: localdate

9.2.24.7 localdate.datestruct
.............................

 -- Method: OUT = datestruct (OBJ)

     Converts this to a "datestruct" broken-down time structure.

     A "datestruct" is a format of struct that Chrono came up with.  It
     is a scalar struct with fields Year, Month, and Day, each
     containing a double array the same size as the date array it
     represents.  This format differs from the "datestruct" used by
     ‘datetime’ in that it lacks Hour, Minute, and Second components.
     This is done for efficiency.

     The values in the returned broken-down time are those of the local
     time in this’ defined time zone, if it has one.

     Returns a struct with fields Year, Month, and Day.  Each field
     contains a double array of the same size as this.


File: tablicious.info,  Node: localdate.posixtime,  Next: localdate.datenum,  Prev: localdate.datestruct,  Up: localdate

9.2.24.8 localdate.posixtime
............................

 -- Method: OUT = posixtime (OBJ)

     Converts this to POSIX time values for midnight of OBJ’s days.

     Converts this to POSIX time values that represent the same date.
     The returned values will be doubles that will not include
     fractional second values.  The times returned are those of midnight
     UTC on OBJ’s days.

     Returns double array of same size as this.


File: tablicious.info,  Node: localdate.datenum,  Next: localdate.isnat,  Prev: localdate.posixtime,  Up: localdate

9.2.24.9 localdate.datenum
..........................

 -- Method: OUT = datenum (OBJ)

     Convert this to datenums that represent midnight on OBJ’s days.

     Returns double array of same size as this.


File: tablicious.info,  Node: localdate.isnat,  Next: localdate.isnan,  Prev: localdate.datenum,  Up: localdate

9.2.24.10 localdate.isnat
.........................

 -- Method: OUT = isnat (OBJ)

     True if input elements are NaT.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: localdate.isnan,  Prev: localdate.isnat,  Up: localdate

9.2.24.11 localdate.isnan
.........................

 -- Method: OUT = isnan (OBJ)

     True if input elements are NaT. This is an alias for ‘isnat’ to
     support type compatibility and polymorphic programming.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: milliseconds,  Next: minutes,  Prev: localdate,  Up: API Alphabetically

9.2.25 milliseconds
-------------------

 -- Function File: OUT = milliseconds (X)
     Create a ‘duration’ X milliseconds long, or get the milliseconds in
     a ‘duration’ X.

     If input is numeric, returns a ‘duration’ array that is that many
     milliseconds in time.

     If input is a ‘duration’, converts the ‘duration’ to a number of
     milliseconds.

     Returns an array the same size as X.


File: tablicious.info,  Node: minutes,  Next: missing,  Prev: milliseconds,  Up: API Alphabetically

9.2.26 minutes
--------------

 -- Function File: OUT = hours (X)
     Create a ‘duration’ X hours long, or get the hours in a ‘duration’
     X.


File: tablicious.info,  Node: missing,  Next: mustBeA,  Prev: minutes,  Up: API Alphabetically

9.2.27 missing
--------------

 -- Class: missing

     Generic auto-converting missing value.

     ‘missing’ is a generic missing value that auto-converts to other
     types.

     A ‘missing’ array indicates a missing value, of no particular type.
     It auto- converts to other types when it is combined with them via
     concatenation or other array combination operations.

     This class is currently EXPERIMENTAL. Use at your own risk.

     Note: This class does not actually work for assignment.  If you do
     this:

            x = 1:5
            x(3) = missing

     It’s supposed to work, but I can’t figure out how to do this in a
     normal classdef object, because there doesn’t seem to be any
     function that’s implicitly called for type conversion in that
     assignment.  Darn it.

* Menu:

* missing.missing::
* missing.dispstrs::
* missing.ismissing::
* missing.isnan::
* missing.isnannish::


File: tablicious.info,  Node: missing.missing,  Next: missing.dispstrs,  Up: missing

9.2.27.1 missing.missing
........................

 -- Constructor: OBJ = missing ()

     Constructs a scalar ‘missing’ array.

     The constructor takes no arguments, since there’s only one
     ‘missing’ value.


File: tablicious.info,  Node: missing.dispstrs,  Next: missing.ismissing,  Prev: missing.missing,  Up: missing

9.2.27.2 missing.dispstrs
.........................

 -- Method: OUT = dispstrs (OBJ)

     Display strings.

     Gets display strings for each element in OBJ.

     For ‘missing’, the display strings are always ‘'<missing>'’.

     Returns a cellstr the same size as OBJ.


File: tablicious.info,  Node: missing.ismissing,  Next: missing.isnan,  Prev: missing.dispstrs,  Up: missing

9.2.27.3 missing.ismissing
..........................

 -- Method: OUT = ismissing (OBJ)

     Test whether elements are missing values.

     ‘ismissing’ is always true for ‘missing’ arrays.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: missing.isnan,  Next: missing.isnannish,  Prev: missing.ismissing,  Up: missing

9.2.27.4 missing.isnan
......................

 -- Method: OUT = isnan (OBJ)

     Test whether elements are NaN.

     ‘isnan’ is always true for ‘missing’ arrays.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: missing.isnannish,  Prev: missing.isnan,  Up: missing

9.2.27.5 missing.isnannish
..........................

 -- Method: OUT = isnannish (OBJ)

     Test whether elements are NaN-like.

     ‘isnannish’ is always true for ‘missing’ arrays.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: mustBeA,  Next: mustBeCellstr,  Prev: missing,  Up: API Alphabetically

9.2.28 mustBeA
--------------

 -- Function File: X = mustBeA (X, TYPE)
 -- Function File: X = mustBeA (X, TYPE, LABEL)

     Requires that input is of a given type.

     Raises an error if the input X is not of type TYPE, as determined
     by ‘isa (x, type)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeCellstr,  Next: mustBeCharvec,  Prev: mustBeA,  Up: API Alphabetically

9.2.29 mustBeCellstr
--------------------

 -- Function File: ‘x’ = mustBeCellstr (X, LABEL)

     Requires that input is a cellstr.

     Raises an error if the input X is not a cellstr (a cell array of
     ‘char’ arrays).

     TODO: Decide whether to require the contained char arrays be
     rowvec/empty.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeCharvec,  Next: mustBeFinite,  Prev: mustBeCellstr,  Up: API Alphabetically

9.2.30 mustBeCharvec
--------------------

 -- Function File: X = mustBeCharvec (X, LABEL)

     Requires that input is a char row vector.

     Raises an error if the input X is not a row vector of ‘char’s.
     ‘char’ row vectors are Octave’s normal representation of single
     strings.  (They are what are produced by ‘'...'’ string literals.)
     As a special case, 0-by-0 empty chars (what is produced by the
     string literal ‘''’) are also considered charvecs.

     This does not differentiate between single-quoted and double-quoted
     strings.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeFinite,  Next: mustBeInteger,  Prev: mustBeCharvec,  Up: API Alphabetically

9.2.31 mustBeFinite
-------------------

 -- Function File: X = mustBeFinite (X, LABEL)

     Requires that input is finite.

     Raises an error if the input X is not finite, as determined by
     ‘isfinite (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeInteger,  Next: mustBeMember,  Prev: mustBeFinite,  Up: API Alphabetically

9.2.32 mustBeInteger
--------------------

 -- Function File: X = mustBeInteger (X, LABEL)

     Requires that input is integer-valued (but not necessarily
     integer-typed).

     Raises an error if any element of the input X is not a finite,
     real, integer-valued numeric value, as determined by various
     checks.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeMember,  Next: mustBeNonempty,  Prev: mustBeInteger,  Up: API Alphabetically

9.2.33 mustBeMember
-------------------

 -- Function File: X = mustBeMember (X, VALID, LABEL)

     Requires that input is a member of a set of given valid values.

     Raises an error if any element of the input X is not a member of
     VALID, as determined by ‘ismember (x)’.

     Note that char inputs may behave weirdly, because of the
     interaction between chars and cellstrs when calling ismember() on
     them.  But it will probably "do what you mean" if you just use it
     naturally.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeNonempty,  Next: mustBeNumeric,  Prev: mustBeMember,  Up: API Alphabetically

9.2.34 mustBeNonempty
---------------------

 -- Function File: X = mustBeNonempty (X, LABEL)

     Requires that input is nonempty.

     Raises an error if the input X is not empty, as determined by ‘!
     isempty (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeNumeric,  Next: mustBeReal,  Prev: mustBeNonempty,  Up: API Alphabetically

9.2.35 mustBeNumeric
--------------------

 -- Function File: X = mustBeNumeric (X, LABEL)

     Requires that input is numeric.

     Raises an error if the input X is not numeric, as determined by
     ‘isnumeric (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeReal,  Next: mustBeSameSize,  Prev: mustBeNumeric,  Up: API Alphabetically

9.2.36 mustBeReal
-----------------

 -- Function File: X = mustBeReal (X, LABEL)

     Requires that input is finite.

     Raises an error if the input X is not real, as determined by
     ‘isreal (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeSameSize,  Next: mustBeScalar,  Prev: mustBeReal,  Up: API Alphabetically

9.2.37 mustBeSameSize
---------------------

 -- Function File: [A, B] = mustBeSameSize (A, B, LABELA, LABELB)

     Requires that the inputs are the same size.

     Raises an error if the inputs A and B are not the same size, as
     determined by ‘isequal (size (a), size (b))’.

     LABELA and LABELB are optional inputs that determine how the input
     will be described in error messages.  If not supplied, ‘inputname
     (...)’ is used, and if that is empty, it falls back to "input 1"
     and "input 2".


File: tablicious.info,  Node: mustBeScalar,  Next: mustBeScalarLogical,  Prev: mustBeSameSize,  Up: API Alphabetically

9.2.38 mustBeScalar
-------------------

 -- Function File: X = mustBeScalar (X, LABEL)

     Requires that input is scalar.

     Raises an error if the input X is not scalar, as determined by
     ‘isscalar (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeScalarLogical,  Next: mustBeVector,  Prev: mustBeScalar,  Up: API Alphabetically

9.2.39 mustBeScalarLogical
--------------------------

 -- Function File: X = mustBeScalarLogical (X, LABEL)

     Requires that input is a scalar logical.

     Raises an error if the input X is not scalar, as determined by
     ‘isscalar (x) && islogical (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeVector,  Next: NaT,  Prev: mustBeScalarLogical,  Up: API Alphabetically

9.2.40 mustBeVector
-------------------

 -- Function File: X = mustBeVector (X, LABEL)

     Requires that input is a vector or empty.

     Raises an error if the input X is not a row vector and is not
     0-by-0 empty.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: NaT,  Next: octave.chrono.dummy_function,  Prev: mustBeVector,  Up: API Alphabetically

9.2.41 NaT
----------

 -- Function: OUT = NaT ()
 -- Function: OUT = NaT (SZ)

     “Not-a-Time”.  Creates NaT-valued arrays.

     Constructs a new ‘datetime’ array of all ‘NaT’ values of the given
     size.  If no input SZ is given, the result is a scalar ‘NaT’.

     ‘NaT’ is the ‘datetime’ equivalent of ‘NaN’.  It represents a
     missing or invalid value.  ‘NaT’ values never compare equal to,
     greater than, or less than any value, including other ‘NaT’s.
     Doing arithmetic with a ‘NaT’ and any other value results in a
     ‘NaT’.


File: tablicious.info,  Node: octave.chrono.dummy_function,  Next: octave.chrono.DummyClass,  Prev: NaT,  Up: API Alphabetically

9.2.42 octave.chrono.dummy_function
-----------------------------------

 -- Function: OUT = dummy_function (X)

     A dummy function just for testing the doco tools.

     Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Curabitur
     ullamcorper pulvinar ligula, sit amet accumsan turpis dapibus at.
     Ut sit amet quam orci.  Donec vel mauris elementum massa pretium
     tincidunt.


File: tablicious.info,  Node: octave.chrono.DummyClass,  Next: octave.dataset,  Prev: octave.chrono.dummy_function,  Up: API Alphabetically

9.2.43 octave.chrono.DummyClass
-------------------------------

 -- Class: DummyClass

     A do-nothing class just for testing the doco tools.

     Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Curabitur
     ullamcorper pulvinar ligula, sit amet accumsan turpis dapibus at.
     Ut sit amet quam orci.  Donec vel mauris elementum massa pretium
     tincidunt.

 -- Instance Variable of DummyClass: ‘double’ x

     A x.  Has no semantics.

 -- Instance Variable of DummyClass: ‘double’ y

     A y.  Has no semantics.

* Menu:

* octave.chrono.DummyClass.DummyClass::
* octave.chrono.DummyClass.foo::
* octave.chrono.DummyClass.bar::


File: tablicious.info,  Node: octave.chrono.DummyClass.DummyClass,  Next: octave.chrono.DummyClass.foo,  Up: octave.chrono.DummyClass

9.2.43.1 octave.chrono.DummyClass.DummyClass
............................................

 -- Constructor: OBJ = octave.chrono.DummyClass ()

     Constructs a new scalar ‘DummyClass’ with default values.

 -- Constructor: OBJ = octave.chrono.DummyClass (X, Y)

     Constructs a new ‘DummyClass’ with the specified values.


File: tablicious.info,  Node: octave.chrono.DummyClass.foo,  Next: octave.chrono.DummyClass.bar,  Prev: octave.chrono.DummyClass.DummyClass,  Up: octave.chrono.DummyClass

9.2.43.2 octave.chrono.DummyClass.foo
.....................................

 -- Method: OUT = foo (OBJ)

     Computes a foo value.

     Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Curabitur
     ullamcorper pulvinar ligula, sit amet accumsan turpis dapibus at.
     Ut sit amet quam orci.  Donec vel mauris elementum massa pretium
     tincidunt.


File: tablicious.info,  Node: octave.chrono.DummyClass.bar,  Prev: octave.chrono.DummyClass.foo,  Up: octave.chrono.DummyClass

9.2.43.3 octave.chrono.DummyClass.bar
.....................................

 -- Method: OUT = bar (OBJ)

     Computes a bar value.

     Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Curabitur
     ullamcorper pulvinar ligula, sit amet accumsan turpis dapibus at.
     Ut sit amet quam orci.  Donec vel mauris elementum massa pretium
     tincidunt.


File: tablicious.info,  Node: octave.dataset,  Next: octave.datasets,  Prev: octave.chrono.DummyClass,  Up: API Alphabetically

9.2.44 octave.dataset
---------------------

 -- Class: dataset

     The ‘dataset’ class provides convenient access to the various
     datasets included with Tablicious.

     This class just contains a bunch of static methods, each of which
     loads the dataset of that name.  It’s provided so you can use tab
     completion on the dataset list.

* Menu:

* octave.dataset.AirPassengers::
* octave.dataset.airmiles::
* octave.dataset.beavers::
* octave.dataset.iris::


File: tablicious.info,  Node: octave.dataset.AirPassengers,  Next: octave.dataset.airmiles,  Up: octave.dataset

9.2.44.1 octave.dataset.AirPassengers
.....................................

 -- Static Method: OUT = AirPassengers ()

     Monthly Airline Passenger Numbers 1949-1960


File: tablicious.info,  Node: octave.dataset.airmiles,  Next: octave.dataset.beavers,  Prev: octave.dataset.AirPassengers,  Up: octave.dataset

9.2.44.2 octave.dataset.airmiles
................................

 -- Static Method: OUT = airmiles ()

     Passenger Miles on Commercial US Airlines, 1937-1960


File: tablicious.info,  Node: octave.dataset.beavers,  Next: octave.dataset.iris,  Prev: octave.dataset.airmiles,  Up: octave.dataset

9.2.44.3 octave.dataset.beavers
...............................

 -- Static Method: OUT = beavers ()

     Body Temperature Series of Two Beavers


File: tablicious.info,  Node: octave.dataset.iris,  Prev: octave.dataset.beavers,  Up: octave.dataset

9.2.44.4 octave.dataset.iris
............................

 -- Static Method: OUT = iris ()

     The Fisher Iris set: measurements for various flowers


File: tablicious.info,  Node: octave.datasets,  Next: pp,  Prev: octave.dataset,  Up: API Alphabetically

9.2.45 octave.datasets
----------------------

 -- Class: datasets

     Example dataset collection.

     ‘datasets’ is a collection of example datasets to go with the
     Tablicious package.

     The ‘datasets’ class provides methods for listing and loading the
     example datasets.

* Menu:

* octave.datasets.list::
* octave.datasets.load::


File: tablicious.info,  Node: octave.datasets.list,  Next: octave.datasets.load,  Up: octave.datasets

9.2.45.1 octave.datasets.list
.............................

 -- Static Method: list ()
 -- Static Method: OUT = list ()

     List all datasets.

     Lists all the example datasets known to this class.  If the output
     is captured, returns the list as a table.  If the output is not
     captured, displays the list.

     Returns a table with variables Name, Description, and possibly
     more.


File: tablicious.info,  Node: octave.datasets.load,  Prev: octave.datasets.list,  Up: octave.datasets

9.2.45.2 octave.datasets.load
.............................

 -- Static Method: load (DATASETNAME)
 -- Static Method: OUT = load (DATASETNAME)

     Load a specified dataset.

     DATASETNAME is the name of the dataset to load, as found in the
     ‘Name’ column of the dataset list.


File: tablicious.info,  Node: pp,  Next: rmmissing,  Prev: octave.datasets,  Up: API Alphabetically

9.2.46 pp
---------

 -- Function: pp (X)
 -- Function: pp (A, B, C, ...)
 -- Function: pp (‘'A'’, ‘'B'’, ‘'C'’, ...)
 -- Function: pp ‘A’ ‘B’ ‘C’ ...

     Alias for prettyprint, for interactive use.

     This is an alias for prettyprint(), with additional name-conversion
     magic.

     If you pass in a char, instead of pretty-printing that directly, it
     will grab and pretty-print the variable of that name from the
     caller’s workspace.  This is so you can conveniently run it from
     the command line.


File: tablicious.info,  Node: rmmissing,  Next: scalarexpand,  Prev: pp,  Up: API Alphabetically

9.2.47 rmmissing
----------------

 -- Function: [OUT, TF] = rmmissing (X)
 -- Function: [OUT, TF] = rmmissing (X, DIM)
 -- Function: [OUT, TF] = rmmissing (..., ‘'MinNumMissing'’,
          MINNUMMISSING)

     Remove missing values.

     If X is a vector, removes elements with missing values.  If X is a
     matrix, removes rows or columns with missing data elements.

     DIM is the dimension to operate along.  Specifying a dimension
     forces ‘rmmissing’ to operate in matrix instead of vector mode.

     MINNUMMISSING indicates how many missing element values there must
     be in a row or column for it to be considered missing and this
     removed.  This option is only used in matrix mode; it is silently
     ignored in vector mode.

     Returns: OUT - the input, with missing elements or rows or columns
     removed TF - a logical index vector indicating which elements,
     rows, or columns were removed


File: tablicious.info,  Node: scalarexpand,  Next: seconds,  Prev: rmmissing,  Up: API Alphabetically

9.2.48 scalarexpand
-------------------

_Not documented_


File: tablicious.info,  Node: seconds,  Next: size2str,  Prev: scalarexpand,  Up: API Alphabetically

9.2.49 seconds
--------------

 -- Function File: OUT = seconds (X)
     Create a ‘duration’ X seconds long, or get the seconds in a
     ‘duration’ X.

     If input is numeric, returns a ‘duration’ array that is that many
     seconds in time.

     If input is a ‘duration’, converts the ‘duration’ to a number of
     seconds.

     Returns an array the same size as X.


File: tablicious.info,  Node: size2str,  Next: standardizeMissing,  Prev: seconds,  Up: API Alphabetically

9.2.50 size2str
---------------

_Not documented_


File: tablicious.info,  Node: standardizeMissing,  Next: startsWith,  Prev: size2str,  Up: API Alphabetically

9.2.51 standardizeMissing
-------------------------

 -- Function: OUT = standardizeMissing (X, INDICATOR)

     Insert standard missing values.

     Standardizes missing values in X by replacing the values listed in
     INDICATOR with the standard missing values for the type of X.

     Standard missing values depend on the data type: * NaN for double,
     single, duration, and calendarDuration * NaT for datetime * ‘' '’
     for char * ‘{''}’ for cellstrs * Integer numeric types have no
     standard missing value; they are never considered missing.  *
     Structs are never considered missing.  * Logicals are never
     considered missing.

     See also: *note table.standardizeMissing::


File: tablicious.info,  Node: startsWith,  Next: string,  Prev: standardizeMissing,  Up: API Alphabetically

9.2.52 startsWith
-----------------

 -- Function: OUT = startsWith (STR, PATTERN)
 -- Function: OUT = startsWith (..., ‘'IgnoreCase'’, IGNORECASE)

     Test if strings start with a pattern.

     Tests whether the given strings start with the given pattern(s).

     STR (char, cellstr, or string) is a list of strings to compare
     against PATTERN.

     PATTERN (char, cellstr, or string) is a list of patterns to match.
     These are literal plain string patterns, not regex patterns.  If
     more than one pattern is supplied, the return value is true if the
     string matched any of them.

     Returns a logical array of the same size as the string array
     represented by STR.


File: tablicious.info,  Node: string,  Next: struct2table,  Prev: startsWith,  Up: API Alphabetically

9.2.53 string
-------------

 -- Class: string

     A string array of Unicode strings.

     A string array is an array of strings, where each array element is
     a single string.

     The string class represents strings, where: - Each element of a
     string array is a single string - A single string is a
     1-dimensional row vector of Unicode characters - Those characters
     are encoded in UTF-8

     This should correspond pretty well to what people think of as
     strings, and is pretty compatible with people’s typical notion of
     strings in Octave.

     String arrays also have a special “missing” value, that is like the
     string equivalent of NaN for doubles or “undefined” for
     categoricals, or SQL NULL.

     This is a slightly higher-level and more strongly-typed way of
     representing strings than cellstrs are.  (A cellstr array is of
     type cell, not a text- specific type, and allows assignment of
     non-string data into it.)

     Be aware that while string arrays interconvert with Octave chars
     and cellstrs, Octave char elements represent 8-bit UTF-8 code
     units, not Unicode code points.

     This class really serves three roles.  - It is an object wrapper
     around Octave’s base primitive character types.  - It adds
     ismissing() semantics.  - And it introduces Unicode support.  Not
     clear whether it’s a good fit to have the Unicode support wrapped
     up in this.  Maybe it should just be a simple object wrapper
     wrapper, and defer Unicode semantics to when core Octave adopts
     them for char and cellstr.  On the other hand, because Octave chars
     are UTF-8, not UCS-2, some methods like strlength() and reverse()
     are just going to be wrong if they delegate straight to chars.

     “Missing” string values work like NaNs.  They are never considered
     equal, less than, or greater to any other string, including other
     missing strings.  This applies to set membership and other
     equivalence tests.

     The current implementation depends on Java for its Unicode and
     encoding support.  This means your Octave session must be running
     Java to call those methods.  This should be changed in the future
     to use a native C/C++ library and avoid the Java dependency,
     especially before this class is merged into core Octave.

     TODO: Need to decide how far to go with Unicode semantics, and how
     much to just make this an object wrapper over cellstr and defer to
     Octave’s existing char/string-handling functions.

     TODO: demote_strings should probably be static or global, so that
     other functions can use it to hack themselves into being
     string-aware.

* Menu:

* string.string::
* string.isstring::
* string.dispstrs::
* string.sizeof::
* string.ismissing::
* string.isnannish::
* string.cellstr::
* string.cell::
* string.char::
* string.encode::
* string.strlength_bytes::
* string.strlength::
* string.reverse_bytes::
* string.reverse::
* string.strcat::
* string.lower::
* string.upper::
* string.erase::
* string.strrep::
* string.strfind::
* string.regexprep::
* string.strcmp::
* string.cmp::
* string.missing::
* string.decode::


File: tablicious.info,  Node: string.string,  Next: string.isstring,  Up: string

9.2.53.1 string.string
......................

 -- Constructor: OBJ = string ()
 -- Constructor: OBJ = string (IN)

     Construct a new string array.

     The zero-argument constructor creates a new scalar string array
     whose value is the empty string.  TODO: Determine if this should
     actually return a “missing” string instead.

     The other constructors construct a new string array by converting
     various types of inputs.  - chars and cellstrs are converted via
     cellstr() - numerics are converted via num2str() - datetimes are
     converted via datestr()


File: tablicious.info,  Node: string.isstring,  Next: string.dispstrs,  Prev: string.string,  Up: string

9.2.53.2 string.isstring
........................

 -- Method: OUT = isstring (OBJ)

     Test if input is a string array.

     ‘isstring’ is always true for ‘string’ inputs.

     Returns a scalar logical.


File: tablicious.info,  Node: string.dispstrs,  Next: string.sizeof,  Prev: string.isstring,  Up: string

9.2.53.3 string.dispstrs
........................

 -- Method: OUT = dispstrs (OBJ)

     Display strings for array elements.

     Gets display strings for all the elements in OBJ.  These display
     strings will either be the string contents of the element, enclosed
     in ‘"..."’, and with CR/LF characters replaced with ‘'\r'’ and
     ‘'\n'’ escape sequences, or ‘"<missing>"’ for missing values.

     Returns a cellstr of the same size as OBJ.


File: tablicious.info,  Node: string.sizeof,  Next: string.ismissing,  Prev: string.dispstrs,  Up: string

9.2.53.4 string.sizeof
......................

 -- Method: OUT = sizeof (OBJ)

     Size of array in bytes.


File: tablicious.info,  Node: string.ismissing,  Next: string.isnannish,  Prev: string.sizeof,  Up: string

9.2.53.5 string.ismissing
.........................

 -- Method: OUT = ismissing (OBJ)

     Test whether array elements are missing.

     For ‘string’ arrays, only the special “missing” value is considered
     missing.  Empty strings are not considered missing, the way they
     are with cellstrs.

     Returns a logical array the same size as ‘obj’.


File: tablicious.info,  Node: string.isnannish,  Next: string.cellstr,  Prev: string.ismissing,  Up: string

9.2.53.6 string.isnannish
.........................

 -- Method: OUT = isnannish (OBJ)

     Test whether array elements are NaN-like.

     Missing values are considered nannish; any other string value is
     not.

     Returns a logical array of the same size as OBJ.


File: tablicious.info,  Node: string.cellstr,  Next: string.cell,  Prev: string.isnannish,  Up: string

9.2.53.7 string.cellstr
.......................

 -- Method: OUT = cellstr (OBJ)

     Convert to cellstr.

     Converts OBJ to a cellstr.  Missing values are converted to ‘''’.

     Returns a cellstr array of the same size as OBJ.


File: tablicious.info,  Node: string.cell,  Next: string.char,  Prev: string.cellstr,  Up: string

9.2.53.8 string.cell
....................

 -- Method: OUT = cell (OBJ)

     Convert to cell array.

     Converts this to a cell, which will be a cellstr.  Missing values
     are converted to ‘''’.

     This method returns the same values as ‘cellstr(obj)’; it is just
     provided for interface compatibility purposes.

     Returns a cell array of the same size as OBJ.


File: tablicious.info,  Node: string.char,  Next: string.encode,  Prev: string.cell,  Up: string

9.2.53.9 string.char
....................

 -- Method: OUT = char (OBJ)

     Convert to char array.

     Converts OBJ to a 2-D char array.  It will have as many rows as OBJ
     has elements.

     It is an error to convert missing-valued ‘string’ arrays to char.
     (NOTE: This may change in the future; it may be more appropriate)
     to convert them to space-padded empty strings.)

     Returns 2-D char array.


File: tablicious.info,  Node: string.encode,  Next: string.strlength_bytes,  Prev: string.char,  Up: string

9.2.53.10 string.encode
.......................

 -- Method: OUT = encode (OBJ, CHARSETNAME)

     Encode string in a given character encoding.

     OBJ must be scalar.

     CHARSETNAME (charvec) is the name of a character encoding.  (TODO:
     Document what determines the set of valid encoding names.)

     Returns the encoded string as a ‘uint8’ vector.

     See also: *note string.decode::.


File: tablicious.info,  Node: string.strlength_bytes,  Next: string.strlength,  Prev: string.encode,  Up: string

9.2.53.11 string.strlength_bytes
................................

 -- Method: OUT = strlength_bytes (OBJ)

     String length in bytes.

     Gets the length of each string in OBJ, counted in Unicode UTF-8
     code units (bytes).  This is the same as ‘numel(str)’ for the
     corresponding Octave char vector for each string, but may not be
     what you actually want to use.  You may want ‘strlength’ instead.

     Returns double array of the same size as OBJ.  Returns NaNs for
     missing strings.

     See also: *note string.strlength::


File: tablicious.info,  Node: string.strlength,  Next: string.reverse_bytes,  Prev: string.strlength_bytes,  Up: string

9.2.53.12 string.strlength
..........................

 -- Method: OUT = strlength (OBJ)

     String length in characters.

     Gets the length of each string, counted in Unicode characters (code
     points).  This is the string length method you probably want to
     use, not ‘strlength_bytes’.

     Returns double array of the same size as OBJ.  Returns NaNs for
     missing strings.

     See also: *note string.strlength_bytes::


File: tablicious.info,  Node: string.reverse_bytes,  Next: string.reverse,  Prev: string.strlength,  Up: string

9.2.53.13 string.reverse_bytes
..............................

 -- Method: OUT = reverse_bytes (OBJ)

     Reverse string, byte-wise.

     Reverses the bytes in each string in OBJ.  This operates on bytes
     (Unicode code units), not characters.

     This may well produce invalid strings as a result, because
     reversing a UTF-8 byte sequence does not necessarily produce
     another valid UTF-8 byte sequence.

     You probably do not want to use this method.  You probably want to
     use ‘string.reverse’ instead.

     Returns a string array the same size as OBJ.

     See also: *note string.reverse::


File: tablicious.info,  Node: string.reverse,  Next: string.strcat,  Prev: string.reverse_bytes,  Up: string

9.2.53.14 string.reverse
........................

 -- Method: OUT = reverse (OBJ)

     Reverse string, character-wise.

     Reverses the characters in each string in OBJ.  This operates on
     Unicode characters (code points), not on bytes, so it is guaranteed
     to produce valid UTF-8 as its output.

     Returns a string array the same size as OBJ.


File: tablicious.info,  Node: string.strcat,  Next: string.lower,  Prev: string.reverse,  Up: string

9.2.53.15 string.strcat
.......................

 -- Method: OUT = strcat (VARARGIN)

     String concatenation.

     Concatenates the corresponding elements of all the input arrays,
     string-wise.  Inputs that are not string arrays are converted to
     string arrays.

     The semantics of concatenating missing strings with non-missing
     strings has not been determined yet.

     Returns a string array the same size as the scalar expansion of its
     inputs.


File: tablicious.info,  Node: string.lower,  Next: string.upper,  Prev: string.strcat,  Up: string

9.2.53.16 string.lower
......................

 -- Method: OUT = lower (OBJ)

     Convert to lower case.

     Converts all the characters in all the strings in OBJ to lower
     case.

     This currently delegates to Octave’s own ‘lower()’ function to do
     the conversion, so whatever character class handling it has, this
     has.

     Returns a string array of the same size as OBJ.


File: tablicious.info,  Node: string.upper,  Next: string.erase,  Prev: string.lower,  Up: string

9.2.53.17 string.upper
......................

 -- Method: OUT = upper (OBJ)

     Convert to upper case.

     Converts all the characters in all the strings in OBJ to upper
     case.

     This currently delegates to Octave’s own ‘upper()’ function to do
     the conversion, so whatever character class handling it has, this
     has.

     Returns a string array of the same size as OBJ.


File: tablicious.info,  Node: string.erase,  Next: string.strrep,  Prev: string.upper,  Up: string

9.2.53.18 string.erase
......................

 -- Method: OUT = erase (OBJ, MATCH)

     Erase matching substring.

     Erases the substrings in OBJ which match the MATCH input.

     Returns a string array of the same size as OBJ.


File: tablicious.info,  Node: string.strrep,  Next: string.strfind,  Prev: string.erase,  Up: string

9.2.53.19 string.strrep
.......................

 -- Method: OUT = strrep (OBJ, MATCH, REPLACEMENT)
 -- Method: OUT = strrep (..., VARARGIN)

     Replace occurrences of pattern with other string.

     Replaces matching substrings in OBJ with a given replacement
     string.

     VARARGIN is passed along to the core Octave ‘strrep’ function.
     This supports whatever options it does.  TODO: Maybe document what
     those options are.

     Returns a string array of the same size as OBJ.


File: tablicious.info,  Node: string.strfind,  Next: string.regexprep,  Prev: string.strrep,  Up: string

9.2.53.20 string.strfind
........................

 -- Method: OUT = strfind (OBJ, PATTERN)
 -- Method: OUT = strfind (..., VARARGIN)

     Find pattern in string.

     Finds the locations where PATTERN occurs in the strings of OBJ.

     TODO: It’s ambiguous whether a scalar this should result in a
     numeric out or a cell array out.

     Returns either an index vector, or a cell array of index vectors.


File: tablicious.info,  Node: string.regexprep,  Next: string.strcmp,  Prev: string.strfind,  Up: string

9.2.53.21 string.regexprep
..........................

 -- Method: OUT = regexprep (OBJ, PAT, REPSTR)
 -- Method: OUT = regexprep (..., VARARGIN)

     Replace based on regular expression matching.

     Replaces all the substrings matching a given regexp pattern PAT
     with the given replacement text REPSTR.

     Returns a string array of the same size as OBJ.


File: tablicious.info,  Node: string.strcmp,  Next: string.cmp,  Prev: string.regexprep,  Up: string

9.2.53.22 string.strcmp
.......................

 -- Method: OUT = strcmp (A, B)

     String comparison.

     Tests whether each element in A is exactly equal to the
     corresponding element in B. Missing values are not considered equal
     to each other.

     This does the same comparison as ‘A == B’, but is not polymorphic.
     Generally, there is no reason to use ‘strcmp’ instead of ‘==’ or
     ‘eq’ on string arrays, unless you want to be compatible with
     cellstr inputs as well.

     Returns logical array the size of the scalar expansion of A and B.


File: tablicious.info,  Node: string.cmp,  Next: string.missing,  Prev: string.strcmp,  Up: string

9.2.53.23 string.cmp
....................

 -- Method: [OUT, OUTA, OUTB] = cmp (A, B)

     Value ordering comparison, returning -1/0/+1.

     Compares each element of A and B, returning for each element ‘i’
     whether ‘A(i)’ was less than (-1), equal to (0), or greater than
     (1) the corresponding ‘B(i)’.

     TODO: What to do about missing values?  Should missings sort to the
     end (preserving total ordering over the full domain), or should
     their comparisons result in a fourth "null"/"undef" return value,
     probably represented by NaN? FIXME: The current implementation does
     not handle missings.

     Returns a numeric array OUT of the same size as the scalar
     expansion of A and B.  Each value in it will be -1, 0, or 1.

     Also returns scalar-expanded copies of A and B as OUTA and OUTB, as
     a programming convenience.


File: tablicious.info,  Node: string.missing,  Next: string.decode,  Prev: string.cmp,  Up: string

9.2.53.24 string.missing
........................

 -- Static Method: OUT = string.missing (SZ)

     Missing string value.

     Creates a string array of all-missing values of the specified size
     SZ.  If SZ is omitted, creates a scalar missing string.

     Returns a string array of size SZ.


File: tablicious.info,  Node: string.decode,  Prev: string.missing,  Up: string

9.2.53.25 string.decode
.......................

 -- Static Method: OUT = string.decode (BYTES, CHARSETNAME)

     Decode encoded text from bytes.

     Decodes the given encoded text in BYTES according to the specified
     encoding, given by CHARSETNAME.

     Returns a scalar string.

     See also: *note string.encode::


File: tablicious.info,  Node: struct2table,  Next: table,  Prev: string,  Up: API Alphabetically

9.2.54 struct2table
-------------------

 -- Function: OUT = struct2table (S)
 -- Function: OUT = struct2table (..., ‘'AsArray'’, ASARRAY)

     Convert struct to a table.

     Converts the input struct S to a ‘table’.

     S may be a scalar struct or a nonscalar struct array.

     The ASARRAY option is not implemented yet.

     Returns a ‘table’.


File: tablicious.info,  Node: table,  Next: tableOuterFillValue,  Prev: struct2table,  Up: API Alphabetically

9.2.55 table
------------

 -- Class: table

     Tabular data array containing multiple columnar variables.

     A ‘table’ is a tabular data structure that collects multiple
     parallel named variables.  Each variable is treated like a column.
     (Possibly a multi-columned column, if that makes sense.)  The types
     of variables may be heterogeneous.

     A table object is like an SQL table or resultset, or a relation, or
     a DataFrame in R or Pandas.

     A table is an array in itself: its size is NROWS-by-NVARIABLES, and
     you can index along the rows and variables by indexing into the
     table along dimensions 1 and 2.

 -- Instance Variable of table: ‘cellstr’ VariableNames

     The names of the variables in the table, as a cellstr row vector.

 -- Instance Variable of table: ‘cell’ VariableValues

     A cell vector containing the values for each of the variables.
     ‘VariableValues(i)’ corresponds to ‘VariableNames(i)’.

 -- Instance Variable of table: ‘cellstr’ RowNames

     An optional list of row names that identify each row in the table.
     This is a cellstr column vector, if present.

* Menu:

* table.table::
* table.summary::
* table.prettyprint::
* table.table2cell::
* table.table2struct::
* table.table2array::
* table.varnames::
* table.istable::
* table.size::
* table.length::
* table.ndims::
* table.squeeze::
* table.sizeof::
* table.height::
* table.rows::
* table.width::
* table.columns::
* table.numel::
* table.isempty::
* table.ismatrix::
* table.isrow::
* table.iscol::
* table.isvector::
* table.isscalar::
* table.hasrownames::
* table.vertcat::
* table.horzcat::
* table.repmat::
* table.repelem::
* table.setVariableNames::
* table.setRowNames::
* table.resolveVarRef::
* table.subsetrows::
* table.subsetvars::
* table.removevars::
* table.movevars::
* table.setvar::
* table.addvars::
* table.convertvars::
* table.mergevars::
* table.splitvars::
* table.stack::
* table.head::
* table.tail::
* table.join::
* table.innerjoin::
* table.outerjoin::
* table.outerfillvals::
* table.semijoin::
* table.antijoin::
* table.cartesian::
* table.groupby::
* table.grpstats::
* table.rows2vars::
* table.congruentize::
* table.union::
* table.intersect::
* table.setxor::
* table.setdiff::
* table.ismember::
* table.ismissing::
* table.rmmissing::
* table.standardizeMissing::
* table.varfun::
* table.rowfun::
* table.findgroups::
* table.evalWithVars::
* table.restrict::


File: tablicious.info,  Node: table.table,  Next: table.summary,  Up: table

9.2.55.1 table.table
....................

 -- Constructor: OBJ = table ()

     Constructs a new empty (0 rows by 0 variables) table.

 -- Constructor: OBJ = table (VAR1, VAR2, ..., VARN)

     Constructs a new table from the given variables.  The variables
     passed as inputs to this constructor become the variables of the
     table.  Their names are automatically detected from the input
     variable names that you used.

 -- Constructor: OBJ = table (‘'Size'’, SZ, ‘'VariableTypes'’, VARTYPES)

     Constructs a new table of the given size, and with the given
     variable types.  The variables will contain the default value for
     elements of that type.

 -- Constructor: OBJ = table (..., ‘'VariableNames'’, VARNAMES)
 -- Constructor: OBJ = table (..., ‘'RowNames'’, ROWNAMES)

     Specifies the variable names or row names to use in the constructed
     table.  Overrides the implicit names garnered from the input
     variable names.


File: tablicious.info,  Node: table.summary,  Next: table.prettyprint,  Prev: table.table,  Up: table

9.2.55.2 table.summary
......................

 -- Method: summary (OBJ)
 -- Method: S = summary (OBJ)

     Summary of table’s data.

     Displays or returns a summary of data in the input table.  This
     will contain some statistical information on each of its variables.

     This method is not implemented yet.


File: tablicious.info,  Node: table.prettyprint,  Next: table.table2cell,  Prev: table.summary,  Up: table

9.2.55.3 table.prettyprint
..........................

 -- Method: prettyprint (OBJ)

     Display table’s values in tabular format.  This prints the contents
     of the table in human-readable, tabular form.

     Variables which contain objects are displayed using the strings
     returned by their ‘dispstrs’ method, if they define one.


File: tablicious.info,  Node: table.table2cell,  Next: table.table2struct,  Prev: table.prettyprint,  Up: table

9.2.55.4 table.table2cell
.........................

 -- Method: C = table2cell (OBJ)

     Converts table to a cell array.  Each variable in OBJ becomes one
     or more columns in the output, depending on how many columns that
     variable has.

     Returns a cell array with the same number of rows as OBJ, and with
     as many or more columns as OBJ has variables.


File: tablicious.info,  Node: table.table2struct,  Next: table.table2array,  Prev: table.table2cell,  Up: table

9.2.55.5 table.table2struct
...........................

 -- Method: S = table2struct (OBJ)
 -- Method: S = table2struct (..., ‘'ToScalar'’, TRUEORFALSE)

     Converts OBJ to a scalar structure or structure array.

     Row names are not included in the output struct.  To include them,
     you must add them manually: s = table2struct (tbl, ’ToScalar’,
     true); s.RowNames = tbl.Properties.RowNames;

     Returns a scalar struct or struct array, depending on the value of
     the ‘ToScalar’ option.


File: tablicious.info,  Node: table.table2array,  Next: table.varnames,  Prev: table.table2struct,  Up: table

9.2.55.6 table.table2array
..........................

 -- Method: S = table2struct (OBJ)

     Converts OBJ to a homogeneous array.


File: tablicious.info,  Node: table.varnames,  Next: table.istable,  Prev: table.table2array,  Up: table

9.2.55.7 table.varnames
.......................

 -- Method: OUT = varnames (OBJ)

     Get variable names for a table.

     Returns cellstr.


File: tablicious.info,  Node: table.istable,  Next: table.size,  Prev: table.varnames,  Up: table

9.2.55.8 table.istable
......................

 -- Method: TF = istable (OBJ)

     True if input is a table.


File: tablicious.info,  Node: table.size,  Next: table.length,  Prev: table.istable,  Up: table

9.2.55.9 table.size
...................

 -- Method: SZ = size (OBJ)

     Gets the size of a table.

     For tables, the size is [number-of-rows x number-of-variables].
     This is the same as ‘[height(obj), width(obj)]’.


File: tablicious.info,  Node: table.length,  Next: table.ndims,  Prev: table.size,  Up: table

9.2.55.10 table.length
......................

 -- Method: OUT = length (OBJ)

     Length along longest dimension

     Use of ‘length’ is not recommended.  Use ‘numel’ or ‘size’ instead.


File: tablicious.info,  Node: table.ndims,  Next: table.squeeze,  Prev: table.length,  Up: table

9.2.55.11 table.ndims
.....................

 -- Method: OUT = ndims (OBJ)

     Number of dimensions

     For tables, ‘ndims(obj)’ is always 2.


File: tablicious.info,  Node: table.squeeze,  Next: table.sizeof,  Prev: table.ndims,  Up: table

9.2.55.12 table.squeeze
.......................

 -- Method: OBJ = squeeze (OBJ)

     Remove singleton dimensions.

     For tables, this is always a no-op that returns the input
     unmodified, because tables always have exactly 2 dimensions.


File: tablicious.info,  Node: table.sizeof,  Next: table.height,  Prev: table.squeeze,  Up: table

9.2.55.13 table.sizeof
......................

 -- Method: OUT = sizeof (OBJ)

     Approximate size of array in bytes.  For tables, this returns the
     sume of ‘sizeof’ for all of its variables’ arrays, plus the size of
     the VariableNames and any other metadata stored in OBJ.

     This is currently unimplemented.


File: tablicious.info,  Node: table.height,  Next: table.rows,  Prev: table.sizeof,  Up: table

9.2.55.14 table.height
......................

 -- Method: OUT = height (OBJ)

     Number of rows in table.


File: tablicious.info,  Node: table.rows,  Next: table.width,  Prev: table.height,  Up: table

9.2.55.15 table.rows
....................

 -- Method: OUT = rows (OBJ)

     Number of rows in table.


File: tablicious.info,  Node: table.width,  Next: table.columns,  Prev: table.rows,  Up: table

9.2.55.16 table.width
.....................

 -- Method: OUT = width (OBJ)

     Number of variables in table.

     Note that this is not the sum of the number of columns in each
     variable.  It is just the number of variables.


File: tablicious.info,  Node: table.columns,  Next: table.numel,  Prev: table.width,  Up: table

9.2.55.17 table.columns
.......................

 -- Method: OUT = columns (OBJ)

     Number of variables in table.

     Note that this is not the sum of the number of columns in each
     variable.  It is just the number of variables.


File: tablicious.info,  Node: table.numel,  Next: table.isempty,  Prev: table.columns,  Up: table

9.2.55.18 table.numel
.....................

 -- Method: OUT = numel (OBJ)

     Total number of elements in table.

     This is the total number of elements in this table.  This is
     calculated as the sum of numel for each variable.

     NOTE: Those semantics may be wrong.  This may actually need to be
     defined as ‘height(obj) * width(obj)’.  The behavior of ‘numel’ may
     change in the future.


File: tablicious.info,  Node: table.isempty,  Next: table.ismatrix,  Prev: table.numel,  Up: table

9.2.55.19 table.isempty
.......................

 -- Method: OUT = isempty (OBJ)

     Test whether array is empty.

     For tables, ‘isempty’ is true if the number of rows is 0 or the
     number of variables is 0.


File: tablicious.info,  Node: table.ismatrix,  Next: table.isrow,  Prev: table.isempty,  Up: table

9.2.55.20 table.ismatrix
........................

 -- Method: OUT = ismatrix (OBJ)

     Test whether array is a matrix.

     For tables, ‘ismatrix’ is always true, by definition.


File: tablicious.info,  Node: table.isrow,  Next: table.iscol,  Prev: table.ismatrix,  Up: table

9.2.55.21 table.isrow
.....................

 -- Method: OUT = isrow (OBJ)

     Test whether array is a row vector.


File: tablicious.info,  Node: table.iscol,  Next: table.isvector,  Prev: table.isrow,  Up: table

9.2.55.22 table.iscol
.....................

 -- Method: OUT = iscol (OBJ)

     Test whether array is a column vector.

     For tables, ‘iscol’ is true if the input has a single variable.
     The number of columns within that variable does not matter.


File: tablicious.info,  Node: table.isvector,  Next: table.isscalar,  Prev: table.iscol,  Up: table

9.2.55.23 table.isvector
........................

 -- Method: OUT = isvector (OBJ)

     Test whether array is a vector.


File: tablicious.info,  Node: table.isscalar,  Next: table.hasrownames,  Prev: table.isvector,  Up: table

9.2.55.24 table.isscalar
........................

 -- Method: OUT = isscalar (OBJ)

     Test whether array is scalar.


File: tablicious.info,  Node: table.hasrownames,  Next: table.vertcat,  Prev: table.isscalar,  Up: table

9.2.55.25 table.hasrownames
...........................

 -- Method: OUT = hasrownames (OBJ)

     True if this table has row names defined.


File: tablicious.info,  Node: table.vertcat,  Next: table.horzcat,  Prev: table.hasrownames,  Up: table

9.2.55.26 table.vertcat
.......................

 -- Method: OUT = vertcat (VARARGIN)

     Vertical concatenation.

     Combines tables by vertically concatenating them.

     Inputs that are not tables are automatically converted to tables by
     calling table() on them.

     The inputs must have the same number and names of variables, and
     their variable value types and sizes must be cat-compatible.


File: tablicious.info,  Node: table.horzcat,  Next: table.repmat,  Prev: table.vertcat,  Up: table

9.2.55.27 table.horzcat
.......................

 -- Method: OUT = horzcat (VARARGIN)

     Horizontal concatenation.

     Combines tables by horizontally concatenating them.  Inputs that
     are not tables are automatically converted to tables by calling
     table() on them.  Inputs must have all distinct variable names.

     Output has the same RowNames as ‘varargin{1}’.  The variable names
     and values are the result of the concatenation of the variable
     names and values lists from the inputs.


File: tablicious.info,  Node: table.repmat,  Next: table.repelem,  Prev: table.horzcat,  Up: table

9.2.55.28 table.repmat
......................

 -- Method: OUT = repmat (OBJ, SZ)

     Replicate matrix.

     Repmats a table by repmatting each of its variables vertically.

     For tables, repmatting is only supported along dimension 1.  That
     is, the values of sz(2:end) must all be exactly 1.

     Returns a new table with the same variable names and types as tbl,
     but with a possibly different row count.


File: tablicious.info,  Node: table.repelem,  Next: table.setVariableNames,  Prev: table.repmat,  Up: table

9.2.55.29 table.repelem
.......................

 -- Method: OUT = repelem (OBJ, R)
 -- Method: OUT = repelem (OBJ, R_1, R_2)

     Replicate elements of matrix.

     Replicates elements of this table matrix by applying repelem to
     each of its variables.

     Only two dimensions are supported for ‘repelem’ on tables.


File: tablicious.info,  Node: table.setVariableNames,  Next: table.setRowNames,  Prev: table.repelem,  Up: table

9.2.55.30 table.setVariableNames
................................

 -- Method: OUT = setVariableNames (OBJ, NAMES)

     Set variable names.

     Sets the ‘VariableNames’ for this table to a new list of names.

     NAMES is a cellstr vector.  It must have the same number of
     elements as the number of variables in OBJ.


File: tablicious.info,  Node: table.setRowNames,  Next: table.resolveVarRef,  Prev: table.setVariableNames,  Up: table

9.2.55.31 table.setRowNames
...........................

 -- Method: OUT = setRowNames (OBJ, NAMES)

     Set row names.

     Sets the row names on OBJ to NAMES.

     NAMES is a cellstr column vector, with the same number of rows as
     OBJ has.


File: tablicious.info,  Node: table.resolveVarRef,  Next: table.subsetrows,  Prev: table.setRowNames,  Up: table

9.2.55.32 table.resolveVarRef
.............................

 -- Method: [IXVAR, VARNAMES] = resolveVarRef (OBJ, VARREF)
 -- Method: [IXVAR, VARNAMES] = resolveVarRef (OBJ, VARREF, STRICTNESS)

     Resolve a variable reference against this table.

     A VARREF is a numeric or char/cellstr indicator of which variables
     within OBJ are being referenced.

     STRICTNESS controls what to do when the given variable references
     could not be resolved.  It may be ’strict’ (the default) or
     ’lenient’.

     Returns: IXVAR - the indexes of the variables in OBJ VARNAMES - a
     cellstr of the names of the variables in OBJ

     Raises an error if any of the specified variables could not be
     resolved, unless strictness is ’lenient’, in which case it will
     return 0 for the index and ” for the name for each variable which
     could not be resolved.


File: tablicious.info,  Node: table.subsetrows,  Next: table.subsetvars,  Prev: table.resolveVarRef,  Up: table

9.2.55.33 table.subsetrows
..........................

 -- Method: OUT = subsetrows (OBJ, IXROWS)

     Subset table by rows.

     Subsets this table by rows.

     IXROWS may be a numeric or logical index into the rows of OBJ.


File: tablicious.info,  Node: table.subsetvars,  Next: table.removevars,  Prev: table.subsetrows,  Up: table

9.2.55.34 table.subsetvars
..........................

 -- Method: OUT = subsetvars (OBJ, IXVARS)

     Subset table by variables.

     Subsets table OBJ by subsetting it along its variables.

     ixVars may be: - a numeric index vector - a logical index vector -
     ":" - a cellstr vector of variable names

     The resulting table will have its variables reordered to match
     ixVars.


File: tablicious.info,  Node: table.removevars,  Next: table.movevars,  Prev: table.subsetvars,  Up: table

9.2.55.35 table.removevars
..........................

 -- Method: OUT = removevars (OBJ, VARS)

     Remove variables from table.

     Deletes the variables specified by VARS from OBJ.

     VARS may be a char, cellstr, numeric index vector, or logical index
     vector.


File: tablicious.info,  Node: table.movevars,  Next: table.setvar,  Prev: table.removevars,  Up: table

9.2.55.36 table.movevars
........................

 -- Method: OUT = movevars (OBJ, VARS, RELLOCATION, LOCATION)

     Move around variables in a table.

     VARS is a list of variables to move, specified by name or index.

     RELLOCATION is ‘'Before'’ or ‘'After'’.

     LOCATION indicates a single variable to use as the target location,
     specified by name or index.  If it is specified by index, it is the
     index into the list of *unmoved* variables from OBJ, not the
     original full list of variables in OBJ.

     Returns a table with the same variables as OBJ, but in a different
     order.


File: tablicious.info,  Node: table.setvar,  Next: table.addvars,  Prev: table.movevars,  Up: table

9.2.55.37 table.setvar
......................

 -- Method: OUT = setvar (OBJ, VARREF, VALUE)

     Set value for a variable in table.

     This sets (adds or replaces) the value for a variable in OBJ.  It
     may be used to change the value of an existing variable, or add a
     new variable.

     VARREF is a variable reference, either the index or name of a
     variable.  If you are adding a new variable, it must be a name, and
     not an index.

     VALUE is the value to set the variable to.  If it is scalar or a
     single string as charvec, it is scalar-expanded to match the number
     of rows in OBJ.


File: tablicious.info,  Node: table.addvars,  Next: table.convertvars,  Prev: table.setvar,  Up: table

9.2.55.38 table.addvars
.......................

 -- Method: OUT = addvars (OBJ, VAR1, ..., VARN)
 -- Method: OUT = addvars (..., ‘'Before'’, BEFORE)
 -- Method: OUT = addvars (..., ‘'After'’, AFTER)
 -- Method: OUT = addvars (..., ‘'NewVariableNames'’, NEWVARIABLENAMES)

     Add variables to table

     Adds the specified variables to a table.


File: tablicious.info,  Node: table.convertvars,  Next: table.mergevars,  Prev: table.addvars,  Up: table

9.2.55.39 table.convertvars
...........................

 -- Method: OUT = convertvars (OBJ, VARS, DATATYPE)

     Convert variables to specified data type.

     Converts the variables in OBJ specified by VARS to the specified
     data type.

     VARS is a cellstr or numeric vector specifying which variables to
     convert.

     DATATYPE specifies the data type to convert those variables to.  It
     is either a char holding the name of the data type, or a function
     handle which will perform the conversion.  If it is the name of the
     data type, there must either be a one-arg constructor of that type
     which accepts the specified variables’ current types as input, or a
     conversion method of that name defined on the specified variables’
     current type.

     Returns a table with the same variable names as OBJ, but with
     converted types.


File: tablicious.info,  Node: table.mergevars,  Next: table.splitvars,  Prev: table.convertvars,  Up: table

9.2.55.40 table.mergevars
.........................

 -- Method: OUT = mergevars (OBJ, VARS)
 -- Method: OUT = mergevars (..., ‘'NewVariableName'’, NEWVARIABLENAME)
 -- Method: OUT = mergevars (..., ‘'MergeAsTable'’, MERGEASTABLE)

     Merge table variables into a single variable.


File: tablicious.info,  Node: table.splitvars,  Next: table.stack,  Prev: table.mergevars,  Up: table

9.2.55.41 table.splitvars
.........................

 -- Method: OUT = splitvars (OBJ)
 -- Method: OUT = splitvars (OBJ, VARS)
 -- Method: OUT = splitvars (..., ‘'NewVariableNames'’,
          NEWVARIABLENAMES)

     Split multicolumn table variables.

     Splits multicolumn table variables into new single-column
     variables.  If VARS is supplied, splits only those variables.  If
     VARS is not supplied, splits all multicolumn variables.


File: tablicious.info,  Node: table.stack,  Next: table.head,  Prev: table.splitvars,  Up: table

9.2.55.42 table.stack
.....................

 -- Method: OUT = stack (OBJ, VARS)
 -- Method: OUT = stack (..., ‘'NewDataVariableName'’,
          NEWDATAVARIABLENAME)
 -- Method: OUT = stack (..., ‘'IndexVariableName'’, INDEXVARIABLENAME)

     Stack multiple table variables into a single variable.


File: tablicious.info,  Node: table.head,  Next: table.tail,  Prev: table.stack,  Up: table

9.2.55.43 table.head
....................

 -- Method: OUT = head (OBJ)
 -- Method: OUT = head (OBJ, K)

     Get first K rows of table.

     Returns the first K rows of OBJ, as a table.

     K defaults to 8.

     If there are less than K rows in OBJ, returns all rows.


File: tablicious.info,  Node: table.tail,  Next: table.join,  Prev: table.head,  Up: table

9.2.55.44 table.tail
....................

 -- Method: OUT = tail (OBJ)
 -- Method: OUT = tail (OBJ, K)

     Get last K rows of table.

     Returns the last K rows of OBJ, as a table.

     K defaults to 8.

     If there are less than K rows in OBJ, returns all rows.


File: tablicious.info,  Node: table.join,  Next: table.innerjoin,  Prev: table.tail,  Up: table

9.2.55.45 table.join
....................

 -- Method: [C, IB] = join (A, B)
 -- Method: [C, IB] = join (A, B, ...)

     Combine two tables by rows using key variables, in a restricted
     form.

     This is not a "real" relational join operation.  It has the
     restrictions that: 1) The key values in B must be unique.  2) Every
     key value in A must map to a key value in B. These are restrictions
     inherited from the Matlab definition of table.join.

     You probably don’t want to use this method.  You probably want to
     use innerjoin or outerjoin instead.

     See also: *note table.innerjoin::, *note table.outerjoin::


File: tablicious.info,  Node: table.innerjoin,  Next: table.outerjoin,  Prev: table.join,  Up: table

9.2.55.46 table.innerjoin
.........................

 -- Method: [OUT, IXA, IXB] = innerjoin (A, B)
 -- Method: [...] = innerjoin (A, B, ...)

     Combine two tables by rows using key variables.

     Computes the relational inner join between two tables.  “Inner”
     means that only rows which had matching rows in the other input are
     kept in the output.

     TODO: Document options.

     Returns: OUT - A table that is the result of joining A and B IX -
     Indexes into A for each row in out IXB - Indexes into B for each
     row in out


File: tablicious.info,  Node: table.outerjoin,  Next: table.outerfillvals,  Prev: table.innerjoin,  Up: table

9.2.55.47 table.outerjoin
.........................

 -- Method: [OUT, IXA, IXB] = outerjoin (A, B)
 -- Method: [...] = outerjoin (A, B, ...)

     Combine two tables by rows using key variables, retaining unmatched
     rows.

     Computes the relational outer join of tables A and B. This is like
     a regular join, but also includes rows in each input which did not
     have matching rows in the other input; the columns from the missing
     side are filled in with placeholder values.

     TODO: Document options.

     Returns: OUT - A table that is the result of the outer join of A
     and B IXA - indexes into A for each row in out IXB - indexes into B
     for each row in out


File: tablicious.info,  Node: table.outerfillvals,  Next: table.semijoin,  Prev: table.outerjoin,  Up: table

9.2.55.48 table.outerfillvals
.............................

 -- Method: OUT = outerfillvals (OBJ)

     Get fill values for outer join.

     Returns a table with the same variables as this, but containing
     only a single row whose variable values are the values to use as
     fill values when doing an outer join.


File: tablicious.info,  Node: table.semijoin,  Next: table.antijoin,  Prev: table.outerfillvals,  Up: table

9.2.55.49 table.semijoin
........................

 -- Method: [OUTA, IXA, OUTB, IXB] = semijoin (A, B)

     Natural semijoin.

     Computes the natural semijoin of tables A and B. The semi-join of
     tables A and B is the set of all rows in A which have matching rows
     in B, based on comparing the values of variables with the same
     names.

     This method also computes the semijoin of B and A, for convenience.

     Returns: OUTA - all the rows in A with matching row(s) in B IXA -
     the row indexes into A which produced OUTA OUTB - all the rows in B
     with matching row(s) in A IXB - the row indexes into B which
     produced OUTB


File: tablicious.info,  Node: table.antijoin,  Next: table.cartesian,  Prev: table.semijoin,  Up: table

9.2.55.50 table.antijoin
........................

 -- Method: [OUTA, IXA, OUTB, IXB] = antijoin (A, B)

     Natural antijoin (AKA “semidifference”).

     Computes the anti-join of A and B. The anti-join is defined as all
     the rows from one input which do not have matching rows in the
     other input.

     Returns: OUTA - all the rows in A with no matching row in B IXA -
     the row indexes into A which produced OUTA OUTB - all the rows in B
     with no matching row in A IXB - the row indexes into B which
     produced OUTB


File: tablicious.info,  Node: table.cartesian,  Next: table.groupby,  Prev: table.antijoin,  Up: table

9.2.55.51 table.cartesian
.........................

 -- Method: [OUT, IXS] = cartesian (A, B)

     Cartesian product of two tables.

     Computes the Cartesian product of two tables.  The Cartesian
     product is each row in A combined with each row in B.

     Due to the definition and structural constraints of table, the two
     inputs must have no variable names in common.  It is an error if
     they do.

     The Cartesian product is seldom used in practice.  If you find
     yourself calling this method, you should step back and re-evaluate
     what you are doing, asking yourself if that is really what you want
     to happen.  If nothing else, writing a function that calls
     cartesian() is usually much less efficient than alternate ways of
     arriving at the same result.

     This implementation does not remove duplicate values.  TODO:
     Determine whether this duplicate-removing behavior is correct.

     The ordering of the rows in the output is not specified, and may be
     implementation- dependent.  TODO: Determine if we can lock this
     behavior down to a fixed, defined ordering, without killing
     performance.


File: tablicious.info,  Node: table.groupby,  Next: table.grpstats,  Prev: table.cartesian,  Up: table

9.2.55.52 table.groupby
.......................

 -- Method: [OUT] = groupby (OBJ, GROUPVARS, AGGCALCS)

     Find groups in table data and apply functions to variables within
     groups.

     This works like an SQL ‘"SELECT ... GROUP BY ..."’ statement.

     GROUPVARS (cellstr, numeric) is a list of the grouping variables,
     identified by name or index.

     AGGCALCS is a specification of the aggregate calculations to
     perform on them, in the form ‘{’OUT_VAR‘,’ FCN‘,’ IN_VARS‘; ...}’,
     where: OUT_VAR (char) is the name of the output variable FCN
     (function handle) is the function to apply to produce it IN_VARS
     (cellstr) is a list of the input variables to pass to fcn

     Returns a table.


File: tablicious.info,  Node: table.grpstats,  Next: table.rows2vars,  Prev: table.groupby,  Up: table

9.2.55.53 table.grpstats
........................

 -- Method: [OUT] = grpstats (OBJ, GROUPVAR)
 -- Method: [OUT] = grpstats (..., ‘'DataVars'’, DATAVARS)

     Statistics by group.

     See also: *note table.groupby::.


File: tablicious.info,  Node: table.rows2vars,  Next: table.congruentize,  Prev: table.grpstats,  Up: table

9.2.55.54 table.rows2vars
.........................

 -- Method: OUT = rows2vars (OBJ)
 -- Method: OUT = rows2vars (OBJ, ‘'VariableNamesSource'’,
          VARIABLENAMESSOURCE)
 -- Method: OUT = rows2vars (..., ‘'DataVariables'’, DATAVARIABLES)

     Reorient table, swapping rows and variables dimensions.

     This flips the dimensions of the given table OBJ, swapping the
     orientation of the contained data, and swapping the row
     names/labels and variable names.

     The variable names become a new variable named
     “OriginalVariableNames”.

     The row names are drawn from the column VARIABLENAMESSOURCE if it
     is specified.  Otherwise, if OBJ has row names, they are used.
     Otherwise, new variable names in the form “VarN” are generated.

     If all the variables in OBJ are of the same type, they are
     concatenated and then sliced to create the new variable values.
     Otherwise, they are converted to cells, and the new table has cell
     variable values.


File: tablicious.info,  Node: table.congruentize,  Next: table.union,  Prev: table.rows2vars,  Up: table

9.2.55.55 table.congruentize
............................

 -- Method: [OUTA, OUTB] = congruentize (A, B)

     Make tables congruent.

     Makes tables congruent by ensuring they have the same variables of
     the same types in the same order.  Congruent tables may be safely
     unioned, intersected, vertcatted, or have other set operations done
     to them.

     Variable names present in one input but not in the other produces
     an error.  Variables with the same name but different types in the
     inputs produces an error.  Inputs must either both have row names
     or both not have row names; it is an error if one has row names and
     the other doesn’t.  Variables in different orders are reordered to
     be in the same order as A.


File: tablicious.info,  Node: table.union,  Next: table.intersect,  Prev: table.congruentize,  Up: table

9.2.55.56 table.union
.....................

 -- Method: [C, IA, IB] = union (A, B)

     Set union.

     Computes the union of two tables.  The union is defined to be the
     unique row values which are present in either of the two input
     tables.

     Returns: C - A table containing all the unique row values present
     in A or B. IA - Row indexes into A of the rows from A included in
     C. IB - Row indexes into B of the rows from B included in C.


File: tablicious.info,  Node: table.intersect,  Next: table.setxor,  Prev: table.union,  Up: table

9.2.55.57 table.intersect
.........................

 -- Method: [C, IA, IB] = intersect (A, B)

     Set intersection.

     Computes the intersection of two tables.  The intersection is
     defined to be the unique row values which are present in both of
     the two input tables.

     Returns: C - A table containing all the unique row values present
     in both A and B. IA - Row indexes into A of the rows from A
     included in C. IB - Row indexes into B of the rows from B included
     in C.


File: tablicious.info,  Node: table.setxor,  Next: table.setdiff,  Prev: table.intersect,  Up: table

9.2.55.58 table.setxor
......................

 -- Method: [C, IA, IB] = setxor (A, B)

     Set exclusive OR.

     Computes the setwise exclusive OR of two tables.  The set XOR is
     defined to be the unique row values which are present in one or the
     other of the two input tables, but not in both.

     Returns: C - A table containing all the unique row values in the
     set XOR of A and B. IA - Row indexes into A of the rows from A
     included in C. IB - Row indexes into B of the rows from B included
     in C.


File: tablicious.info,  Node: table.setdiff,  Next: table.ismember,  Prev: table.setxor,  Up: table

9.2.55.59 table.setdiff
.......................

 -- Method: [C, IA] = setdiff (A, B)

     Set difference.

     Computes the set difference of two tables.  The set difference is
     defined to be the unique row values which are present in table A
     that are not in table B.

     Returns: C - A table containing the unique row values in A that
     were not in B. IA - Row indexes into A of the rows from A included
     in C.


File: tablicious.info,  Node: table.ismember,  Next: table.ismissing,  Prev: table.setdiff,  Up: table

9.2.55.60 table.ismember
........................

 -- Method: [TF, LOC] = ismember (A, B)

     Set membership.

     Finds rows in A that are members of B.

     Returns: TF - A logical vector indicating whether each A(i,:) was
     present in B. LOC - Indexes into B of rows that were found.


File: tablicious.info,  Node: table.ismissing,  Next: table.rmmissing,  Prev: table.ismember,  Up: table

9.2.55.61 table.ismissing
.........................

 -- Method: OUT = ismissing (OBJ)
 -- Method: OUT = ismissing (OBJ, INDICATOR)

     Find missing values.

     Finds missing values in OBJ’s variables.

     If indicator is not supplied, uses the standard missing values for
     each variable’s data type.  If indicator is supplied, the same
     indicator list is applied across all variables.

     All variables in this must be vectors.  (This is due to the
     requirement that ‘size(out) == size(obj)’.)

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: table.rmmissing,  Next: table.standardizeMissing,  Prev: table.ismissing,  Up: table

9.2.55.62 table.rmmissing
.........................

 -- Method: [OUT, TF] = rmmissing (OBJ)
 -- Method: [OUT, TF] = rmmissing (OBJ, INDICATOR)
 -- Method: [OUT, TF] = rmmissing (..., ‘'DataVariables'’, VARS)
 -- Method: [OUT, TF] = rmmissing (..., ‘'MinNumMissing'’,
          MINNUMMISSING)

     Remove rows with missing values.

     Removes the rows from OBJ that have missing values.

     If the ’DataVariables’ option is given, only the data in the
     specified variables is considered.

     Returns: OUT - A table the same as OBJ, but with rows with missing
     values removed.  TF - A logical index vector indicating which rows
     were removed.


File: tablicious.info,  Node: table.standardizeMissing,  Next: table.varfun,  Prev: table.rmmissing,  Up: table

9.2.55.63 table.standardizeMissing
..................................

 -- Method: OUT = standardizeMissing (OBJ, INDICATOR)
 -- Method: OUT = standardizeMissing (..., ‘'DataVariables'’, VARS)

     Insert standard missing values.

     Standardizes missing values in variable data.

     If the DATAVARIABLES option is supplied, only the indicated
     variables are standardized.

     INDICATOR is passed along to ‘standardizeMissing’ when it is called
     on each of the data variables in turn.  The same indicator is used
     for all variables.  You can mix and match indicator types by just
     passing in mixed indicator types in a cell array; indicators that
     don’t match the type of the column they are operating on are just
     ignored.

     Returns a table with same variable names and types as OBJ, but with
     variable values standardized.


File: tablicious.info,  Node: table.varfun,  Next: table.rowfun,  Prev: table.standardizeMissing,  Up: table

9.2.55.64 table.varfun
......................

 -- Method: OUT = varfun (FCN, OBJ)
 -- Method: OUT = varfun (..., ‘'OutputFormat'’, OUTPUTFORMAT)
 -- Method: OUT = varfun (..., ‘'InputVariables'’, VARS)
 -- Method: OUT = varfun (..., ‘'ErrorHandler'’, ERRORFCN)

     Apply function to table variables.

     Applies the given function FCN to each variable in OBJ, collecting
     the output in a table, cell array, or array of another type.


File: tablicious.info,  Node: table.rowfun,  Next: table.findgroups,  Prev: table.varfun,  Up: table

9.2.55.65 table.rowfun
......................

 -- Method: OUT = varfun (FCN, OBJ)
 -- Method: OUT = varfun (..., ‘'OptionName'’, OPTIONVALUE, ...)

     This method is currently unimplemented.  Sorry.


File: tablicious.info,  Node: table.findgroups,  Next: table.evalWithVars,  Prev: table.rowfun,  Up: table

9.2.55.66 table.findgroups
..........................

 -- Method: [G, TID] = findgroups (OBJ)

     Find groups within a table’s row values.

     Finds groups within a table’s row values and get group numbers.  A
     group is a set of rows that have the same values in all their
     variable elements.

     Returns: G - A double column vector of group numbers created from
     OBJ.  TID - A table containing the row values corresponding to the
     group numbers.


File: tablicious.info,  Node: table.evalWithVars,  Next: table.restrict,  Prev: table.findgroups,  Up: table

9.2.55.67 table.evalWithVars
............................

 -- Method: OUT = evalWithVars (OBJ, EXPR)

     Evaluate an expression against table’s variables.

     Evaluates the M-code expression EXPR in a workspace where all of
     OBJ’s variables have been assigned to workspace variables.

     EXPR is a charvec containing an Octave expression.

     As an implementation detail, the workspace will also contain some
     variables that are prefixed and suffixed with "__".  So try to
     avoid those in your table variable names.

     Returns the result of the evaluation.

     Examples:

          [s,p,sp] = table_examples.SpDb
          tmp = join (sp, p);
          shipment_weight = evalWithVars (tmp, "Qty .* Weight")


File: tablicious.info,  Node: table.restrict,  Prev: table.evalWithVars,  Up: table

9.2.55.68 table.restrict
........................

 -- Method: OUT = restrict (OBJ, EXPR)
 -- Method: OUT = restrict (OBJ, IX)

     Subset rows using variable expression or index.

     Subsets a table row-wise, using either an index vector or an
     expression involving OBJ’s variables.

     If the argument is a numeric or logical vector, it is interpreted
     as an index into the rows of this.  (Just as with ‘subsetrows
     (this, index)‘.)

     If the argument is a char, then it is evaulated as an M-code
     expression, with all of this’ variables available as workspace
     variables, as with ‘evalWithVars’.  The output of expr must be a
     numeric or logical index vector (This form is a shorthand for ‘out
     = subsetrows (this, evalWithVars (this, expr))’.)

     TODO: Decide whether to name this to "where" to be more like SQL
     instead of relational algebra.

     Examples:
          [s,p,sp] = table_examples.SpDb;
          prettyprint (restrict (p, 'Weight >= 14 & strcmp(Color, "Red")'))


File: tablicious.info,  Node: tableOuterFillValue,  Next: timezones,  Prev: table,  Up: API Alphabetically

9.2.56 tableOuterFillValue
--------------------------

 -- Function: OUT = tableOuterFillValue (X)

     Outer fill value for variable within a table.

     Determines the fill value to usse for a given variable value X when
     that value is used as a variable in a table that is involved in an
     outer join.

     The default implementation for ‘tableOuterFillValue’ has support
     for all Octave primitive types, plus cellstrs, datetime & friends,
     strings, and ‘table’-valued variables.

     This function may become private to table before version 1.0.  It
     is currently global to make debugging more convenient.  It (or an
     equivalent) will remain global if we want to allow user-defined
     classes to customize their fill value.  It also has default logic
     that will determine the fill value for an arbitrary type by
     detecting the value used to fill elements during array expansion
     operations.  This will be appropriate for most data types.

     Returns a 1-by-ncols value of the same type as x, which may be any
     type, where ncols is the number of columns in the input.


File: tablicious.info,  Node: timezones,  Next: vartype,  Prev: tableOuterFillValue,  Up: API Alphabetically

9.2.57 timezones
----------------

 -- Function: OUT = timezones ()
 -- Function: OUT = timezones (AREA)

     List all the time zones defined on this system.

     This lists all the time zones that are defined in the IANA time
     zone database used by this Octave.  (On Linux and macOS, that will
     generally be the system time zone database from
     ‘/usr/share/zoneinfo’.  On Windows, it will be the database
     redistributed with the Chrono package.

     If the return is captured, the output is returned as a table if
     your Octave has table support, or a struct if it does not.  It will
     have fields/variables containing column vectors:

     ‘Name’
          The IANA zone name, as cellstr.
     ‘Area’
          The geographical area the zone is in, as cellstr.

     Compatibility note: Matlab also includes UTCOffset and DSTOffset
     fields in the output; these are currently unimplemented.


File: tablicious.info,  Node: vartype,  Next: vecfun,  Prev: timezones,  Up: API Alphabetically

9.2.58 vartype
--------------

 -- Function: OUT = vartype (TYPE)

     Filter by variable type for use in suscripting.

     Creates an object that can be used for subscripting into the
     variables dimension of a table and filtering on variable type.

     TYPE is the name of a type as charvec.  This may be anything that
     the ‘isa’ function accepts, or ‘'cellstr'’ to select cellstrs, as
     determined by ‘iscellstr’.

     Returns an object of an opaque type.  Don’t worry about what type
     it is; just pass it into the second argument of a subscript into a
     ‘table’ object.


File: tablicious.info,  Node: vecfun,  Next: years,  Prev: vartype,  Up: API Alphabetically

9.2.59 vecfun
-------------

 -- Function: OUT = vecfun (FCN, X, DIM)

     Apply function to vectors in array along arbitrary dimension.

     This function is not implemented yet.

     Applies a given function to the vector slices of an N-dimensional
     array, where those slices are along a given dimension.

     FCN is a function handle to apply.

     X is an array of arbitrary type which is to be sliced and passed in
     to FCN.

     DIM is the dimension along which the vector slices lay.

     Returns the collected output of the FCN calls, which will be the
     same size as X, but not necessarily the same type.


File: tablicious.info,  Node: years,  Prev: vecfun,  Up: API Alphabetically

9.2.60 years
------------

 -- Function File: OUT = years (X)
     Create a ‘duration’ X years long, or get the years in a ‘duration’
     X.

     If input is numeric, returns a ‘duration’ array in units of
     fixed-length years of 365.2425 days each.

     If input is a ‘duration’, converts the ‘duration’ to a number of
     fixed-length years as double.

     Note: ‘years’ creates fixed-length years, which may not be what you
     want.  To create a duration of calendar years (which account for
     actual leap days), use ‘calyears’.

     *Note calyears::.


File: tablicious.info,  Node: Copying,  Prev: API Reference,  Up: Top

10 Copying
**********

10.1 Package Copyright
======================

Tablicious for Octave is covered by the GNU GPLv3.

   All the code in the package is GNU GPLv3.

   The Fisher Iris dataset is Public Domain.

10.2 Manual Copyright
=====================

This manual is for Tablicious, version 0.1.0.

   Copyright © 2019 Andrew Janke

     Permission is granted to make and distribute verbatim copies of
     this manual provided the copyright notice and this permission
     notice are preserved on all copies.

     Permission is granted to copy and distribute modified versions of
     this manual under the conditions for verbatim copying, provided
     that the entire resulting derived work is distributed under the
     terms of a permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
     manual into another language, under the same conditions as for
     modified versions.



Tag Table:
Node: Top772
Node: Introduction1136
Node: Getting Started2499
Node: Table Representation3313
Node: table Class3576
Node: Date Representation3888
Node: datetime Class4148
Node: datenum Compatibility4981
Node: Time Zones6525
Node: Defined Time Zones9362
Node: Durations10337
Node: duration Class10519
Node: calendarDuration Class11274
Node: Validation Functions12179
Node: Missing Functionality14475
Node: API Reference15727
Node: API by Category15916
Node: API Alphabetically20703
Node: array2table24602
Node: calendarDuration25538
Node: calendarDuration.calendarDuration27470
Node: calendarDuration.sizeof27981
Node: calendarDuration.isnat28261
Node: calendarDuration.uminus28586
Node: calendarDuration.plus28869
Node: calendarDuration.times29478
Node: calendarDuration.minus29839
Node: calendarDuration.dispstrs30188
Node: calendarDuration.isnan30532
Node: calmonths30936
Node: calyears31525
Node: categorical31869
Node: categorical.categorical34143
Node: categorical.sizeof35396
Node: categorical.categories35646
Node: categorical.iscategory36044
Node: categorical.isordinal36490
Node: categorical.string36859
Node: categorical.cellstr37306
Node: categorical.dispstrs37745
Node: categorical.summary38201
Node: categorical.addcats38652
Node: categorical.removecats39080
Node: categorical.mergecats39722
Node: categorical.renamecats40377
Node: categorical.reordercats40794
Node: categorical.setcats41329
Node: categorical.isundefined41775
Node: categorical.ismissing42293
Node: categorical.isnannish42703
Node: categorical.squeezecats43181
Node: cell2table43551
Node: colvecfun44291
Node: contains45015
Node: datetime45802
Node: datetime.datetime48194
Node: datetime.ofDatenum49016
Node: datetime.ofDatestruct49376
Node: datetime.NaT49879
Node: datetime.posix2datenum50644
Node: datetime.datenum2posix51121
Node: datetime.sizeof51523
Node: datetime.proxyKeys51756
Node: datetime.ymd52393
Node: datetime.hms52783
Node: datetime.ymdhms53178
Node: datetime.timeofday53621
Node: datetime.week54041
Node: datetime.dispstrs54301
Node: datetime.datestr54600
Node: datetime.datestrs54992
Node: datetime.datestruct55413
Node: datetime.posixtime56215
Node: datetime.datenum56749
Node: datetime.gmtime57066
Node: datetime.localtime57507
Node: datetime.isnat58229
Node: datetime.isnan58510
Node: datetime.lt58881
Node: datetime.le59312
Node: datetime.ne59752
Node: datetime.eq60184
Node: datetime.ge60612
Node: datetime.gt61056
Node: datetime.plus61489
Node: datetime.minus61985
Node: datetime.diff62630
Node: datetime.isbetween63010
Node: datetime.linspace63498
Node: datetime.convertDatenumTimeZone64111
Node: days64765
Node: discretize65231
Node: dispstrs66128
Node: duration66912
Node: duration.ofDays68117
Node: duration.sizeof68604
Node: duration.years68804
Node: duration.hours69202
Node: duration.minutes69573
Node: duration.seconds69960
Node: duration.milliseconds70323
Node: duration.dispstrs70731
Node: duration.char71042
Node: duration.linspace71470
Node: endsWith72079
Node: eqn72862
Node: fillmissing73950
Node: hours74801
Node: isdatetime75285
Node: isduration75573
Node: isfile75862
Node: isfolder76972
Node: ismissing77939
Node: isnannish80049
Node: localdate81033
Node: localdate.localdate82356
Node: localdate.NaT82892
Node: localdate.ymd83780
Node: localdate.dispstrs84084
Node: localdate.datestr84388
Node: localdate.datestrs84786
Node: localdate.datestruct85213
Node: localdate.posixtime86131
Node: localdate.datenum86702
Node: localdate.isnat87030
Node: localdate.isnan87317
Node: milliseconds87675
Node: minutes88210
Node: missing88468
Node: missing.missing89508
Node: missing.dispstrs89822
Node: missing.ismissing90219
Node: missing.isnan90584
Node: missing.isnannish90923
Node: mustBeA91257
Node: mustBeCellstr91834
Node: mustBeCharvec92469
Node: mustBeFinite93369
Node: mustBeInteger93909
Node: mustBeMember94554
Node: mustBeNonempty95382
Node: mustBeNumeric95931
Node: mustBeReal96476
Node: mustBeSameSize97005
Node: mustBeScalar97643
Node: mustBeScalarLogical98190
Node: mustBeVector98783
Node: NaT99323
Node: octave.chrono.dummy_function100039
Node: octave.chrono.DummyClass100571
Node: octave.chrono.DummyClass.DummyClass101373
Node: octave.chrono.DummyClass.foo101844
Node: octave.chrono.DummyClass.bar102383
Node: octave.dataset102878
Node: octave.dataset.AirPassengers103489
Node: octave.dataset.airmiles103774
Node: octave.dataset.beavers104084
Node: octave.dataset.iris104368
Node: octave.datasets104626
Node: octave.datasets.list105092
Node: octave.datasets.load105600
Node: pp105995
Node: rmmissing106646
Node: scalarexpand107683
Node: seconds107847
Node: size2str108346
Node: standardizeMissing108507
Node: startsWith109332
Node: string110142
Node: string.string113454
Node: string.isstring114124
Node: string.dispstrs114449
Node: string.sizeof115028
Node: string.ismissing115246
Node: string.isnannish115725
Node: string.cellstr116108
Node: string.cell116453
Node: string.char116940
Node: string.encode117465
Node: string.strlength_bytes117981
Node: string.strlength118654
Node: string.reverse_bytes119221
Node: string.reverse119959
Node: string.strcat120431
Node: string.lower121009
Node: string.upper121511
Node: string.erase122012
Node: string.strrep122349
Node: string.strfind122954
Node: string.regexprep123477
Node: string.strcmp123953
Node: string.cmp124646
Node: string.missing125625
Node: string.decode126027
Node: struct2table126437
Node: table126904
Node: table.table129483
Node: table.summary130535
Node: table.prettyprint130962
Node: table.table2cell131421
Node: table.table2struct131909
Node: table.table2array132544
Node: table.varnames132791
Node: table.istable133043
Node: table.size133255
Node: table.length133584
Node: table.ndims133883
Node: table.squeeze134134
Node: table.sizeof134481
Node: table.height134912
Node: table.rows135120
Node: table.width135321
Node: table.columns135652
Node: table.numel135990
Node: table.isempty136510
Node: table.ismatrix136834
Node: table.isrow137123
Node: table.iscol137341
Node: table.isvector137701
Node: table.isscalar137927
Node: table.hasrownames138157
Node: table.vertcat138407
Node: table.horzcat138928
Node: table.repmat139548
Node: table.repelem140074
Node: table.setVariableNames140515
Node: table.setRowNames140962
Node: table.resolveVarRef141334
Node: table.subsetrows142336
Node: table.subsetvars142681
Node: table.removevars143188
Node: table.movevars143573
Node: table.setvar144301
Node: table.addvars145026
Node: table.convertvars145493
Node: table.mergevars146481
Node: table.splitvars146884
Node: table.stack147442
Node: table.head147851
Node: table.tail148220
Node: table.join148586
Node: table.innerjoin149332
Node: table.outerjoin149993
Node: table.outerfillvals150800
Node: table.semijoin151233
Node: table.antijoin152002
Node: table.cartesian152654
Node: table.groupby153922
Node: table.grpstats154773
Node: table.rows2vars155105
Node: table.congruentize156228
Node: table.union157097
Node: table.intersect157669
Node: table.setxor158277
Node: table.setdiff158912
Node: table.ismember159449
Node: table.ismissing159851
Node: table.rmmissing160535
Node: table.standardizeMissing161327
Node: table.varfun162317
Node: table.rowfun162884
Node: table.findgroups163195
Node: table.evalWithVars163780
Node: table.restrict164630
Node: tableOuterFillValue165759
Node: timezones166996
Node: vartype168041
Node: vecfun168754
Node: years169481
Node: Copying170158

End Tag Table


Local Variables:
coding: utf-8
End:
