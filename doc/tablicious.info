This is tablicious.info, produced by makeinfo version 6.6 from
tablicious.texi.

This manual is for Tablicious, version 0.1.0+.

   Copyright © 2019 Andrew Janke

     Permission is granted to make and distribute verbatim copies of
     this manual provided the copyright notice and this permission
     notice are preserved on all copies.

     Permission is granted to copy and distribute modified versions of
     this manual under the conditions for verbatim copying, provided
     that the entire resulting derived work is distributed under the
     terms of a permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
     manual into another language, under the same conditions as for
     modified versions.


File: tablicious.info,  Node: Top,  Next: Introduction

Tablicious for GNU Octave
*************************

This manual is for Tablicious, version 0.1.0+.

* Menu:

* Introduction::
* Getting Started::
* Table Representation::
* Date Representation::
* Time Zones::
* Durations::
* Validation Functions::
* Example Data Sets::
* Missing Functionality::
* API Reference::
* Copying::


File: tablicious.info,  Node: Introduction,  Next: Getting Started,  Up: Top

1 Introduction
**************

     Time is an illusion.  Lunchtime doubly so.

                           — _Douglas Adams_

   This is the manual for the Tablicious package version 0.1.0+ for GNU
Octave.

   Tablicious provides Matlab-compatible tabular data and date/time
support for GNU Octave.  This includes a ‘table’ class with support for
filtering and join operations; ‘datetime’, ‘duration’, and related
classes; Missing Data support; ‘string’ and ‘categorical’ data types;
and other miscellaneous things.

   This document is a work in progress.  You are invited to help improve
it and submit patches.

   Tablicious’s classes are designed to be convenient to use while still
being efficient.  The data representations used by Tablicious are
designed to be efficient and suitable for working with large-ish data
sets.  A “large-ish” data set is one that can have millions of elements
or rows, but still fits in main computer memory.  Tablicious’s main
relational and arithmetic operations are all implemented using
vectorized operations on primitive Octave data types.

   Tablicious was written by Andrew Janke <<floss@apjanke.net>>.
Support can be found on the Tablicious project GitHub page
(https://github.com/apjanke/octave-tablicious).


File: tablicious.info,  Node: Getting Started,  Next: Table Representation,  Prev: Introduction,  Up: Top

2 Getting Started
*****************

The easiest way to obtain Tablicious is by using Octave’s ‘pkg’ package
manager.  To install the development prerelease of Tablicious, run this
in Octave:

     pkg install https://github.com/apjanke/octave-tablicious/releases/download/v0.1.0+/tablicious-0.1.0+.tar.gz

   (Check the releases page at
<https://github.com/apjanke/octave-tablicious/releases> to find out what
the actual latest release number is.)

   For development, you can obtain the source code for Tablicious from
the project repo on GitHub at
<https://github.com/apjanke/octave-tablicious>.  Make a local clone of
the repo.  Then add the ‘inst’ directory in the repo to your Octave
path.


File: tablicious.info,  Node: Table Representation,  Next: Date Representation,  Prev: Getting Started,  Up: Top

3 Table Representation
**********************

Tablicious provides the ‘table’ class for representing tabular data.

* Menu:

* table Class::


File: tablicious.info,  Node: table Class,  Up: Table Representation

3.1 ‘table’ Class
=================

A ‘table’ is an array object that represents a tabular data structure.
It holds multiple named “variables”, each of which is a column vector,
or a 2-D matrix whose rows are read as records.


File: tablicious.info,  Node: Date Representation,  Next: Time Zones,  Prev: Table Representation,  Up: Top

4 Date Representation
*********************

Chrono provides the ‘datetime’ class for representing points in time.

* Menu:

* datetime Class::


File: tablicious.info,  Node: datetime Class,  Up: Date Representation

4.1 ‘datetime’ Class
====================

A ‘datetime’ is an array object that represents points in time in the
familiar Gregorian calendar.

   This is an attempt to reproduce the functionality of Matlab’s
‘datetime’.  It also contains some Octave-specific extensions.

   The underlying representation is that of a datenum (a ‘double’
containing the number of days since the Matlab epoch), but encapsulating
it in an object provides several benefits: friendly human-readable
display, type safety, automatic type conversion, and time zone support.
In addition to the underlying datenum array, a ‘datetime’ inclues an
optional ‘TimeZone’ property indicating what time zone the datetimes are
in.

* Menu:

* datenum Compatibility::


File: tablicious.info,  Node: datenum Compatibility,  Up: datetime Class

4.1.1 ‘datenum’ Compatibility
-----------------------------

While the underlying data representation of ‘datetime’ is compatible
with (in fact, identical to) that of datenums, you cannot directly
combine them via assignment, concatenation, or most arithmetic
operations.

   This is because of the signature of the ‘datetime’ constructor.  When
combining objects and primitive types like ‘double’, the primitive type
is promoted to an object by calling the other object’s one-argument
constructor on it.  However, the one-argument numeric-input consstructor
for ‘datetime’ does not accept datenums: it interprets its input as
datevecs instead.  This is due to a design decision on Matlab’s part;
for compatibility, Octave does not alter that interface.

   To combine ‘datetime’s with datenums, you can convert the datenums to
‘datetime’s by calling ‘datetime.ofDatenum’ or ‘datetime(x,
'ConvertFrom', 'datenum')’, or you can convert the ‘datetime’s to
datenums by accessing its ‘dnums’ field with ‘x.dnums’.

   Examples:

     dt = datetime('2011-03-04')
     dn = datenum('2017-01-01')
     [dt dn]
         ⇒ error: datenum: expected date vector containing [YEAR, MONTH, DAY, HOUR, MINUTE, SECOND]
     [dt datetime.ofDatenum(dn)]
         ⇒ 04-Mar-2011   01-Jan-2017

   Also, if you have a zoned ‘datetime’, you can’t combine it with a
datenum, because datenums do not carry time zone information.


File: tablicious.info,  Node: Time Zones,  Next: Durations,  Prev: Date Representation,  Up: Top

5 Time Zones
************

Chrono has support for representing dates in time zones and for
converting between time zones.

   A ‘datetime’ may be "zoned" or "zoneless".  A zoneless ‘datetime’
does not have a time zone associated with it.  This is represented by an
empty ‘TimeZone’ property on the ‘datetime’ object.  A zoneless
‘datetime’ represents the local time in some unknown time zone, and
assumes a continuous time scale (no DST shifts).

   A zoned ‘datetime’ is associated with a time zone.  It is represented
by having the time zone’s IANA zone identifier (e.g.  ‘'UTC'’ or
‘'America/New_York'’) in its ‘TimeZone’ property.  A zoned ‘datetime’
represents the local time in that time zone.

   By default, the ‘datetime’ constructor creates unzoned ‘datetime’s.
To make a zoned ‘datetime’, either pass the ‘'TimeZone'’ option to the
constructor, or set the ‘TimeZone’ property after object creation.
Setting the ‘TimeZone’ property on a zoneless ‘datetime’ declares that
it’s a local time in that time zone.  Setting the ‘TimeZone’ property on
a zoned ‘datetime’ turns it back into a zoneless ‘datetime’ without
changing the local time it represents.

   You can tell a zoned from a zoneless time zone in the object display
because the time zone is included for zoned ‘datetime’s.

     % Create an unzoned datetime
     d = datetime('2011-03-04 06:00:00')
         ⇒  04-Mar-2011 06:00:00

     % Create a zoned datetime
     d_ny = datetime('2011-03-04 06:00:00', 'TimeZone', 'America/New_York')
         ⇒  04-Mar-2011 06:00:00 America/New_York
     % This is equivalent
     d_ny = datetime('2011-03-04 06:00:00');
     d_ny.TimeZone = 'America/New_York'
         ⇒  04-Mar-2011 06:00:00 America/New_York

     % Convert it to Chicago time
     d_chi.TimeZone = 'America/Chicago'
         ⇒  04-Mar-2011 05:00:00 America/Chicago

   When you combine two zoned ‘datetime’s via concatenation, assignment,
or arithmetic, if their time zones differ, they are converted to the
time zone of the left-hand input.

     d_ny = datetime('2011-03-04 06:00:00', 'TimeZone', 'America/New_York')
     d_la = datetime('2011-03-04 06:00:00', 'TimeZone', 'America/Los_Angeles')
     d_la - d_ny
         ⇒ 03:00:00

   You cannot combine a zoned and an unzoned ‘datetime’.  This results
in an error being raised.

     Warning: Normalization of "nonexistent" times (like between 02:00
     and 03:00 on a "spring forward" DST change day) is not implemented
     yet.  The results of converting a zoneless local time into a time
     zone where that local time did not exist are currently undefined.

* Menu:

* Defined Time Zones::


File: tablicious.info,  Node: Defined Time Zones,  Up: Time Zones

5.1 Defined Time Zones
======================

Chrono’s time zone data is drawn from the IANA Time Zone Database
(https://www.iana.org/time-zones), also known as the “Olson Database”.
Chrono includes a copy of this database in its distribution so it can
work on Windows, which does not supply it like Unix systems do.

   You can use the ‘timezones’ function to list the time zones known to
Chrono.  These will be all the time zones in the IANA database on your
system (for Linux and macOS) or in the IANA time zone database
redistributed with Chrono (for Windows).

     Note: The IANA Time Zone Database only covers dates from about the
     year 1880 to 2038.  Converting time zones for ‘datetime’s outside
     that range is currently unimplemented.  (Chrono needs to add
     support for proleptic POSIX time zone rules, which are used to
     govern behavior outside that date range.)


File: tablicious.info,  Node: Durations,  Next: Validation Functions,  Prev: Time Zones,  Up: Top

6 Durations
***********

* Menu:

* duration Class::
* calendarDuration Class::


File: tablicious.info,  Node: duration Class,  Next: calendarDuration Class,  Up: Durations

6.1 ‘duration’ Class
====================

A ‘duration’ represents a period of time in fixed-length seconds (or
minutes, hours, or whatever you want to measure it in.)

   A ‘duration’ has a resolution of about a nanosecond for typical
dates.  The underlying representation is a ‘double’ representing the
number of days elapsed, similar to a datenum, except it’s interpreted as
relative to some other reference point you provide, instead of being
relative to the Matlab/Octave epoch.

   You can add or subtract a ‘duration’ to a ‘datetime’ to get another
‘datetime’.  You can also add or subtract ‘durations’ to each other.


File: tablicious.info,  Node: calendarDuration Class,  Prev: duration Class,  Up: Durations

6.2 ‘calendarDuration’ Class
============================

A ‘calendarDuration’ represents a period of time in variable-length
calendar components.  For example, years and months can have varying
numbers of days, and days in time zones with Daylight Saving Time have
varying numbers of hours.  A ‘calendarDuration’ does arithmetic with
"whole" calendar periods.

   ‘calendarDuration’s and ‘duration’s cannot be directly combined,
because they are not semantically equivalent.  (This may be relaxed in
the future to allow ‘duration’s to be interpreted as numbers of days
when combined with ‘calendarDuration’s.)

     d = datetime('2011-03-04 00:00:00')
         ⇒ 04-Mar-2011
     cdur = calendarDuration(1, 3, 0)
         ⇒ 1y 3mo
     d2 = d + cdur
         ⇒ 04-Jun-2012


File: tablicious.info,  Node: Validation Functions,  Next: Example Data Sets,  Prev: Durations,  Up: Top

7 Validation Functions
**********************

Tablicious provides several validation functions which can be used to
check properties of function arguments, variables, object properties,
and other expressions.  These can be used to express invariants in your
program and catch problems due to input errors, incorrect function
usage, or other bugs.

   These validation functions are named following the pattern
‘mustBeXxx’, where ‘Xxx’ is some property of the input it is testing.
Validation functions may check the type, size, or other aspects of their
inputs.

   The most common place for validation functions to be used will
probably be at the beginning of functions, to check the input arguments
and ensure that the contract of the function is not being violated.  If
in the future Octave gains the ability to declaratively express object
property constraints, they will also be of use there.

   Be careful not to get too aggressive with the use of validation
functions: while using them can make sure invariants are followed and
your program is correct, they also reduce the code’s ability to make use
of duck typing, reducing its flexibility.  Whether you want to make this
trade-off is a design decision you will have to consider.

   When a validation function’s condition is violated, it raises an
error that includes a description of the violation in the error message.
This message will include a label for the input that describes what is
being tested.  By default, this label is initialized with ‘inputname()’,
so when you are calling a validator on a function argument or variable,
you will generally not need to supply a label.  But if you’re calling it
on an object property or an expression more complex than a simple
variable reference, the validator cannot automatically detect the input
name for use in the label.  In this case, make use of the optional
trailing argument(s) to the functions to manually supply a label for the
value being tested.

     % Validation of a simple variable does not need a label
     mustBeScalar (x);
     % Validation of a field or property reference does need a label
     mustBeScalar (this.foo, 'this.foo');


File: tablicious.info,  Node: Example Data Sets,  Next: Missing Functionality,  Prev: Validation Functions,  Up: Top

8 Example Data Sets
*******************

Tablicious comes with several example data sets that you can use to
explore how its functions and objects work.  These are accessed through
the ‘octave.datasets’ and ‘octave.dataset’ classes.

   To see a list of the available data sets, run
‘octave.datasets.list()’.  Then to load one of the example data sets,
run ‘octave.datasets.load('examplename')’.  For example:

     octave.datasets.list
     t = octave.datasets.load('cupcake')

   You can also load it by calling ‘octave.dataset.<name>’.  This does
the same thing.  For example:

     t = octave.dataset.cupcake

   When you load a data set, it either returns all its data in a single
variable (if you capture it), or loads its data into one or more
variables in your workspace (if you call it with no outputs).

   Each example data set comes with help text that describes the data
set and provides examples of how to work with it.  This help is found
using the ‘doc’ command on ‘octave.dataset.<name>’, where <NAME> is the
name of the data set.

   For example:

     doc octave.dataset.cupcake

   (The command ‘help octave.dataset.<name>’ ought to work too, but it
currently doesn’t.  This may be due to an issue with Octave’s ‘help’
command.)


File: tablicious.info,  Node: Missing Functionality,  Next: API Reference,  Prev: Example Data Sets,  Up: Top

9 Missing Functionality
***********************

Tablicious is based on Matlab’s table and date/time APIs and supports
most of their major functionality.  But not all of it is implemented
yet.  The missing parts are currently:

   • File I/O like ‘readtable()’ and ‘writetable()’
   • ‘summary()’ ‘categorical’
   • Assignment to table variables using ‘.’-indexing
   • ‘timetable’
   • POSIX time zone support for years outside the IANA time zone
     database coverage
   • Week-of-year (ISO calendar) calculations
   • Various ‘'ConvertFrom'’ forms for ‘datetime’ and ‘duration’
   • Support for LDML formatting for ‘datetime’
   • Various functions:
        • ‘between’
        • ‘caldiff’
        • ‘dateshift’
        • ‘week’
   • ‘isdst’, ‘isweekend’
   • ‘calendarDuration.split’
   • ‘duration.Format’ support
   • Moving window methods in ‘fillmissing’
   • ‘UTCOffset’ and ‘DSTOffset’ fields in the output of ‘timezones()’
   • Plotting support

   It is the author’s hope that all these will be implemented some day.

   These areas of missing functionality are all tracked on the
Tablicious issue tracker at
<https://github.com/apjanke/octave-tablicious/issues> and
<https://github.com/users/apjanke/projects/1>.


File: tablicious.info,  Node: API Reference,  Next: Copying,  Prev: Missing Functionality,  Up: Top

10 API Reference
****************

* Menu:

* API by Category::
* API Alphabetically::


File: tablicious.info,  Node: API by Category,  Next: API Alphabetically,  Up: API Reference

10.1 API by Category
====================

10.1.1 Tables
-------------

*note table::
     Tabular data array containing multiple columnar variables.

*note array2table::
     Convert an array to a table.

*note cell2table::
     Convert a cell array to a table.

*note struct2table::
     Convert struct to a table.

*note tableOuterFillValue::
     Outer fill value for variable within a table.

*note vartype::
     Filter by variable type for use in suscripting.

10.1.2 Strings and Categoricals
-------------------------------

*note string::
     A string array of Unicode strings.

*note startsWith::
     Test if strings start with a pattern.

*note endsWith::
     Test if strings end with a pattern.

*note contains::
     Test if strings contain a pattern.

*note categorical::
     Categorical variable array.

*note discretize::
     Group data into discrete bins or categories.

10.1.3 Dates and Times
----------------------

*note datetime::
     Represents points in time using the Gregorian calendar.

*note localdate::
     Represents a complete day using the Gregorian calendar.

*note isdatetime::
     True if input is a ’datetime’ array, false otherwise.

*note NaT::
     “Not-a-Time”.

*note calendarDuration::
     Durations of time using variable-length calendar periods, such as
     days, months, and years, which may vary in length over time.

*note calmonths::
     Create a ’calendarDuration’ that is a given number of calendar
     months long.

*note calyears::
     Construct a ’calendarDuration’ a given number of years long.

*note days::
     Duration in days.

*note duration::
     Represents durations or periods of time as an amount of
     fixed-length time (i.e.

*note hours::
     Create a ’duration’ X hours long, or get the hours in a ’duration’
     X.

*note isduration::
     True if input is a ’duration’ array, false otherwise.

*note milliseconds::
     Create a ’duration’ X milliseconds long, or get the milliseconds in
     a ’duration’ X.

*note minutes::
     Create a ’duration’ X hours long, or get the hours in a ’duration’
     X.

*note seconds::
     Create a ’duration’ X seconds long, or get the seconds in a
     ’duration’ X.

*note timezones::
     List all the time zones defined on this system.

*note years::
     Create a ’duration’ X years long, or get the years in a ’duration’
     X.

10.1.4 Missing Data
-------------------

*note fillmissing::
     Fill missing values.

*note ismissing::
     Find missing values.

*note rmmissing::
     Remove missing values.

*note standardizeMissing::
     Insert standard missing values.

*note missing::
     Generic auto-converting missing value.

*note isnannish::
     Test if elements are NaN or NaN-like

*note eqn::
     Determine element-wise equality, treating NaNs as equal

10.1.5 Validation Functions
---------------------------

*note mustBeA::
     Requires that input is of a given type.

*note mustBeCellstr::
     Requires that input is a cellstr.

*note mustBeCharvec::
     Requires that input is a char row vector.

*note mustBeFinite::
     Requires that input is finite.

*note mustBeInteger::
     Requires that input is integer-valued (but not necessarily
     integer-typed).

*note mustBeMember::
     Requires that input is a member of a set of given valid values.

*note mustBeNonempty::
     Requires that input is nonempty.

*note mustBeNumeric::
     Requires that input is numeric.

*note mustBeReal::
     Requires that input is finite.

*note mustBeSameSize::
     Requires that the inputs are the same size.

*note mustBeScalar::
     Requires that input is scalar.

*note mustBeScalarLogical::
     Requires that input is a scalar logical.

*note mustBeVector::
     Requires that input is a vector or empty.

10.1.6 Miscellaneous
--------------------

*note colvecfun::
     Apply a function to column vectors in array.

*note dispstrs::
     Display strings for array.

*note isfile::
     Test whether file exists and is not a folder.

*note isfolder::
     Test whether file exists and is a folder.

*note pp::
     Alias for prettyprint, for interactive use.

*note scalarexpand::
     Expand scalar inputs to match size of non-scalar inputs.

*note size2str::
     Format an array size for display.

*note splitapply::
     Split data into groups and apply function.

*note vecfun::
     Apply function to vectors in array along arbitrary dimension.

10.1.7 Example Datasets
-----------------------

*note octave.datasets::
     Example dataset collection.

*note octave.dataset::
     The ’dataset’ class provides convenient access to the various
     datasets included with Tablicious.

10.1.8 Example Code
-------------------

*note octave.examples.plot_pairs::
     Plot pairs of variables against each other.

10.1.9 Uncategorized
--------------------

*note iscategorical::
     True if input is a ’categorical’ array, false otherwise.

*note isstring::
     True if input is a ’string’ array, false otherwise.

*note octave.chrono.dummy_function::
     A dummy function just for testing the doco tools.

*note octave.chrono.DummyClass::
     A do-nothing class just for testing the doco tools.


File: tablicious.info,  Node: API Alphabetically,  Prev: API by Category,  Up: API Reference

10.2 API Alphabetically
=======================

* Menu:

* array2table:: Convert an array to a table.
* calendarDuration::	Durations of time using variable-length calendar
		periods, such as days, months, and years, which may vary in
		length over time.
* calmonths::	Create a ’calendarDuration’ that is a given number of
		calendar months long.
* calyears::	Construct a ’calendarDuration’ a given number of years
		long.
* categorical:: Categorical variable array.
* cell2table::	Convert a cell array to a table.
* colvecfun::	Apply a function to column vectors in array.
* contains::	Test if strings contain a pattern.
* datetime::	Represents points in time using the Gregorian calendar.
* days::	Duration in days.
* discretize::	Group data into discrete bins or categories.
* dispstrs::	Display strings for array.
* duration::	Represents durations or periods of time as an amount of
		fixed-length time (i.e.
* endsWith::	Test if strings end with a pattern.
* eqn:: Determine element-wise equality, treating NaNs as equal
* fillmissing:: Fill missing values.
* hours::	Create a ’duration’ X hours long, or get the hours in a
		’duration’ X.
* iscategorical::	True if input is a ’categorical’ array, false
		otherwise.
* isdatetime::	True if input is a ’datetime’ array, false otherwise.
* isduration::	True if input is a ’duration’ array, false otherwise.
* isfile::	Test whether file exists and is not a folder.
* isfolder::	Test whether file exists and is a folder.
* ismissing::	Find missing values.
* isnannish::	Test if elements are NaN or NaN-like
* isstring::	True if input is a ’string’ array, false otherwise.
* localdate::	Represents a complete day using the Gregorian calendar.
* milliseconds::	Create a ’duration’ X milliseconds long, or get the
		milliseconds in a ’duration’ X.
* minutes::	Create a ’duration’ X hours long, or get the hours in a
		’duration’ X.
* missing::	Generic auto-converting missing value.
* mustBeA::	Requires that input is of a given type.
* mustBeCellstr::	Requires that input is a cellstr.
* mustBeCharvec::	Requires that input is a char row vector.
* mustBeFinite::	Requires that input is finite.
* mustBeInteger::	Requires that input is integer-valued (but not
		necessarily integer-typed).
* mustBeMember::	Requires that input is a member of a set of given
		valid values.
* mustBeNonempty::	Requires that input is nonempty.
* mustBeNumeric::	Requires that input is numeric.
* mustBeReal::	Requires that input is finite.
* mustBeSameSize::	Requires that the inputs are the same size.
* mustBeScalar::	Requires that input is scalar.
* mustBeScalarLogical:: Requires that input is a scalar logical.
* mustBeVector::	Requires that input is a vector or empty.
* NaT:: “Not-a-Time”.
* octave.chrono.dummy_function::	A dummy function just for testing
		the doco tools.
* octave.chrono.DummyClass::	A do-nothing class just for testing the
		doco tools.
* octave.dataset::	The ’dataset’ class provides convenient access to
		the various datasets included with Tablicious.
* octave.datasets::	Example dataset collection.
* octave.examples.plot_pairs::	Plot pairs of variables against each other.
* pp::	Alias for prettyprint, for interactive use.
* rmmissing::	Remove missing values.
* scalarexpand::	Expand scalar inputs to match size of non-scalar
		inputs.
* seconds::	Create a ’duration’ X seconds long, or get the seconds in a
		’duration’ X.
* size2str::	Format an array size for display.
* splitapply::	Split data into groups and apply function.
* standardizeMissing::	Insert standard missing values.
* startsWith::	Test if strings start with a pattern.
* string::	A string array of Unicode strings.
* struct2table::	Convert struct to a table.
* table::	Tabular data array containing multiple columnar variables.
* tableOuterFillValue:: Outer fill value for variable within a table.
* timezones::	List all the time zones defined on this system.
* vartype::	Filter by variable type for use in suscripting.
* vecfun::	Apply function to vectors in array along arbitrary
		dimension.
* years::	Create a ’duration’ X years long, or get the years in a
		’duration’ X.


File: tablicious.info,  Node: array2table,  Next: calendarDuration,  Up: API Alphabetically

10.2.1 array2table
------------------

 -- Function: OUT = array2table (C)
 -- Function: OUT = array2table (..., ‘'VariableNames'’, VARIABLENAMES)
 -- Function: OUT = array2table (..., ‘'RowNames'’, ROWNAMES)

     Convert an array to a table.

     Converts a 2-D array to a table, with columns in the array becoming
     variables in the output table.  This is typically used on numeric
     arrays, but it can be applied to any type of array.

     You may not want to use this on cell arrays, though, because you
     will end up with a table that has all its variables of type cell.
     If you use ‘cell2table’ instead, columns of the cell array which
     can be condensed into primitive arrays will be.  With
     ‘array2table’, they won’t be.

     See also: *note cell2table::, *note table::, *note struct2table::


File: tablicious.info,  Node: calendarDuration,  Next: calmonths,  Prev: array2table,  Up: API Alphabetically

10.2.2 calendarDuration
-----------------------

 -- Class: calendarDuration

     Durations of time using variable-length calendar periods, such as
     days, months, and years, which may vary in length over time.  (For
     example, a calendar month may have 28, 30, or 31 days.)

 -- Instance Variable of calendarDuration: ‘char’ Sign

     The sign (1 or -1) of this duration, which indicates whether it is
     a positive or negative span of time.

 -- Instance Variable of calendarDuration: ‘char’ Years

     The number of whole calendar years in this duration.  Must be
     integer-valued.

 -- Instance Variable of calendarDuration: ‘char’ Months

     The number of whole calendar months in this duration.  Must be
     integer-valued.

 -- Instance Variable of calendarDuration: ‘char’ Days

     The number of whole calendar days in this duration.  Must be
     integer-valued.

 -- Instance Variable of calendarDuration: ‘char’ Hours

     The number of whole hours in this duration.  Must be
     integer-valued.

 -- Instance Variable of calendarDuration: ‘char’ Minutes

     The number of whole minutes in this duration.  Must be
     integer-valued.

 -- Instance Variable of calendarDuration: ‘char’ Seconds

     The number of seconds in this duration.  May contain fractional
     values.

 -- Instance Variable of calendarDuration: ‘char’ Format

     The format to display this ‘calendarDuration’ in.  Currently
     unsupported.

     This is a single value that applies to the whole array.

* Menu:

* calendarDuration.calendarDuration::
* calendarDuration.sizeof::
* calendarDuration.isnat::
* calendarDuration.uminus::
* calendarDuration.plus::
* calendarDuration.times::
* calendarDuration.minus::
* calendarDuration.dispstrs::
* calendarDuration.isnan::


File: tablicious.info,  Node: calendarDuration.calendarDuration,  Next: calendarDuration.sizeof,  Up: calendarDuration

10.2.2.1 calendarDuration.calendarDuration
..........................................

 -- Constructor: OBJ = calendarDuration ()

     Constructs a new scalar ‘calendarDuration’ of zero elapsed time.

 -- Constructor: OBJ = calendarDuration (Y, M, D)
 -- Constructor: OBJ = calendarDuration (Y, M, D, H, MI, S)

     Constructs new ‘calendarDuration’ arrays based on input values.


File: tablicious.info,  Node: calendarDuration.sizeof,  Next: calendarDuration.isnat,  Prev: calendarDuration.calendarDuration,  Up: calendarDuration

10.2.2.2 calendarDuration.sizeof
................................

 -- Method: OUT = sizeof (OBJ)

     Size of array in bytes.


File: tablicious.info,  Node: calendarDuration.isnat,  Next: calendarDuration.uminus,  Prev: calendarDuration.sizeof,  Up: calendarDuration

10.2.2.3 calendarDuration.isnat
...............................

 -- Method: OUT = isnat (OBJ)

     True if input elements are NaT.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: calendarDuration.uminus,  Next: calendarDuration.plus,  Prev: calendarDuration.isnat,  Up: calendarDuration

10.2.2.4 calendarDuration.uminus
................................

 -- Method: OUT = uminus (OBJ)

     Unary minus.  Negates the sign of OBJ.


File: tablicious.info,  Node: calendarDuration.plus,  Next: calendarDuration.times,  Prev: calendarDuration.uminus,  Up: calendarDuration

10.2.2.5 calendarDuration.plus
..............................

 -- Method: OUT = plus (A, B)

     Addition: add two ‘calendarDuration’s.

     All the calendar elements (properties) of the two inputs are added
     together.  No normalization is done across the elements, aside from
     the normalization of NaNs.

     If B is numeric, it is converted to a ‘calendarDuration’ using
     ‘calendarDuration.ofDays’.

     Returns a ‘calendarDuration’.


File: tablicious.info,  Node: calendarDuration.times,  Next: calendarDuration.minus,  Prev: calendarDuration.plus,  Up: calendarDuration

10.2.2.6 calendarDuration.times
...............................

 -- Method: OUT = times (OBJ, B)

     Multiplication: Multiplies a ‘calendarDuration’ by a numeric
     factor.

     Returns a ‘calendarDuration’.


File: tablicious.info,  Node: calendarDuration.minus,  Next: calendarDuration.dispstrs,  Prev: calendarDuration.times,  Up: calendarDuration

10.2.2.7 calendarDuration.minus
...............................

 -- Method: OUT = times (A, B)

     Subtraction: Subtracts one ‘calendarDuration’ from another.

     Returns a ‘calendarDuration’.


File: tablicious.info,  Node: calendarDuration.dispstrs,  Next: calendarDuration.isnan,  Prev: calendarDuration.minus,  Up: calendarDuration

10.2.2.8 calendarDuration.dispstrs
..................................

 -- Method: OUT = dispstrs (OBJ)

     Get display strings for each element of OBJ.

     Returns a cellstr the same size as OBJ.


File: tablicious.info,  Node: calendarDuration.isnan,  Prev: calendarDuration.dispstrs,  Up: calendarDuration

10.2.2.9 calendarDuration.isnan
...............................

 -- Method: OUT = isnan (OBJ)

     True if input elements are NaT. This is just an alias for ‘isnat’,
     provided for compatibility and polymorphic programming purposes.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: calmonths,  Next: calyears,  Prev: calendarDuration,  Up: API Alphabetically

10.2.3 calmonths
----------------

 -- Function File: OUT = calmonths (X)
     Create a ‘calendarDuration’ that is a given number of calendar
     months long.

     Input X is a numeric array specifying the number of calendar
     months.

     This is a shorthand alternative to calling the ‘calendarDuration’
     constructor with ‘calendarDuration(0, x, 0)’.

     Returns a new ‘calendarDuration’ object of the same size as X.

     *Note calendarDuration::.


File: tablicious.info,  Node: calyears,  Next: categorical,  Prev: calmonths,  Up: API Alphabetically

10.2.4 calyears
---------------

 -- Function: OUT = calyears (X)

     Construct a ‘calendarDuration’ a given number of years long.

     This is a shorthand for calling ‘calendarDuration(X, 0, 0)’.

     *Note calendarDuration::.


File: tablicious.info,  Node: categorical,  Next: cell2table,  Prev: calyears,  Up: API Alphabetically

10.2.5 categorical
------------------

 -- Class: categorical

     Categorical variable array.

     A ‘categorical’ array represents an array of values of a
     categorical variable.  Each ‘categorical’ array stores the element
     values along with a list of the categories, and indicators of
     whether the categories are ordinal (that is, they have a meaningful
     mathematical ordering), and whether the set of categories is
     protected (preventing new categories from being added to the
     array).

     In addition to the categories defined in the array, a categorical
     array may have elements of "undefined" value.  This is not
     considered a category; rather, it is the absence of any known
     value.  It is analagous to a ‘NaN’ value.

     This class is not fully implemented yet.  Missing stuff: - gt, ge,
     lt, le - Ordinal support in general - countcats - summary

 -- Instance Variable of categorical: ‘uint16’ code

     The numeric codes of the array element values.  These are indexes
     into the ‘cats’ category list.

     This is a planar property.

 -- Instance Variable of categorical: ‘logical’ tfMissing

     A logical mask indicating whether each element of the array is
     missing (that is, undefined).

     This is a planar property.

 -- Instance Variable of categorical: ‘cellstr’ cats

     The names of the categories in this array.  This is the list into
     which the ‘code’ values are indexes.

 -- Instance Variable of categorical: ‘scalar_logical’ isOrdinal

     A scalar logical indicating whether the categories in this array
     have an ordinal relationship.

* Menu:

* categorical.undefined::
* categorical.categorical::
* categorical.sizeof::
* categorical.categories::
* categorical.iscategory::
* categorical.isordinal::
* categorical.string::
* categorical.cellstr::
* categorical.dispstrs::
* categorical.summary::
* categorical.addcats::
* categorical.removecats::
* categorical.mergecats::
* categorical.renamecats::
* categorical.reordercats::
* categorical.setcats::
* categorical.isundefined::
* categorical.ismissing::
* categorical.isnannish::
* categorical.squeezecats::


File: tablicious.info,  Node: categorical.undefined,  Next: categorical.categorical,  Up: categorical

10.2.5.1 categorical.undefined
..............................

 -- Static Method: OUT = categorical.undefined ()
 -- Static Method: OUT = categorical.undefined (sz)

     Create an array of undefined categoricals.

     Creates a categorical array whose elements are all <undefined>.

     SZ is the size of the array to create.  If omitted or empty,
     creates a scalar.

     Returns a categorical.


File: tablicious.info,  Node: categorical.categorical,  Next: categorical.sizeof,  Prev: categorical.undefined,  Up: categorical

10.2.5.2 categorical.categorical
................................

 -- Constructor: OBJ = categorical ()

     Constructs a new scalar categorical whose value is undefined.

 -- Constructor: OBJ = categorical (VALS)
 -- Constructor: OBJ = categorical (VALS, VALUESET)
 -- Constructor: OBJ = categorical (VALS, VALUESET, CATEGORY_NAMES)
 -- Constructor: OBJ = categorical (..., ‘'Ordinal'’, ORDINAL)
 -- Constructor: OBJ = categorical (..., ‘'Protected'’, PROTECTED)

     Constructs a new categorical array from the given values.

     VALS is the array of values to convert to categoricals.

     VALUESET is the set of all values from which VALS is drawn.  If
     omitted, it defaults to the unique values in VALS.

     CATEGORY_NAMES is a list of category names corresponding to
     VALUESET.  If omitted, it defaults to VALUESET, converted to
     strings.

     ORDINAL is a logical indicating whether the category values in OBJ
     have a numeric ordering relationship.  Defaults to false.

     PROTECTED indicates whether OBJ should be protected, which prevents
     the addition of new categories to the array.  Defaults to false.


File: tablicious.info,  Node: categorical.sizeof,  Next: categorical.categories,  Prev: categorical.categorical,  Up: categorical

10.2.5.3 categorical.sizeof
...........................

 -- Method: OUT = sizeof (OBJ)

     Size of array in bytes.


File: tablicious.info,  Node: categorical.categories,  Next: categorical.iscategory,  Prev: categorical.sizeof,  Up: categorical

10.2.5.4 categorical.categories
...............................

 -- Method: OUT = categories (OBJ)

     Get a list of the categories in OBJ.

     Gets a list of the categories in OBJ, identified by their category
     names.

     Returns a cellstr column vector.


File: tablicious.info,  Node: categorical.iscategory,  Next: categorical.isordinal,  Prev: categorical.categories,  Up: categorical

10.2.5.5 categorical.iscategory
...............................

 -- Method: OUT = iscategory (OBJ, CATNAMES)

     Test whether input is a category on a categorical array.

     CATNAMES is a cellstr listing the category names to check against
     OBJ.

     Returns a logical array the same size as CATNAMES.


File: tablicious.info,  Node: categorical.isordinal,  Next: categorical.string,  Prev: categorical.iscategory,  Up: categorical

10.2.5.6 categorical.isordinal
..............................

 -- Method: OUT = isordinal (OBJ)

     Whether OBJ is ordinal.

     Returns true if OBJ is ordinal (as determined by its ‘IsOrdinal’
     property), and false otherwise.


File: tablicious.info,  Node: categorical.string,  Next: categorical.cellstr,  Prev: categorical.isordinal,  Up: categorical

10.2.5.7 categorical.string
...........................

 -- Method: OUT = string (OBJ)

     Convert to string array.

     Converts OBJ to a string array.  The strings will be the category
     names for corresponding values, or <missing> for undefined values.

     Returns a ‘string’ array the same size as OBJ.


File: tablicious.info,  Node: categorical.cellstr,  Next: categorical.dispstrs,  Prev: categorical.string,  Up: categorical

10.2.5.8 categorical.cellstr
............................

 -- Method: OUT = cellstr (OBJ)

     Convert to cellstr.

     Converts OBJ to a cellstr array.  The strings will be the category
     names for corresponding values, or ‘''’ for undefined values.

     Returns a cellstr array the same size as OBJ.


File: tablicious.info,  Node: categorical.dispstrs,  Next: categorical.summary,  Prev: categorical.cellstr,  Up: categorical

10.2.5.9 categorical.dispstrs
.............................

 -- Method: OUT = dispstrs (OBJ)

     Display strings.

     Gets display strings for each element in OBJ.  The display strings
     are either the category string, or ‘'<undefined>'’ for undefined
     values.

     Returns a cellstr array the same size as OBJ.


File: tablicious.info,  Node: categorical.summary,  Next: categorical.addcats,  Prev: categorical.dispstrs,  Up: categorical

10.2.5.10 categorical.summary
.............................

 -- Method: summary (OBJ)

     Display summary of array’s values.

     Displays a summary of the values in this categorical array.  The
     output may contain info like the number of categories, number of
     undefined values, and frequency of each category.


File: tablicious.info,  Node: categorical.addcats,  Next: categorical.removecats,  Prev: categorical.summary,  Up: categorical

10.2.5.11 categorical.addcats
.............................

 -- Method: OUT = addcats (OBJ, NEWCATS)

     Add categories to categorical array.

     Adds the specified categories to OBJ, without changing any of its
     values.

     NEWCATS is a cellstr listing the category names to add to OBJ.


File: tablicious.info,  Node: categorical.removecats,  Next: categorical.mergecats,  Prev: categorical.addcats,  Up: categorical

10.2.5.12 categorical.removecats
................................

 -- Method: OUT = removecats (OBJ)

     Removes all unused categories from OBJ.  This is equivalent to ‘out
     = squeezecats (obj)’.

 -- Method: OUT = removecats (OBJ, OLDCATS)

     Remove categories from categorical array.

     Removes the specified categories from OBJ.  Elements of OBJ whose
     values belonged to those categories are replaced with undefined.

     NEWCATS is a cellstr listing the category names to add to OBJ.


File: tablicious.info,  Node: categorical.mergecats,  Next: categorical.renamecats,  Prev: categorical.removecats,  Up: categorical

10.2.5.13 categorical.mergecats
...............................

 -- Method: OUT = mergecats (OBJ, OLDCATS)
 -- Method: OUT = mergecats (OBJ, OLDCATS, NEWCAT)

     Merge multiple categories.

     Merges the categories OLDCATS into a single category.  If NEWCAT is
     specified, that new category is added if necessary, and all of
     OLDCATS are merged into it.  NEWCAT must be an existing category in
     OBJ if OBJ is ordinal.

     If NEWCAT is not provided, all of ODCATS are merged into
     ‘oldcats{1}’.


File: tablicious.info,  Node: categorical.renamecats,  Next: categorical.reordercats,  Prev: categorical.mergecats,  Up: categorical

10.2.5.14 categorical.renamecats
................................

 -- Method: OUT = renamecats (OBJ, NEWCATS)
 -- Method: OUT = renamecats (OBJ, OLDCATS, NEWCATS)

     Rename categories.

     Renames some or all of the categories in OBJ, without changing any
     of its values.


File: tablicious.info,  Node: categorical.reordercats,  Next: categorical.setcats,  Prev: categorical.renamecats,  Up: categorical

10.2.5.15 categorical.reordercats
.................................

 -- Method: OUT = reordercats (OBJ)
 -- Method: OUT = reordercats (OBJ, NEWCATS)

     Reorder categories.

     Reorders the categories in OBJ to match NEWCATS.

     NEWCATS is a cellstr that must be a reordering of OBJ’s existing
     category list.  If NEWCATS is not supplied, sorts the categories in
     alphabetical order.


File: tablicious.info,  Node: categorical.setcats,  Next: categorical.isundefined,  Prev: categorical.reordercats,  Up: categorical

10.2.5.16 categorical.setcats
.............................

 -- Method: OUT = setcats (OBJ, NEWCATS)

     Set categories for categorical array.

     Sets the categories to use for OBJ.  If any current categories are
     absent from the NEWCATS list, current values of those categories
     become undefined.


File: tablicious.info,  Node: categorical.isundefined,  Next: categorical.ismissing,  Prev: categorical.setcats,  Up: categorical

10.2.5.17 categorical.isundefined
.................................

 -- Method: OUT = isundefined (OBJ)

     Test whether elements are undefined.

     Checks whether each element in OBJ is undefined.  "Undefined" is a
     special value defined by ‘categorical’.  It is equivalent to a
     ‘NaN’ or a ‘missing’ value.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: categorical.ismissing,  Next: categorical.isnannish,  Prev: categorical.isundefined,  Up: categorical

10.2.5.18 categorical.ismissing
...............................

 -- Method: OUT = ismissing (OBJ)

     Test whether elements are missing.

     For categorical arrays, undefined elements are considered to be
     missing.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: categorical.isnannish,  Next: categorical.squeezecats,  Prev: categorical.ismissing,  Up: categorical

10.2.5.19 categorical.isnannish
...............................

 -- Method: OUT = isnannish (OBJ)

     Test whethere elements are NaN-ish.

     Checks where each element in OBJ is NaN-ish.  For categorical
     arrays, undefined values are considered NaN-ish; any other value is
     not.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: categorical.squeezecats,  Prev: categorical.isnannish,  Up: categorical

10.2.5.20 categorical.squeezecats
.................................

 -- Method: OUT = squeezecats (OBJ)

     Remove unused categories.

     Removes all categories which have no corresponding values in OBJ’s
     elements.

     This is currently unimplemented.


File: tablicious.info,  Node: cell2table,  Next: colvecfun,  Prev: categorical,  Up: API Alphabetically

10.2.6 cell2table
-----------------

 -- Function: OUT = cell2table (C)
 -- Function: OUT = cell2table (..., ‘'VariableNames'’, VARIABLENAMES)
 -- Function: OUT = cell2table (..., ‘'RowNames'’, ROWNAMES)

     Convert a cell array to a table.

     Converts a 2-dimensional cell matrix into a table.  Each column in
     the input C becomes a variable in OUT.  For columns that contain
     all scalar values of ‘cat’-compatible types, they are “popped out”
     of their cells and condensed into a homogeneous array of the
     contained type.

     See also: *note array2table::, *note table::, *note struct2table::


File: tablicious.info,  Node: colvecfun,  Next: contains,  Prev: cell2table,  Up: API Alphabetically

10.2.7 colvecfun
----------------

 -- Function: OUT = colvecfun (FCN, X)

     Apply a function to column vectors in array.

     Applies the given function FCN to each column vector in the array
     X, by iterating over the indexes along all dimensions except
     dimension 1.  Collects the function return values in an output
     array.

     FCN must be a function which takes a column vector and returns a
     column vector of the same size.  It does not have to return the
     same type as X.

     Returns the result of applying fcn to each column in x, all
     concatenated together in the same shape as x.


File: tablicious.info,  Node: contains,  Next: datetime,  Prev: colvecfun,  Up: API Alphabetically

10.2.8 contains
---------------

 -- Function: OUT = colvecfun (STR, PATTERN)
 -- Function: OUT = colvecfun (..., ‘'IgnoreCase'’, IGNORECASE)

     Test if strings contain a pattern.

     Tests whether the given strings contain the given pattern(s).

     STR (char, cellstr, or string) is a list of strings to compare
     against pattern.

     PATTERN (char, cellstr, or string) is a list of patterns to match.
     These are literal plain string patterns, not regex patterns.  If
     more than one pattern is supplied, the return value is true if the
     string matched any of them.

     Returns a logical array of the same size as the string array
     represented by STR.


File: tablicious.info,  Node: datetime,  Next: days,  Prev: contains,  Up: API Alphabetically

10.2.9 datetime
---------------

 -- Class: datetime

     Represents points in time using the Gregorian calendar.

     The underlying values are doubles representing the number of days
     since the Matlab epoch of "January 0, year 0".  This has a
     precision of around nanoseconds for typical times.

     A ‘datetime’ array is an array of date/time values, with each
     element holding a complete date/time.  The overall array may also
     have a TimeZone and a Format associated with it, which apply to all
     elements in the array.

     This is an attempt to reproduce the functionality of Matlab’s
     ‘datetime’.  It also contains some Octave-specific extensions.

 -- Instance Variable of datetime: ‘double’ dnums

     The underlying datenums that represent the points in time.  These
     are always in UTC.

     This is a planar property: the size of ‘dnums’ is the same size as
     the containing ‘datetime’ array object.

 -- Instance Variable of datetime: ‘char’ TimeZone

     The time zone this ‘datetime’ array is in.  Empty if this does not
     have a time zone associated with it (“unzoned”).  The name of an
     IANA time zone if this does.

     Setting the ‘TimeZone’ of a ‘datetime’ array changes the time zone
     it is presented in for strings and broken-down times, but does not
     change the underlying UTC times that its elements represent.

 -- Instance Variable of datetime: ‘char’ Format

     The format to display this ‘datetime’ in.  Currently unsupported.

* Menu:

* datetime.datetime::
* datetime.ofDatenum::
* datetime.ofDatestruct::
* datetime.NaT::
* datetime.posix2datenum::
* datetime.datenum2posix::
* datetime.sizeof::
* datetime.proxyKeys::
* datetime.ymd::
* datetime.hms::
* datetime.ymdhms::
* datetime.timeofday::
* datetime.week::
* datetime.dispstrs::
* datetime.datestr::
* datetime.datestrs::
* datetime.datestruct::
* datetime.posixtime::
* datetime.datenum::
* datetime.gmtime::
* datetime.localtime::
* datetime.isnat::
* datetime.isnan::
* datetime.lt::
* datetime.le::
* datetime.ne::
* datetime.eq::
* datetime.ge::
* datetime.gt::
* datetime.plus::
* datetime.minus::
* datetime.diff::
* datetime.isbetween::
* datetime.linspace::
* datetime.convertDatenumTimeZone::


File: tablicious.info,  Node: datetime.datetime,  Next: datetime.ofDatenum,  Up: datetime

10.2.9.1 datetime.datetime
..........................

 -- Constructor: OBJ = datetime ()

     Constructs a new scalar ‘datetime’ containing the current local
     time, with no time zone attached.

 -- Constructor: OBJ = datetime (DATEVEC)
 -- Constructor: OBJ = datetime (DATESTRS)
 -- Constructor: OBJ = datetime (IN, ‘'ConvertFrom'’, INTYPE)
 -- Constructor: OBJ = datetime (Y, M, D, H, MI, S)
 -- Constructor: OBJ = datetime (Y, M, D, H, MI, MS)
 -- Constructor: OBJ = datetime (..., ‘'Format'’, FORMAT,
          ‘'InputFormat'’, INPUTFORMAT, ‘'Locale'’, INPUTLOCALE,
          ‘'PivotYear'’, PIVOTYEAR, ‘'TimeZone'’, TIMEZONE)

     Constructs a new ‘datetime’ array based on input values.


File: tablicious.info,  Node: datetime.ofDatenum,  Next: datetime.ofDatestruct,  Prev: datetime.datetime,  Up: datetime

10.2.9.2 datetime.ofDatenum
...........................

 -- Static Method: OBJ = datetime.ofDatenum (DNUMS)

     Converts a datenum array to a datetime array.

     Returns an unzoned ‘datetime’ array of the same size as the input.


File: tablicious.info,  Node: datetime.ofDatestruct,  Next: datetime.NaT,  Prev: datetime.ofDatenum,  Up: datetime

10.2.9.3 datetime.ofDatestruct
..............................

 -- Static Method: OBJ = datetime.ofDatestruct (DSTRUCT)

     Converts a datestruct to a datetime array.

     A datestruct is a special struct format used by Chrono that has
     fields Year, Month, Day, Hour, Minute, and Second.  It is not a
     standard Octave datatype.

     Returns an unzoned ‘datetime’ array.


File: tablicious.info,  Node: datetime.NaT,  Next: datetime.posix2datenum,  Prev: datetime.ofDatestruct,  Up: datetime

10.2.9.4 datetime.NaT
.....................

 -- Static Method: OUT = datetime.NaT ()
 -- Static Method: OUT = datetime.NaT (SZ)

     “Not-a-Time”: Creates NaT-valued arrays.

     Constructs a new ‘datetime’ array of all ‘NaT’ values of the given
     size.  If no input SZ is given, the result is a scalar ‘NaT’.

     ‘NaT’ is the ‘datetime’ equivalent of ‘NaN’.  It represents a
     missing or invalid value.  ‘NaT’ values never compare equal to,
     greater than, or less than any value, including other ‘NaT’s.
     Doing arithmetic with a ‘NaT’ and any other value results in a
     ‘NaT’.


File: tablicious.info,  Node: datetime.posix2datenum,  Next: datetime.datenum2posix,  Prev: datetime.NaT,  Up: datetime

10.2.9.5 datetime.posix2datenum
...............................

 -- Static Method: DNUMS = datetime.posix2datenum (PDATES)

     Converts POSIX (Unix) times to datenums

     Pdates (numeric) is an array of POSIX dates.  A POSIX date is the
     number of seconds since January 1, 1970 UTC, excluding leap
     seconds.  The output is implicitly in UTC.


File: tablicious.info,  Node: datetime.datenum2posix,  Next: datetime.sizeof,  Prev: datetime.posix2datenum,  Up: datetime

10.2.9.6 datetime.datenum2posix
...............................

 -- Static Method: OUT = datetime.datenum2posix (DNUMS)

     Converts Octave datenums to Unix dates.

     The input datenums are assumed to be in UTC.

     Returns a double, which may have fractional seconds.


File: tablicious.info,  Node: datetime.sizeof,  Next: datetime.proxyKeys,  Prev: datetime.datenum2posix,  Up: datetime

10.2.9.7 datetime.sizeof
........................

 -- Method: OUT = sizeof (OBJ)

     Size of array in bytes.


File: tablicious.info,  Node: datetime.proxyKeys,  Next: datetime.ymd,  Prev: datetime.sizeof,  Up: datetime

10.2.9.8 datetime.proxyKeys
...........................

 -- Method: [KEYSA, KEYSB] = proxyKeys (A, B)

     Computes proxy key values for two datetime arrays.  Proxy keys are
     numeric values whose rows have the same equivalence relationships
     as the elements of the inputs.

     This is primarily for Chrono’s internal use; users will typically
     not need to call it or know how it works.

     Returns two 2-D numeric matrices of size n-by-k, where n is the
     number of elements in the corresponding input.


File: tablicious.info,  Node: datetime.ymd,  Next: datetime.hms,  Prev: datetime.proxyKeys,  Up: datetime

10.2.9.9 datetime.ymd
.....................

 -- Method: [Y, M, D] = ymd (OBJ)

     Get the Year, Month, and Day components of OBJ.

     For zoned ‘datetime’s, these will be local times in the associated
     time zone.

     Returns double arrays the same size as ‘obj’.


File: tablicious.info,  Node: datetime.hms,  Next: datetime.ymdhms,  Prev: datetime.ymd,  Up: datetime

10.2.9.10 datetime.hms
......................

 -- Method: [H, M, S] = hms (OBJ)

     Get the Hour, Minute, and Second components of a OBJ.

     For zoned ‘datetime’s, these will be local times in the associated
     time zone.

     Returns double arrays the same size as ‘obj’.


File: tablicious.info,  Node: datetime.ymdhms,  Next: datetime.timeofday,  Prev: datetime.hms,  Up: datetime

10.2.9.11 datetime.ymdhms
.........................

 -- Method: [Y, M, D, H, MI, S] = ymdhms (OBJ)

     Get the Year, Month, Day, Hour, Minute, and Second components of a
     OBJ.

     For zoned ‘datetime’s, these will be local times in the associated
     time zone.

     Returns double arrays the same size as ‘obj’.


File: tablicious.info,  Node: datetime.timeofday,  Next: datetime.week,  Prev: datetime.ymdhms,  Up: datetime

10.2.9.12 datetime.timeofday
............................

 -- Method: OUT = timeofday (OBJ)

     Get the time of day (elapsed time since midnight).

     For zoned ‘datetime’s, these will be local times in the associated
     time zone.

     Returns a ‘duration’ array the same size as ‘obj’.


File: tablicious.info,  Node: datetime.week,  Next: datetime.dispstrs,  Prev: datetime.timeofday,  Up: datetime

10.2.9.13 datetime.week
.......................

 -- Method: OUT = week (OBJ)

     Get the week of the year.

     This method is unimplemented.


File: tablicious.info,  Node: datetime.dispstrs,  Next: datetime.datestr,  Prev: datetime.week,  Up: datetime

10.2.9.14 datetime.dispstrs
...........................

 -- Method: OUT = dispstrs (OBJ)

     Get display strings for each element of OBJ.

     Returns a cellstr the same size as OBJ.


File: tablicious.info,  Node: datetime.datestr,  Next: datetime.datestrs,  Prev: datetime.dispstrs,  Up: datetime

10.2.9.15 datetime.datestr
..........................

 -- Method: OUT = datestr (OBJ)
 -- Method: OUT = datestr (OBJ, ...)

     Format OBJ as date strings.  Supports all arguments that core
     Octave’s ‘datestr’ does.

     Returns date strings as a 2-D char array.


File: tablicious.info,  Node: datetime.datestrs,  Next: datetime.datestruct,  Prev: datetime.datestr,  Up: datetime

10.2.9.16 datetime.datestrs
...........................

 -- Method: OUT = datestrs (OBJ)
 -- Method: OUT = datestrs (OBJ, ...)

     Format OBJ as date strings, returning cellstr.  Supports all
     arguments that core Octave’s ‘datestr’ does.

     Returns a cellstr array the same size as OBJ.


File: tablicious.info,  Node: datetime.datestruct,  Next: datetime.posixtime,  Prev: datetime.datestrs,  Up: datetime

10.2.9.17 datetime.datestruct
.............................

 -- Method: OUT = datestruct (OBJ)

     Converts this to a "datestruct" broken-down time structure.

     A "datestruct" is a format of struct that Chrono came up with.  It
     is a scalar struct with fields Year, Month, Day, Hour, Minute, and
     Second, each containing a double array the same size as the date
     array it represents.

     The values in the returned broken-down time are those of the local
     time in this’ defined time zone, if it has one.

     Returns a struct with fields Year, Month, Day, Hour, Minute, and
     Second.  Each field contains a double array of the same size as
     this.


File: tablicious.info,  Node: datetime.posixtime,  Next: datetime.datenum,  Prev: datetime.datestruct,  Up: datetime

10.2.9.18 datetime.posixtime
............................

 -- Method: OUT = posixtime (OBJ)

     Converts this to POSIX time values (seconds since the Unix epoch)

     Converts this to POSIX time values that represent the same time.
     The returned values will be doubles that may include fractional
     second values.  POSIX times are, by definition, in UTC.

     Returns double array of same size as this.


File: tablicious.info,  Node: datetime.datenum,  Next: datetime.gmtime,  Prev: datetime.posixtime,  Up: datetime

10.2.9.19 datetime.datenum
..........................

 -- Method: OUT = datenum (OBJ)

     Convert this to datenums that represent the same local time

     Returns double array of same size as this.


File: tablicious.info,  Node: datetime.gmtime,  Next: datetime.localtime,  Prev: datetime.datenum,  Up: datetime

10.2.9.20 datetime.gmtime
.........................

 -- Method: OUT = gmtime (OBJ)

     Convert to TM_STRUCT structure in UTC time.

     Converts OBJ to a TM_STRUCT style structure array.  The result is
     in UTC time.  If OBJ is unzoned, it is assumed to be in UTC time.

     Returns a struct array in TM_STRUCT style.


File: tablicious.info,  Node: datetime.localtime,  Next: datetime.isnat,  Prev: datetime.gmtime,  Up: datetime

10.2.9.21 datetime.localtime
............................

 -- Method: OUT = localtime (OBJ)

     Convert to TM_STRUCT structure in UTC time.

     Converts OBJ to a TM_STRUCT style structure array.  The result is a
     local time in the system default time zone.  Note that the system
     default time zone is always used, regardless of what TimeZone is
     set on OBJ.

     If OBJ is unzoned, it is assumed to be in UTC time.

     Returns a struct array in TM_STRUCT style.

     Example:
          dt = datetime;
          dt.TimeZone = datetime.SystemTimeZone;
          tm_struct = localtime (dt);


File: tablicious.info,  Node: datetime.isnat,  Next: datetime.isnan,  Prev: datetime.localtime,  Up: datetime

10.2.9.22 datetime.isnat
........................

 -- Method: OUT = isnat (OBJ)

     True if input elements are NaT.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.isnan,  Next: datetime.lt,  Prev: datetime.isnat,  Up: datetime

10.2.9.23 datetime.isnan
........................

 -- Method: OUT = isnan (OBJ)

     True if input elements are NaT. This is an alias for ‘isnat’ to
     support type compatibility and polymorphic programming.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.lt,  Next: datetime.le,  Prev: datetime.isnan,  Up: datetime

10.2.9.24 datetime.lt
.....................

 -- Method: OUT = lt (A, B)

     True if A is less than B.  This defines the ‘<’ operator for
     ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.le,  Next: datetime.ne,  Prev: datetime.lt,  Up: datetime

10.2.9.25 datetime.le
.....................

 -- Method: OUT = le (A, B)

     True if A is less than or equal toB.  This defines the ‘<=’
     operator for ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.ne,  Next: datetime.eq,  Prev: datetime.le,  Up: datetime

10.2.9.26 datetime.ne
.....................

 -- Method: OUT = ne (A, B)

     True if A is not equal to B.  This defines the ‘!=’ operator for
     ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.eq,  Next: datetime.ge,  Prev: datetime.ne,  Up: datetime

10.2.9.27 datetime.eq
.....................

 -- Method: OUT = eq (A, B)

     True if A is equal to B.  This defines the ‘==’ operator for
     ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.ge,  Next: datetime.gt,  Prev: datetime.eq,  Up: datetime

10.2.9.28 datetime.ge
.....................

 -- Method: OUT = ge (A, B)

     True if A is greater than or equal to B.  This defines the ‘>=’
     operator for ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.gt,  Next: datetime.plus,  Prev: datetime.ge,  Up: datetime

10.2.9.29 datetime.gt
.....................

 -- Method: OUT = gt (A, B)

     True if A is greater than B.  This defines the ‘>’ operator for
     ‘datetime’s.

     Inputs are implicitly converted to ‘datetime’ using the one-arg
     constructor or conversion method.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: datetime.plus,  Next: datetime.minus,  Prev: datetime.gt,  Up: datetime

10.2.9.30 datetime.plus
.......................

 -- Method: OUT = plus (A, B)

     Addition (‘+’ operator).  Adds a ‘duration’, ‘calendarDuration’, or
     numeric B to a ‘datetime’ A.

     A must be a ‘datetime’.

     Numeric B inputs are implicitly converted to ‘duration’ using
     ‘duration.ofDays’.

     Returns ‘datetime’ array the same size as A.


File: tablicious.info,  Node: datetime.minus,  Next: datetime.diff,  Prev: datetime.plus,  Up: datetime

10.2.9.31 datetime.minus
........................

 -- Method: OUT = minus (A, B)

     Subtraction (‘-’ operator).  Subtracts a ‘duration’,
     ‘calendarDuration’ or numeric B from a ‘datetime’ A, or subtracts
     two ‘datetime’s from each other.

     If both inputs are ‘datetime’, then the output is a ‘duration’.
     Otherwise, the output is a ‘datetime’.

     Numeric B inputs are implicitly converted to ‘duration’ using
     ‘duration.ofDays’.

     Returns an array the same size as A.


File: tablicious.info,  Node: datetime.diff,  Next: datetime.isbetween,  Prev: datetime.minus,  Up: datetime

10.2.9.32 datetime.diff
.......................

 -- Method: OUT = diff (OBJ)

     Differences between elements.

     Computes the difference between each successive element in OBJ, as
     a ‘duration’.

     Returns a ‘duration’ array the same size as OBJ.


File: tablicious.info,  Node: datetime.isbetween,  Next: datetime.linspace,  Prev: datetime.diff,  Up: datetime

10.2.9.33 datetime.isbetween
............................

 -- Method: OUT = isbetween (OBJ, LOWER, UPPER)

     Tests whether the elements of OBJ are between LOWER and UPPER.

     All inputs are implicitly converted to ‘datetime’ arrays, and are
     subject to scalar expansion.

     Returns a logical array the same size as the scalar expansion of
     the inputs.


File: tablicious.info,  Node: datetime.linspace,  Next: datetime.convertDatenumTimeZone,  Prev: datetime.isbetween,  Up: datetime

10.2.9.34 datetime.linspace
...........................

 -- Method: OUT = linspace (FROM, TO, N)

     Linearly-spaced values in date/time space.

     Constructs a vector of ‘datetime’s that represent linearly spaced
     points starting at FROM and going up to TO, with N points in the
     vector.

     FROM and TO are implicitly converted to ‘datetime’s.

     N is how many points to use.  If omitted, defaults to 100.

     Returns an N-long ‘datetime’ vector.


File: tablicious.info,  Node: datetime.convertDatenumTimeZone,  Prev: datetime.linspace,  Up: datetime

10.2.9.35 datetime.convertDatenumTimeZone
.........................................

 -- Static Method: OUT = datetime.convertDatenumTimeZone (DNUM,
          FROMZONEID, TOZONEID)

     Convert a datenum from one time zone to another.

     DNUM is a datenum array to convert.

     FROMZONEID is a charvec containing the IANA Time Zone identifier
     for the time zone to convert from.

     TOZONEID is a charvec containing the IANA Time Zone identifier for
     the time zone to convert to.

     Returns a datenum array the same size as DNUM.


File: tablicious.info,  Node: days,  Next: discretize,  Prev: datetime,  Up: API Alphabetically

10.2.10 days
------------

 -- Function: OUT = days (X)

     Duration in days.

     If X is numeric, then OUT is a ‘duration’ array in units of
     fixed-length 24-hour days, with the same size as X.

     If X is a ‘duration’, then returns a ‘double’ array the same size
     as X indicating the number of fixed-length days that each duration
     is.


File: tablicious.info,  Node: discretize,  Next: dispstrs,  Prev: days,  Up: API Alphabetically

10.2.11 discretize
------------------

 -- Function: [Y, E] = discretize (X, N)
 -- Function: [Y, E] = discretize (X, EDGES)
 -- Function: [Y, E] = discretize (X, DUR)
 -- Function: [Y, E] = discretize (..., ‘'categorical'’)
 -- Function: [Y, E] = discretize (..., ‘'IncludedEdge'’, INCLUDEDEDGE)

     Group data into discrete bins or categories.

     N is the number of bins to group the values into.

     EDGES is an array of edge values defining the bins.

     DUR is a ‘duration’ value indicating the length of time of each
     bin.

     If ‘'categorical'’ is specified, the resulting values are a
     ‘categorical’ array instead of a numeric array of bin indexes.

     Returns: Y - the bin index or category of each value from X E - the
     list of bin edge values


File: tablicious.info,  Node: dispstrs,  Next: duration,  Prev: discretize,  Up: API Alphabetically

10.2.12 dispstrs
----------------

 -- Function: OUT = dispstrs (X)

     Display strings for array.

     Gets the display strings for each element of X.  The display
     strings should be short, one-line, human-presentable strings
     describing the value of that element.

     The default implementation of ‘dispstrs’ can accept input of any
     type, and has decent implementations for Octave’s standard built-in
     types, but will have opaque displays for most user-defined objects.

     This is a polymorphic method that user-defined classes may override
     with their own custom display that is more informative.

     Returns a cell array the same size as X.


File: tablicious.info,  Node: duration,  Next: endsWith,  Prev: dispstrs,  Up: API Alphabetically

10.2.13 duration
----------------

 -- Class: duration

     Represents durations or periods of time as an amount of
     fixed-length time (i.e.  fixed-length seconds).  It does not care
     about calendar things like months and days that vary in length over
     time.

     This is an attempt to reproduce the functionality of Matlab’s
     ‘duration’.  It also contains some Octave-specific extensions.

 -- Instance Variable of duration: ‘double’ days

     The underlying datenums that represent the durations, as number of
     (whole and fractional) days.  These are uniform 24-hour days, not
     calendar days.

     This is a planar property: the size of ‘days’ is the same size as
     the containing ‘duration’ array object.

 -- Instance Variable of duration: ‘char’ Format

     The format to display this ‘duration’ in.  Currently unsupported.

* Menu:

* duration.ofDays::
* duration.sizeof::
* duration.years::
* duration.hours::
* duration.minutes::
* duration.seconds::
* duration.milliseconds::
* duration.dispstrs::
* duration.char::
* duration.linspace::


File: tablicious.info,  Node: duration.ofDays,  Up: duration

10.2.13.1 duration.ofDays
.........................

10.2.13.2 duration.ofDays
.........................

 -- Static Method: OBJ = duration.ofDays (DNUMS)

     Converts a double array representing durations in whole and
     fractional days to a ‘duration’ array.  This is the method that is
     used for implicit conversion of numerics in many cases.

     Returns a ‘duration’ array of the same size as the input.


File: tablicious.info,  Node: duration.sizeof,  Next: duration.years,  Up: duration

10.2.13.3 duration.sizeof
.........................

 -- Method: OUT = sizeof (OBJ)

     Size of array in bytes.


File: tablicious.info,  Node: duration.years,  Prev: duration.sizeof,  Up: duration

10.2.13.4 duration.years
........................

10.2.13.5 duration.years
........................

 -- Method: OUT = years (OBJ)

     Equivalent number of years.

     Gets the number of fixed-length 365.2425-day years that is
     equivalent to this duration.

     Returns double array the same size as OBJ.


File: tablicious.info,  Node: duration.hours,  Up: duration

10.2.13.6 duration.hours
........................

10.2.13.7 duration.hours
........................

 -- Method: OUT = hours (OBJ)

     Equivalent number of hours.

     Gets the number of fixed-length 60-minute hours that is equivalent
     to this duration.

     Returns double array the same size as OBJ.


File: tablicious.info,  Node: duration.minutes,  Up: duration

10.2.13.8 duration.minutes
..........................

10.2.13.9 duration.minutes
..........................

 -- Method: OUT = minutes (OBJ)

     Equivalent number of minutes.

     Gets the number of fixed-length 60-second minutes that is
     equivalent to this duration.

     Returns double array the same size as OBJ.


File: tablicious.info,  Node: duration.seconds,  Up: duration

10.2.13.10 duration.seconds
...........................

10.2.13.11 duration.seconds
...........................

 -- Method: OUT = seconds (OBJ)

     Equivalent number of seconds.

     Gets the number of seconds that is equivalent to this duration.

     Returns double array the same size as OBJ.


File: tablicious.info,  Node: duration.milliseconds,  Up: duration

10.2.13.12 duration.milliseconds
................................

10.2.13.13 duration.milliseconds
................................

 -- Method: OUT = milliseconds (OBJ)

     Equivalent number of milliseconds.

     Gets the number of milliseconds that is equivalent to this
     duration.

     Returns double array the same size as OBJ.


File: tablicious.info,  Node: duration.dispstrs,  Up: duration

10.2.13.14 duration.dispstrs
............................

10.2.13.15 duration.dispstrs
............................

 -- Method: OUT = duration (OBJ)

     Get display strings for each element of OBJ.

     Returns a cellstr the same size as OBJ.


File: tablicious.info,  Node: duration.char,  Up: duration

10.2.13.16 duration.char
........................

10.2.13.17 duration.char
........................

 -- Method: OUT = char (OBJ)

     Convert to char.  The contents of the strings will be the same as
     returned by ‘dispstrs’.

     This is primarily a convenience method for use on scalar OBJs.

     Returns a 2-D char array with one row per element in OBJ.


File: tablicious.info,  Node: duration.linspace,  Up: duration

10.2.13.18 duration.linspace
............................

10.2.13.19 duration.linspace
............................

 -- Method: OUT = linspace (FROM, TO, N)

     Linearly-spaced values in time duration space.

     Constructs a vector of ‘duration’s that represent linearly spaced
     points starting at FROM and going up to TO, with N points in the
     vector.

     FROM and TO are implicitly converted to ‘duration’s.

     N is how many points to use.  If omitted, defaults to 100.

     Returns an N-long ‘datetime’ vector.


File: tablicious.info,  Node: endsWith,  Next: eqn,  Prev: duration,  Up: API Alphabetically

10.2.14 endsWith
----------------

 -- Function: OUT = endsWith (STR, PATTERN)
 -- Function: OUT = endsWith (..., ‘'IgnoreCase'’, IGNORECASE)

     Test if strings end with a pattern.

     Tests whether the given strings end with the given pattern(s).

     STR (char, cellstr, or string) is a list of strings to compare
     against PATTERN.

     PATTERN (char, cellstr, or string) is a list of patterns to match.
     These are literal plain string patterns, not regex patterns.  If
     more than one pattern is supplied, the return value is true if the
     string matched any of them.

     Returns a logical array of the same size as the string array
     represented by STR.


File: tablicious.info,  Node: eqn,  Next: fillmissing,  Prev: endsWith,  Up: API Alphabetically

10.2.15 eqn
-----------

 -- Function: OUT = eqn (A, B)

     Determine element-wise equality, treating NaNs as equal

     out = eqn (A, B)

     ‘eqn’ is just like ‘eq’ (the function that implements the ‘==’
     operator), except that it considers NaN and NaN-like values to be
     equal.  This is the element-wise equivalent of ‘isequaln’.

     ‘eqn’ uses ‘isnannish’ to test for NaN and NaN-like values, which
     means that NaNs and NaTs are considered to be NaN-like, and string
     arrays’ “missing” and categorical objects’ “undefined” values are
     considered equal, because they are NaN-ish.

     Developer’s note: the name “‘eqn’” is a little unfortunate, because
     “eqn” could also be an abbreviation for “equation”.  But this name
     follows the ‘isequaln’ pattern of appending an “n” to the
     corresponding non-NaN-equivocating function.

     See also: ‘eq’, ‘isequaln’, *note isnannish::


File: tablicious.info,  Node: fillmissing,  Next: hours,  Prev: eqn,  Up: API Alphabetically

10.2.16 fillmissing
-------------------

 -- Function: [OUT, TFFILLED] = fillmissing (X, METHOD)
 -- Function: [OUT, TFFILLED] = fillmissing (X, ‘'constant'’, FILL_VAL)
 -- Function: [OUT, TFFILLED] = fillmissing (X, MOVMETHOD, WINDOW)

     Fill missing values.

     Fills missing values in X according to the method specified by
     METHOD.

     This method is only partially implemented.

     METHOD may be: ‘'constant'’ ‘'previous'’ ‘'next'’ ‘'nearest'’
     ‘'linear'’ ‘'spline'’ ‘'pchip'’ MOVMETHOD may be: ‘'movmean'’
     ‘'movmedian'’

     Returns OUT, which is X but with missing values filled in, and
     TFFILLED, a logical array the same size as X which indicates which
     elements were filled.


File: tablicious.info,  Node: hours,  Next: iscategorical,  Prev: fillmissing,  Up: API Alphabetically

10.2.17 hours
-------------

 -- Function File: OUT = hours (X)
     Create a ‘duration’ X hours long, or get the hours in a ‘duration’
     X.

     If input is numeric, returns a ‘duration’ array that is that many
     hours in time.

     If input is a ‘duration’, converts the ‘duration’ to a number of
     hours.

     Returns an array the same size as X.


File: tablicious.info,  Node: iscategorical,  Next: isdatetime,  Prev: hours,  Up: API Alphabetically

10.2.18 iscategorical
---------------------

 -- Function: OUT = iscategorical (X)

     True if input is a ‘categorical’ array, false otherwise.

     Returns a scalar logical.


File: tablicious.info,  Node: isdatetime,  Next: isduration,  Prev: iscategorical,  Up: API Alphabetically

10.2.19 isdatetime
------------------

 -- Function: OUT = isdatetime (X)

     True if input is a ‘datetime’ array, false otherwise.

     Returns a scalar logical.


File: tablicious.info,  Node: isduration,  Next: isfile,  Prev: isdatetime,  Up: API Alphabetically

10.2.20 isduration
------------------

 -- Function: OUT = isduration (X)

     True if input is a ‘duration’ array, false otherwise.

     Returns a scalar logical.


File: tablicious.info,  Node: isfile,  Next: isfolder,  Prev: isduration,  Up: API Alphabetically

10.2.21 isfile
--------------

 -- Function: OUT = isfile (FILE)

     Test whether file exists and is not a folder.

     Tests whether the given file path FILE exists on the filesystem,
     and is not a folder (aka “directory”).  Files of any type except
     for directories are considered files by this function.

     TODO: Handling of symlinks is undetermined as of yet.

     FILE is a charvec containing the path to the file to test.  It may
     be an absolute or relative path.

     This is a new, more specific replacement for ‘exist(file, "file")’.
     Unlike ‘exist’, ‘isfile’ will not search the Octave load path for
     files.

     The underlying logic defers to ‘stat(file)’ for determining file
     existence and attributes, so any paths supported by ‘stat’ are also
     supported by ‘isfile’.  In particular, it seems that the ‘~’ alias
     for the home directory is supported, at least on Unix platforms.

     See also: *note isfolder::, ‘exist’


File: tablicious.info,  Node: isfolder,  Next: ismissing,  Prev: isfile,  Up: API Alphabetically

10.2.22 isfolder
----------------

 -- Function: OUT = isfolder (FILE)

     Test whether file exists and is a folder.

     Tests whether the given file path FILE exists on the filesystem,
     and is a folder (aka “directory”).

     FILE is a charvec containing the path to the file to test.  It may
     be an absolute or relative path.

     This is a new, more specific replacement for ‘exist(file, "dir")’.
     Unlike ‘exist’, ‘isfolder’ will not search the Octave load path for
     files.

     The underlying logic defers to ‘stat(file)’ for determining file
     existence and attributes, so any paths supported by ‘stat’ are also
     supported by ‘isfolder’.  In particular, it seems that the ‘~’
     alias for the home directory is supported, at least on Unix
     platforms.

     See also: *note isfile::, ‘exist’


File: tablicious.info,  Node: ismissing,  Next: isnannish,  Prev: isfolder,  Up: API Alphabetically

10.2.23 ismissing
-----------------

 -- Function: OUT = ismissing (X)
 -- Function: OUT = ismissing (X, INDICATOR)

     Find missing values.

     Determines which elements of X contain missing values.  If an
     indicator input is not provided, standard missing values depending
     on the input type of X are used.

     Standard missing values depend on the data type:
        • NaN for double, single, duration, and calendarDuration
        • NaT for datetime
        • ‘' '’ for char
        • ‘{''}’ for cellstrs
        • Integer numeric types have no standard missing value; they are
          never considered missing.
        • Structs are never considered missing.
        • Logicals are never considered missing.
        • Other types have no standard missing value; it is currently an
          error to call ‘ismissing’ on them without providing an
          indicator.
             − This includes cells which are not cellstrs; calling
               ‘ismissing’ on them results in an error.
             − TODO: Determine whether this should really be an error,
               or if it should default to never considering those types
               as missing.
             − TODO: Decide whether, for classdef objects, ‘ismissing’
               should polymorphically detect isnan()/isnat()/isnannish()
               methods and use those, or whether we should require
               classes to override ismissing() itself.

     If INDICATOR is supplied, it is an array containing multiple
     values, all of which are considered to be missing values.  Only
     indicator values that are type-compatible with the input are
     considered; other indicator value types are silently ignored.  This
     is by design, so you can pass an indicator that holds sentinel
     values for disparate types in to ‘ismissing()’ used for any type,
     or for compound types like table.

     Indicators are currently not supported for struct or logical
     inputs.  This is probably a bug.

     Table defines its own ‘ismissing()’ method which respects
     individual variables’ data types; see *note table.ismissing::.


File: tablicious.info,  Node: isnannish,  Next: isstring,  Prev: ismissing,  Up: API Alphabetically

10.2.24 isnannish
-----------------

 -- Function: OUT = isnannish (X)

     Test if elements are NaN or NaN-like

     Tests if input elements are NaN, NaT, or otherwise NaN-like.  This
     is true if ‘isnan()’ or ‘isnat()’ returns true, and is false for
     types that do not support ‘isnan()’ or ‘isnat()’.

     This function only exists because:

       a. Matlab decided to call their NaN values for datetime “NaT”
          instead, and test for them with a different “isnat()”
          function, and
       b. isnan() errors out for some types that do not support isnan(),
          like cells.

     ‘isnannish()’ smooths over those differences so you can call it
     polymorphically on any input type.

     Under normal operation, ‘isnannish()’ should not throw an error for
     any type or value of input.

     See also: ‘isnan’, ‘isnat’, *note ismissing::, *note eqn::,
     ‘isequaln’


File: tablicious.info,  Node: isstring,  Next: localdate,  Prev: isnannish,  Up: API Alphabetically

10.2.25 isstring
----------------

 -- Function: OUT = isstring (X)

     True if input is a ‘string’ array, false otherwise.

     Returns a scalar logical.


File: tablicious.info,  Node: localdate,  Next: milliseconds,  Prev: isstring,  Up: API Alphabetically

10.2.26 localdate
-----------------

 -- Class: localdate

     Represents a complete day using the Gregorian calendar.

     This class is useful for indexing daily-granularity data or
     representing time periods that cover an entire day in local time
     somewhere.  The major purpose of this class is "type safety", to
     prevent time-of-day values from sneaking in to data sets that
     should be daily only.  As a secondary benefit, this uses less
     memory than datetimes.

 -- Instance Variable of localdate: ‘double’ dnums

     The underlying datenum values that represent the days.  The
     datenums are at the midnight that is at the start of the day it
     represents.

     These are doubles, but they are restricted to be integer-valued, so
     they represent complete days, with no time-of-day component.

 -- Instance Variable of localdate: ‘char’ Format

     The format to display this ‘localdate’ in.  Currently unsupported.

* Menu:

* localdate.localdate::
* localdate.NaT::
* localdate.ymd::
* localdate.dispstrs::
* localdate.datestr::
* localdate.datestrs::
* localdate.datestruct::
* localdate.posixtime::
* localdate.datenum::
* localdate.isnat::
* localdate.isnan::


File: tablicious.info,  Node: localdate.localdate,  Next: localdate.NaT,  Up: localdate

10.2.26.1 localdate.localdate
.............................

 -- Constructor: OBJ = localdate ()

     Constructs a new scalar ‘localdate’ containing the current local
     date.

 -- Constructor: OBJ = localdate (DATENUMS)
 -- Constructor: OBJ = localdate (DATESTRS)
 -- Constructor: OBJ = localdate (Y, M, D)
 -- Constructor: OBJ = localdate (..., ‘'Format'’, FORMAT)

     Constructs a new ‘localdate’ array based on input values.


File: tablicious.info,  Node: localdate.NaT,  Next: localdate.ymd,  Prev: localdate.localdate,  Up: localdate

10.2.26.2 localdate.NaT
.......................

 -- Static Method: OUT = localdate.NaT ()
 -- Static Method: OUT = localdate.NaT (SZ)

     “Not-a-Time”: Creates NaT-valued arrays.

     Constructs a new ‘datetime’ array of all ‘NaT’ values of the given
     size.  If no input SZ is given, the result is a scalar ‘NaT’.

     ‘NaT’ is the ‘datetime’ equivalent of ‘NaN’.  It represents a
     missing or invalid value.  ‘NaT’ values never compare equal to,
     greater than, or less than any value, including other ‘NaT’s.
     Doing arithmetic with a ‘NaT’ and any other value results in a
     ‘NaT’.

     This static method is provided because the global ‘NaT’ function
     creates ‘datetime’s, not ‘localdate’s


File: tablicious.info,  Node: localdate.ymd,  Next: localdate.dispstrs,  Prev: localdate.NaT,  Up: localdate

10.2.26.3 localdate.ymd
.......................

 -- Method: [Y, M, D] = ymd (OBJ)

     Get the Year, Month, and Day components of OBJ.

     Returns double arrays the same size as ‘obj’.


File: tablicious.info,  Node: localdate.dispstrs,  Next: localdate.datestr,  Prev: localdate.ymd,  Up: localdate

10.2.26.4 localdate.dispstrs
............................

 -- Method: OUT = dispstrs (OBJ)

     Get display strings for each element of OBJ.

     Returns a cellstr the same size as OBJ.


File: tablicious.info,  Node: localdate.datestr,  Next: localdate.datestrs,  Prev: localdate.dispstrs,  Up: localdate

10.2.26.5 localdate.datestr
...........................

 -- Method: OUT = datestr (OBJ)
 -- Method: OUT = datestr (OBJ, ...)

     Format OBJ as date strings.  Supports all arguments that core
     Octave’s ‘datestr’ does.

     Returns date strings as a 2-D char array.


File: tablicious.info,  Node: localdate.datestrs,  Next: localdate.datestruct,  Prev: localdate.datestr,  Up: localdate

10.2.26.6 localdate.datestrs
............................

 -- Method: OUT = datestrs (OBJ)
 -- Method: OUT = datestrs (OBJ, ...)

     Format OBJ as date strings, returning cellstr.  Supports all
     arguments that core Octave’s ‘datestr’ does.

     Returns a cellstr array the same size as OBJ.


File: tablicious.info,  Node: localdate.datestruct,  Next: localdate.posixtime,  Prev: localdate.datestrs,  Up: localdate

10.2.26.7 localdate.datestruct
..............................

 -- Method: OUT = datestruct (OBJ)

     Converts this to a “datestruct” broken-down time structure.

     A “datestruct” is a format of struct that Chrono came up with.  It
     is a scalar struct with fields Year, Month, and Day, each
     containing a double array the same size as the date array it
     represents.  This format differs from the “datestruct” used by
     ‘datetime’ in that it lacks Hour, Minute, and Second components.
     This is done for efficiency.

     The values in the returned broken-down time are those of the local
     time in OBJ’s defined time zone, if it has one.

     Returns a struct with fields Year, Month, and Day.  Each field
     contains a double array of the same size as this.


File: tablicious.info,  Node: localdate.posixtime,  Next: localdate.datenum,  Prev: localdate.datestruct,  Up: localdate

10.2.26.8 localdate.posixtime
.............................

 -- Method: OUT = posixtime (OBJ)

     Converts this to POSIX time values for midnight of OBJ’s days.

     Converts this to POSIX time values that represent the same date.
     The returned values will be doubles that will not include
     fractional second values.  The times returned are those of midnight
     UTC on OBJ’s days.

     Returns double array of same size as this.


File: tablicious.info,  Node: localdate.datenum,  Next: localdate.isnat,  Prev: localdate.posixtime,  Up: localdate

10.2.26.9 localdate.datenum
...........................

 -- Method: OUT = datenum (OBJ)

     Convert this to datenums that represent midnight on OBJ’s days.

     Returns double array of same size as this.


File: tablicious.info,  Node: localdate.isnat,  Next: localdate.isnan,  Prev: localdate.datenum,  Up: localdate

10.2.26.10 localdate.isnat
..........................

 -- Method: OUT = isnat (OBJ)

     True if input elements are NaT.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: localdate.isnan,  Prev: localdate.isnat,  Up: localdate

10.2.26.11 localdate.isnan
..........................

 -- Method: OUT = isnan (OBJ)

     True if input elements are NaT. This is an alias for ‘isnat’ to
     support type compatibility and polymorphic programming.

     Returns logical array the same size as OBJ.


File: tablicious.info,  Node: milliseconds,  Next: minutes,  Prev: localdate,  Up: API Alphabetically

10.2.27 milliseconds
--------------------

 -- Function File: OUT = milliseconds (X)
     Create a ‘duration’ X milliseconds long, or get the milliseconds in
     a ‘duration’ X.

     If input is numeric, returns a ‘duration’ array that is that many
     milliseconds in time.

     If input is a ‘duration’, converts the ‘duration’ to a number of
     milliseconds.

     Returns an array the same size as X.


File: tablicious.info,  Node: minutes,  Next: missing,  Prev: milliseconds,  Up: API Alphabetically

10.2.28 minutes
---------------

 -- Function File: OUT = hours (X)
     Create a ‘duration’ X hours long, or get the hours in a ‘duration’
     X.


File: tablicious.info,  Node: missing,  Next: mustBeA,  Prev: minutes,  Up: API Alphabetically

10.2.29 missing
---------------

 -- Class: missing

     Generic auto-converting missing value.

     ‘missing’ is a generic missing value that auto-converts to other
     types.

     A ‘missing’ array indicates a missing value, of no particular type.
     It auto- converts to other types when it is combined with them via
     concatenation or other array combination operations.

     This class is currently EXPERIMENTAL. Use at your own risk.

     Note: This class does not actually work for assignment.  If you do
     this:

            x = 1:5
            x(3) = missing

     It’s supposed to work, but I can’t figure out how to do this in a
     normal classdef object, because there doesn’t seem to be any
     function that’s implicitly called for type conversion in that
     assignment.  Darn it.

* Menu:

* missing.missing::
* missing.dispstrs::
* missing.ismissing::
* missing.isnan::
* missing.isnannish::


File: tablicious.info,  Node: missing.missing,  Next: missing.dispstrs,  Up: missing

10.2.29.1 missing.missing
.........................

 -- Constructor: OBJ = missing ()

     Constructs a scalar ‘missing’ array.

     The constructor takes no arguments, since there’s only one
     ‘missing’ value.


File: tablicious.info,  Node: missing.dispstrs,  Next: missing.ismissing,  Prev: missing.missing,  Up: missing

10.2.29.2 missing.dispstrs
..........................

 -- Method: OUT = dispstrs (OBJ)

     Display strings.

     Gets display strings for each element in OBJ.

     For ‘missing’, the display strings are always ‘'<missing>'’.

     Returns a cellstr the same size as OBJ.


File: tablicious.info,  Node: missing.ismissing,  Next: missing.isnan,  Prev: missing.dispstrs,  Up: missing

10.2.29.3 missing.ismissing
...........................

 -- Method: OUT = ismissing (OBJ)

     Test whether elements are missing values.

     ‘ismissing’ is always true for ‘missing’ arrays.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: missing.isnan,  Next: missing.isnannish,  Prev: missing.ismissing,  Up: missing

10.2.29.4 missing.isnan
.......................

 -- Method: OUT = isnan (OBJ)

     Test whether elements are NaN.

     ‘isnan’ is always true for ‘missing’ arrays.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: missing.isnannish,  Prev: missing.isnan,  Up: missing

10.2.29.5 missing.isnannish
...........................

 -- Method: OUT = isnannish (OBJ)

     Test whether elements are NaN-like.

     ‘isnannish’ is always true for ‘missing’ arrays.

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: mustBeA,  Next: mustBeCellstr,  Prev: missing,  Up: API Alphabetically

10.2.30 mustBeA
---------------

 -- Function File: X = mustBeA (X, TYPE)
 -- Function File: X = mustBeA (X, TYPE, LABEL)

     Requires that input is of a given type.

     Raises an error if the input X is not of type TYPE, as determined
     by ‘isa (x, type)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeCellstr,  Next: mustBeCharvec,  Prev: mustBeA,  Up: API Alphabetically

10.2.31 mustBeCellstr
---------------------

 -- Function File: ‘x’ = mustBeCellstr (X, LABEL)

     Requires that input is a cellstr.

     Raises an error if the input X is not a cellstr (a cell array of
     ‘char’ arrays).

     TODO: Decide whether to require the contained char arrays be
     rowvec/empty.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeCharvec,  Next: mustBeFinite,  Prev: mustBeCellstr,  Up: API Alphabetically

10.2.32 mustBeCharvec
---------------------

 -- Function File: X = mustBeCharvec (X, LABEL)

     Requires that input is a char row vector.

     Raises an error if the input X is not a row vector of ‘char’s.
     ‘char’ row vectors are Octave’s normal representation of single
     strings.  (They are what are produced by ‘'...'’ string literals.)
     As a special case, 0-by-0 empty chars (what is produced by the
     string literal ‘''’) are also considered charvecs.

     This does not differentiate between single-quoted and double-quoted
     strings.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeFinite,  Next: mustBeInteger,  Prev: mustBeCharvec,  Up: API Alphabetically

10.2.33 mustBeFinite
--------------------

 -- Function File: X = mustBeFinite (X, LABEL)

     Requires that input is finite.

     Raises an error if the input X is not finite, as determined by
     ‘isfinite (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeInteger,  Next: mustBeMember,  Prev: mustBeFinite,  Up: API Alphabetically

10.2.34 mustBeInteger
---------------------

 -- Function File: X = mustBeInteger (X, LABEL)

     Requires that input is integer-valued (but not necessarily
     integer-typed).

     Raises an error if any element of the input X is not a finite,
     real, integer-valued numeric value, as determined by various
     checks.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeMember,  Next: mustBeNonempty,  Prev: mustBeInteger,  Up: API Alphabetically

10.2.35 mustBeMember
--------------------

 -- Function File: X = mustBeMember (X, VALID, LABEL)

     Requires that input is a member of a set of given valid values.

     Raises an error if any element of the input X is not a member of
     VALID, as determined by ‘ismember (x)’.

     Note that char inputs may behave weirdly, because of the
     interaction between chars and cellstrs when calling ismember() on
     them.  But it will probably "do what you mean" if you just use it
     naturally.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeNonempty,  Next: mustBeNumeric,  Prev: mustBeMember,  Up: API Alphabetically

10.2.36 mustBeNonempty
----------------------

 -- Function File: X = mustBeNonempty (X, LABEL)

     Requires that input is nonempty.

     Raises an error if the input X is not empty, as determined by ‘!
     isempty (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeNumeric,  Next: mustBeReal,  Prev: mustBeNonempty,  Up: API Alphabetically

10.2.37 mustBeNumeric
---------------------

 -- Function File: X = mustBeNumeric (X, LABEL)

     Requires that input is numeric.

     Raises an error if the input X is not numeric, as determined by
     ‘isnumeric (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeReal,  Next: mustBeSameSize,  Prev: mustBeNumeric,  Up: API Alphabetically

10.2.38 mustBeReal
------------------

 -- Function File: X = mustBeReal (X, LABEL)

     Requires that input is finite.

     Raises an error if the input X is not real, as determined by
     ‘isreal (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeSameSize,  Next: mustBeScalar,  Prev: mustBeReal,  Up: API Alphabetically

10.2.39 mustBeSameSize
----------------------

 -- Function File: [A, B] = mustBeSameSize (A, B, LABELA, LABELB)

     Requires that the inputs are the same size.

     Raises an error if the inputs A and B are not the same size, as
     determined by ‘isequal (size (a), size (b))’.

     LABELA and LABELB are optional inputs that determine how the input
     will be described in error messages.  If not supplied, ‘inputname
     (...)’ is used, and if that is empty, it falls back to "input 1"
     and "input 2".


File: tablicious.info,  Node: mustBeScalar,  Next: mustBeScalarLogical,  Prev: mustBeSameSize,  Up: API Alphabetically

10.2.40 mustBeScalar
--------------------

 -- Function File: X = mustBeScalar (X, LABEL)

     Requires that input is scalar.

     Raises an error if the input X is not scalar, as determined by
     ‘isscalar (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeScalarLogical,  Next: mustBeVector,  Prev: mustBeScalar,  Up: API Alphabetically

10.2.41 mustBeScalarLogical
---------------------------

 -- Function File: X = mustBeScalarLogical (X, LABEL)

     Requires that input is a scalar logical.

     Raises an error if the input X is not scalar, as determined by
     ‘isscalar (x) && islogical (x)’.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: mustBeVector,  Next: NaT,  Prev: mustBeScalarLogical,  Up: API Alphabetically

10.2.42 mustBeVector
--------------------

 -- Function File: X = mustBeVector (X, LABEL)

     Requires that input is a vector or empty.

     Raises an error if the input X is not a row vector and is not
     0-by-0 empty.

     LABEL is an optional input that determines how the input will be
     described in error messages.  If not supplied, ‘inputname (1)’ is
     used, and if that is empty, it falls back to "input".


File: tablicious.info,  Node: NaT,  Next: octave.chrono.dummy_function,  Prev: mustBeVector,  Up: API Alphabetically

10.2.43 NaT
-----------

 -- Function: OUT = NaT ()
 -- Function: OUT = NaT (SZ)

     “Not-a-Time”.  Creates NaT-valued arrays.

     Constructs a new ‘datetime’ array of all ‘NaT’ values of the given
     size.  If no input SZ is given, the result is a scalar ‘NaT’.

     ‘NaT’ is the ‘datetime’ equivalent of ‘NaN’.  It represents a
     missing or invalid value.  ‘NaT’ values never compare equal to,
     greater than, or less than any value, including other ‘NaT’s.
     Doing arithmetic with a ‘NaT’ and any other value results in a
     ‘NaT’.

     ‘NaT’ currently cannot create NaT arrays of type ‘localdate’.  To
     do that, use *note localdate.NaT:: instead.


File: tablicious.info,  Node: octave.chrono.dummy_function,  Next: octave.chrono.DummyClass,  Prev: NaT,  Up: API Alphabetically

10.2.44 octave.chrono.dummy_function
------------------------------------

 -- Function: OUT = dummy_function (X)

     A dummy function just for testing the doco tools.

     Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Curabitur
     ullamcorper pulvinar ligula, sit amet accumsan turpis dapibus at.
     Ut sit amet quam orci.  Donec vel mauris elementum massa pretium
     tincidunt.


File: tablicious.info,  Node: octave.chrono.DummyClass,  Next: octave.dataset,  Prev: octave.chrono.dummy_function,  Up: API Alphabetically

10.2.45 octave.chrono.DummyClass
--------------------------------

 -- Class: DummyClass

     A do-nothing class just for testing the doco tools.

     Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Curabitur
     ullamcorper pulvinar ligula, sit amet accumsan turpis dapibus at.
     Ut sit amet quam orci.  Donec vel mauris elementum massa pretium
     tincidunt.

 -- Instance Variable of DummyClass: ‘double’ x

     An x.  Has no semantics.

 -- Instance Variable of DummyClass: ‘double’ y

     A y.  Has no semantics.

* Menu:

* octave.chrono.DummyClass.DummyClass::
* octave.chrono.DummyClass.foo::
* octave.chrono.DummyClass.bar::


File: tablicious.info,  Node: octave.chrono.DummyClass.DummyClass,  Next: octave.chrono.DummyClass.foo,  Up: octave.chrono.DummyClass

10.2.45.1 octave.chrono.DummyClass.DummyClass
.............................................

 -- Constructor: OBJ = octave.chrono.DummyClass ()

     Constructs a new scalar ‘DummyClass’ with default values.

 -- Constructor: OBJ = octave.chrono.DummyClass (X, Y)

     Constructs a new ‘DummyClass’ with the specified values.


File: tablicious.info,  Node: octave.chrono.DummyClass.foo,  Next: octave.chrono.DummyClass.bar,  Prev: octave.chrono.DummyClass.DummyClass,  Up: octave.chrono.DummyClass

10.2.45.2 octave.chrono.DummyClass.foo
......................................

 -- Method: OUT = foo (OBJ)

     Computes a foo value.

     Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Curabitur
     ullamcorper pulvinar ligula, sit amet accumsan turpis dapibus at.
     Ut sit amet quam orci.  Donec vel mauris elementum massa pretium
     tincidunt.


File: tablicious.info,  Node: octave.chrono.DummyClass.bar,  Prev: octave.chrono.DummyClass.foo,  Up: octave.chrono.DummyClass

10.2.45.3 octave.chrono.DummyClass.bar
......................................

 -- Method: OUT = bar (OBJ)

     Computes a bar value.

     Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Curabitur
     ullamcorper pulvinar ligula, sit amet accumsan turpis dapibus at.
     Ut sit amet quam orci.  Donec vel mauris elementum massa pretium
     tincidunt.


File: tablicious.info,  Node: octave.dataset,  Next: octave.datasets,  Prev: octave.chrono.DummyClass,  Up: API Alphabetically

10.2.46 octave.dataset
----------------------

 -- Class: dataset

     The ‘dataset’ class provides convenient access to the various
     datasets included with Tablicious.

     This class just contains a bunch of static methods, each of which
     loads the dataset of that name.  It’s provided so you can use tab
     completion on the dataset list.

* Menu:

* octave.dataset.AirPassengers::
* octave.dataset.ChickWeight::
* octave.dataset.airmiles::
* octave.dataset.airquality::
* octave.dataset.anscombe::
* octave.dataset.attenu::
* octave.dataset.attitude::
* octave.dataset.austres::
* octave.dataset.beavers::
* octave.dataset.cupcake::
* octave.dataset.iris::
* octave.dataset.mtcars::


File: tablicious.info,  Node: octave.dataset.AirPassengers,  Next: octave.dataset.ChickWeight,  Up: octave.dataset

10.2.46.1 octave.dataset.AirPassengers
......................................

 -- Static Method: OUT = AirPassengers ()

     Monthly Airline Passenger Numbers 1949-1960

     Description
     ...........

     The classic Box & Jenkins airline data.  Monthly totals of
     international airline passengers, 1949 to 1960.

     Source
     ......

     Box, G. E. P., Jenkins, G. M. and Reinsel, G. C. (1976) ‘Time
     Series Analysis, Forecasting and Control’.  Third Edition.
     Holden-Day.  Series G.

     Examples
     ........

          ## TODO: This example needs to be ported from R.


File: tablicious.info,  Node: octave.dataset.ChickWeight,  Next: octave.dataset.airmiles,  Prev: octave.dataset.AirPassengers,  Up: octave.dataset

10.2.46.2 octave.dataset.ChickWeight
....................................

 -- Static Method: OUT = ChickWeight ()

     Weight versus age of chicks on different diets

     Format
     ......

     ‘weight’
          a numeric vector giving the body weight of the chick (gm).
     ‘Time’
          a numeric vector giving the number of days since birth when
          the measurement was made.
     ‘Chick’
          an ordered factor with levels 18 < ...  < 48 giving a unique
          identifier for the chick.  The ordering of the levels groups
          chicks on the same diet together and orders them according to
          their final weight (lightest to heaviest) within diet.
     ‘Diet’
          a factor with levels 1, ..., 4 indicating which experimental
          diet the chick received.

     Source
     ......

     Crowder, M. and Hand, D. (1990), ‘Analysis of Repeated Measures’.
     Chapman and Hall (example 5.3)

     Hand, D. and Crowder, M. (1996), ‘Practical Longitudinal Data
     Analysis’.  Chapman and Hall (table A.2)

     Pinheiro, J. C. and Bates, D. M. (2000) ‘Mixed-effects Models in S
     and S-PLUS’. Springer.

     Examples
     ........

          # TODO: This example needs to be ported from R.


File: tablicious.info,  Node: octave.dataset.airmiles,  Next: octave.dataset.airquality,  Prev: octave.dataset.ChickWeight,  Up: octave.dataset

10.2.46.3 octave.dataset.airmiles
.................................

 -- Static Method: OUT = airmiles ()

     Passenger Miles on Commercial US Airlines, 1937-1960

     Description
     ...........

     The revenue passenger miles flown by commercial airlines in the
     United States for each year from 1937 to 1960.

     Source
     ......

     ‘F.A.A. Statistical Handbook of Aviation’.

     Examples
     ........

          t = octave.dataset.airmiles;
          plot (t.year, t.miles);
          title ("airmiles data");
          xlabel ("Passenger-miles flown by U.S. commercial airlines")
          ylabel ("airmiles");


File: tablicious.info,  Node: octave.dataset.airquality,  Next: octave.dataset.anscombe,  Prev: octave.dataset.airmiles,  Up: octave.dataset

10.2.46.4 octave.dataset.airquality
...................................

 -- Static Method: OUT = airquality ()

     New York Air Quality Measurements from 1973

     Description
     ...........

     Daily air quality measurements in New York, May to September 1973.

     Format
     ......

     ‘Ozone’
          Ozone concentration (ppb)
     ‘SolarR’
          Solar R (lang)
     ‘Wind’
          Wind (mph)
     ‘Temp’
          Temperature (degrees F)
     ‘Month’
          Month (1-12)
     ‘Day’
          Day of month (1-31)

     Source
     ......

     New York State Department of Conservation (ozone data) and the
     National Weather Service (meteorological data).

     References
     ..........

     Chambers, J. M., Cleveland, W. S., Kleiner, B. and Tukey, P. A.
     (1983) ‘Graphical Methods for Data Analysis’.  Belmont, CA:
     Wadsworth.

     Examples
     ........

          t = octave.dataset.airquality
          # Plot a scatter-plot plus a fitted line, for each combination of measurements
          vars = {"Ozone", "SolarR", "Wind", "Temp" "Month", "Day"};
          n_vars = numel (vars);
          figure;
          for i = 1:n_vars
            for j = 1:n_vars
              if i == j
                continue
              endif
              ix_subplot = (n_vars*(j - 1) + i);
              hax = subplot (n_vars, n_vars, ix_subplot);
              var_x = vars{i};
              var_y = vars{j};
              x = t.(var_x);
              y = t.(var_y);
              scatter (hax, x, y, 10);
              # Fit a cubic line to these points
              # TODO: Find out exactly what kind of fitted line R's example is using, and
              # port that.
              hold on
              p = polyfit (x, y, 3);
              x_hat = unique(x);
              p_y = polyval (p, x_hat);
              plot (hax, x_hat, p_y, "r");
            endfor
          endfor



File: tablicious.info,  Node: octave.dataset.anscombe,  Next: octave.dataset.attenu,  Prev: octave.dataset.airquality,  Up: octave.dataset

10.2.46.5 octave.dataset.anscombe
.................................

 -- Static Method: OUT = anscombe ()

     Anscombe’s Quartet of “Identical” Simple Linear Regressions

     Description
     ...........

     Four sets of x/y pairs which have the same statistical properties,
     but are very different.

     Format
     ......

     The data comes in an array of 4 structs, each with fields as
     follows:

     ‘x’
          The X values for this pair.
     ‘y’
          The Y values for this pair.

     Source
     ......

     Tufte, Edward R. (1989).  ‘The Visual Display of Quantitative
     Information’.  13–14.  Graphics Press.

     References
     ..........

     Anscombe, Francis J. (1973).  “Graphs in statistical analysis”.
     ‘The American Statistician’, 27, 17–21.

     Examples
     ........

          data = octave.dataset.anscombe

          # Pick good limits for the plots
          all_x = [data.x];
          all_y = [data.y];
          x_limits = [min(0, min(all_x)) max(all_x)*1.2];
          y_limits = [min(0, min(all_y)) max(all_y)*1.2];

          # Do regression on each pair and plot the input and results
          figure;
          haxs = NaN (1, 4);
          for i_pair = 1:4
            x = data(i_pair).x;
            y = data(i_pair).y;
            # TODO: Port the anova and other characterizations from the R code
            # TODO: Do a linear regression and plot its line
            hax = subplot (2, 2, i_pair);
            haxs(i_pair) = hax;
            xlabel (sprintf ("x%d", i_pair));
            ylabel (sprintf ("y%d", i_pair));
            scatter (x, y, "r");
          endfor

          # Fiddle with the plot axes parameters
          linkaxes (haxs);
          xlim(haxs(1), x_limits);
          ylim(haxs(1), y_limits);


File: tablicious.info,  Node: octave.dataset.attenu,  Next: octave.dataset.attitude,  Prev: octave.dataset.anscombe,  Up: octave.dataset

10.2.46.6 octave.dataset.attenu
...............................

 -- Static Method: OUT = attenu ()

     Joyner-Boore Earthquake Attenuation Data

     Description
     ...........

     Event data for 23 earthquakes in California, showing peak
     accelerations.

     Format
     ......

     ‘event’
          Event number
     ‘mag’
          Moment magnitude
     ‘station’
          Station identifier
     ‘dist’
          Station-hypocenter distance (km)
     ‘accel’
          Peak acceleration (g)

     Source
     ......

     Joyner, W.B., D.M. Boore and R.D. Porcella (1981).  Peak horizontal
     acceleration and velocity from strong-motion records including
     records from the 1979 Imperial Valley, California earthquake.  USGS
     Open File report 81-365.  Menlo Park, Ca.

     References
     ..........

     Boore, D. M. and Joyner, W. B.(1982).  The empirical prediction of
     ground motion, ‘Bulletin of the Seismological Society of America’,
     72, S269–S268.

     Examples
     ........

          # TODO: Port the example code from R
          # It does coplot() and pairs(), which are higher-level plotting tools
          # than core Octave provides. This could turn into a long example if we
          # just use base Octave here.


File: tablicious.info,  Node: octave.dataset.attitude,  Next: octave.dataset.austres,  Prev: octave.dataset.attenu,  Up: octave.dataset

10.2.46.7 octave.dataset.attitude
.................................

 -- Static Method: OUT = attitude ()

     The Chatterjee-Price Attitude Data

     Description
     ...........

     Aggregated data from a survey of clerical employees at a large
     financial organization.

     Format
     ......

     ‘rating’
          Overall rating.
     ‘complaints’
          Handling of employee complaints.
     ‘privileges’
          Does not allow special privileges.
     ‘learning’
          Opportunity to learn.
     ‘raises’
          Raises based on performance.
     ‘critical’
          Too critical.
     ‘advance’
          Advancement.

     Source
     ......

     Chatterjee, S. and Price, B. (1977) ‘Regression Analysis by
     Example’.  New York: Wiley.  (Section 3.7, p.68ff of 2nd
     ed.(1991).)

     Examples
     ........

          t = octave.dataset.attitude

          octave.examples.plot_pairs (t);

          # TODO: Display table summary

          # TODO: Whatever those statistical linear-model plots are that R is doing




File: tablicious.info,  Node: octave.dataset.austres,  Next: octave.dataset.beavers,  Prev: octave.dataset.attitude,  Up: octave.dataset

10.2.46.8 octave.dataset.austres
................................

 -- Static Method: OUT = austres ()

     Australian Population

     Description
     ...........

     Numbers of Australian residents measured quarterly from March 1971
     to March 1994.

     Format
     ......

     ‘date’
          The month of the observation.
     ‘residents’
          The number of residents.

     Source
     ......

     P. J. Brockwell and R. A. Davis (1996) ‘Introduction to Time Series
     and Forecasting’.  Springer

     Examples
     ........

          t = octave.dataset.austres

          plot (datenum (t.date), t.residents);
          datetick x
          xlabel ("Month"); ylabel ("Residents"); title ("Australian Residents");


File: tablicious.info,  Node: octave.dataset.beavers,  Next: octave.dataset.cupcake,  Prev: octave.dataset.austres,  Up: octave.dataset

10.2.46.9 octave.dataset.beavers
................................

 -- Static Method: OUT = beavers ()

     Body Temperature Series of Two Beavers

     Description
     ...........

     Body temperature readings for two beavers.

     Format
     ......

     ‘day’
          Day of observation (in days since the beginning of 1990),
          December 12–13 (beaver1) and November 3–4 (beaver2).
     ‘time’
          Time of observation, in the form 0330 for 3:30am
     ‘temp’
          Measured body temperature in degrees Celsius.
     ‘activ’
          Indicator of activity outside the retreat.

     Source
     ......

     P. S. Reynolds (1994) Time-series analyses of beaver body
     temperatures.  Chapter 11 of Lange, N., Ryan, L., Billard, L.,
     Brillinger, D., Conquest, L. and Greenhouse, J. eds (1994) ‘Case
     Studies in Biometry’.  New York: John Wiley and Sons.

     Examples
     ........

          # TODO: This example needs to be ported from R.


File: tablicious.info,  Node: octave.dataset.cupcake,  Next: octave.dataset.iris,  Prev: octave.dataset.beavers,  Up: octave.dataset

10.2.46.10 octave.dataset.cupcake
.................................

 -- Static Method: OUT = cupcake ()

     Google Search popularity for "cupcake", 2004-2019

     Description
     ...........

     Monthly popularity of worldwide Google search results for
     "cupcake", 2004-2019.

     Format
     ......

     ‘Month’
          Month when searches took place
     ‘Cupcake’
          An indicator of search volume, in unknown units

     Source
     ......

     Google Trends,
     <https://trends.google.com/trends/explore?q=%2Fm%2F03p1r4&date=all>,
     retrieved 2019-05-04 by Andrew Janke.

     Examples
     ........

          t = octave.dataset.cupcake
          plot(datenum(t.Month), t.Cupcake)
          title ('“Cupcake” Google Searches'); xlabel ("Year"); ylabel ("Unknown popularity metric")



File: tablicious.info,  Node: octave.dataset.iris,  Next: octave.dataset.mtcars,  Prev: octave.dataset.cupcake,  Up: octave.dataset

10.2.46.11 octave.dataset.iris
..............................

 -- Static Method: OUT = iris ()

     The Fisher Iris dataset: measurements of various flowers

     Description
     ...........

     This is the classic Fisher Iris dataset.

     Format
     ......

     ‘Species’
          The species of flower being measured.
     ‘SepalLength’
          Length of sepals, in centimeters.
     ‘SepalWidth’
          Width of sepals, in centimeters.
     ‘PetalLength’
          Length of petals, in centimeters.
     ‘PetalWidth’
          Width of petals, in centimeters.

     Source
     ......

     <http://archive.ics.uci.edu/ml/datasets/Iris>

     References
     ..........

     <https://en.wikipedia.org/wiki/Iris_flower_data_set>

     Fisher, R.A. “The use of multiple measurements in taxonomic
     problems” Annals of Eugenics, 7, Part II, 179-188 (1936); also in
     ‘Contributions to Mathematical Statistics’ (John Wiley, NY, 1950).

     Duda, R.O., & Hart, P.E. (1973) ‘Pattern Classification and Scene
     Analysis’.  (Q327.D83) John Wiley & Sons.  ISBN 0-471-22361-1.  See
     page 218.

     The data were collected by Anderson, Edgar (1935).  The irises of
     the Gaspe Peninsula, ‘Bulletin of the American Iris Society’, 59,
     2–5.

     Examples
     ........

          # TODO: Port this example from R


File: tablicious.info,  Node: octave.dataset.mtcars,  Prev: octave.dataset.iris,  Up: octave.dataset

10.2.46.12 octave.dataset.mtcars
................................

 -- Static Method: OUT = mtcars ()

     Motor Trend 1974 Car Road Tests

     Description
     ...........

     The data was extracted from the 1974 Motor Trend US magazine, and
     comprises fuel consumption and 10 aspects of automobile design and
     performance for 32 automobiles (1973–74 models).

     Format
     ......

     ‘mpg’
          Fuel efficiency in miles/gallon
     ‘cyl’
          Number of cylinders
     ‘disp’
          Displacement (cu.  in.)
     ‘hp’
          Gross horsepower
     ‘drat’
          Rear axle ratio
     ‘wt’
          Weight (1,000 lbs)
     ‘qsec’
          1/4 mile time
     ‘vs’
          Engine type (0 = V-shaped, 1 = straight)
     ‘am’
          Transmission type (0 = automatic, 1 = manual)
     ‘gear’
          Number of forward gears
     ‘carb’
          Number of carburetors

     Note
     ....

     Henderson and Velleman (1981) comment in a footnote to Table 1:
     “Hocking [original transcriber]’s noncrucial coding of the Mazda’s
     rotary engine as a straight six-cylinder engine and the Porsche’s
     flat engine as a V engine, as well as the inclusion of the diesel
     Mercedes 240D, have been retained to enable direct comparisons to
     be made with previous analyses.”

     Source
     ......

     Henderson and Velleman (1981), “Building multiple regression models
     interactively”.  Biometrics, 37, 391–411.

     Examples
     ........

          # TODO: Port this example from R


File: tablicious.info,  Node: octave.datasets,  Next: octave.examples.plot_pairs,  Prev: octave.dataset,  Up: API Alphabetically

10.2.47 octave.datasets
-----------------------

 -- Class: datasets

     Example dataset collection.

     ‘datasets’ is a collection of example datasets to go with the
     Tablicious package.

     The ‘datasets’ class provides methods for listing and loading the
     example datasets.

* Menu:

* octave.datasets.list::
* octave.datasets.load::
* octave.datasets.description::


File: tablicious.info,  Node: octave.datasets.list,  Next: octave.datasets.load,  Up: octave.datasets

10.2.47.1 octave.datasets.list
..............................

 -- Static Method: list ()
 -- Static Method: OUT = list ()

     List all datasets.

     Lists all the example datasets known to this class.  If the output
     is captured, returns the list as a table.  If the output is not
     captured, displays the list.

     Returns a table with variables Name, Description, and possibly
     more.


File: tablicious.info,  Node: octave.datasets.load,  Next: octave.datasets.description,  Prev: octave.datasets.list,  Up: octave.datasets

10.2.47.2 octave.datasets.load
..............................

 -- Static Method: load (DATASETNAME)
 -- Static Method: OUT = load (DATASETNAME)

     Load a specified dataset.

     DATASETNAME is the name of the dataset to load, as found in the
     ‘Name’ column of the dataset list.


File: tablicious.info,  Node: octave.datasets.description,  Prev: octave.datasets.load,  Up: octave.datasets

10.2.47.3 octave.datasets.description
.....................................

 -- Static Method: description (DATASETNAME)
 -- Static Method: OUT = description (DATASETNAME)

     Get or display the description for a dataset.

     Gets the description for the named dataset.  If the output is
     captured, it is returned as a charvec containing plain text
     suitable for human display.  If the output is not captured,
     displays the description to the console.


File: tablicious.info,  Node: octave.examples.plot_pairs,  Next: pp,  Prev: octave.datasets,  Up: API Alphabetically

10.2.48 octave.examples.plot_pairs
----------------------------------

 -- Function: OUT = plot_pairs (DATA)
 -- Function: OUT = plot_pairs (DATA, PLOT_TYPE)
 -- Function: OUT = plot_pairs (FIG, ...)

     Plot pairs of variables against each other.

     DATA is the data holding the variables to plot.  It may be either a
     ‘table’ or a struct.  Each variable or field in the ‘table’ or
     struct is considered to be one variable.  Each must hold a vector,
     and all the vectors of all the variables must be the same size.

     PLOT_TYPE is a charvec indicating what plot type to do in each
     subplot.  (‘"scatter"’ is the default.)  Valid PLOT_TYPE values
     are:

     ‘"scatter"’
          A plain scatter plot.
     ‘"smooth"’
          A scatter plot + fitted line, like R’s ‘panel.smooth’ does.

     FIG is an optional figure handle to plot into.  If omitted, a new
     figure is created.

     Returns the created figure, if the output is captured.


File: tablicious.info,  Node: pp,  Next: rmmissing,  Prev: octave.examples.plot_pairs,  Up: API Alphabetically

10.2.49 pp
----------

 -- Function: pp (X)
 -- Function: pp (A, B, C, ...)
 -- Function: pp (‘'A'’, ‘'B'’, ‘'C'’, ...)
 -- Function: pp ‘A’ ‘B’ ‘C’ ...

     Alias for prettyprint, for interactive use.

     This is an alias for prettyprint(), with additional name-conversion
     magic.

     If you pass in a char, instead of pretty-printing that directly, it
     will grab and pretty-print the variable of that name from the
     caller’s workspace.  This is so you can conveniently run it from
     the command line.


File: tablicious.info,  Node: rmmissing,  Next: scalarexpand,  Prev: pp,  Up: API Alphabetically

10.2.50 rmmissing
-----------------

 -- Function: [OUT, TF] = rmmissing (X)
 -- Function: [OUT, TF] = rmmissing (X, DIM)
 -- Function: [OUT, TF] = rmmissing (..., ‘'MinNumMissing'’,
          MINNUMMISSING)

     Remove missing values.

     If X is a vector, removes elements with missing values.  If X is a
     matrix, removes rows or columns with missing data elements.

     DIM is the dimension to operate along.  Specifying a dimension
     forces ‘rmmissing’ to operate in matrix instead of vector mode.

     MINNUMMISSING indicates how many missing element values there must
     be in a row or column for it to be considered missing and this
     removed.  This option is only used in matrix mode; it is silently
     ignored in vector mode.

     Returns: OUT - the input, with missing elements or rows or columns
     removed TF - a logical index vector indicating which elements,
     rows, or columns were removed


File: tablicious.info,  Node: scalarexpand,  Next: seconds,  Prev: rmmissing,  Up: API Alphabetically

10.2.51 scalarexpand
--------------------

 -- Function: [OUT1, OUT2, ..., OUTN] = scalarexpand (X1, X2, ..., XN)

     Expand scalar inputs to match size of non-scalar inputs.

     Expands each scalar input argument to match the size of the
     non-scalar input arguments, and returns the expanded values in the
     corresponding output arguments.  ‘repmat’ is used to do the
     expansion.

     Works on any input types that support ‘size’, ‘isscalar’, and
     ‘repmat’.

     It is an error if any of the non-scalar inputs are not the same
     size as all of the other non-scalar inputs.

     Returns as many output arguments as there were input arguments.

     Examples:

          x1 = rand(3);
          x2 = 42;
          x3 = magic(3);
          [x1, x2, x3] = scalarexpand (x1, x2, x3)


File: tablicious.info,  Node: seconds,  Next: size2str,  Prev: scalarexpand,  Up: API Alphabetically

10.2.52 seconds
---------------

 -- Function File: OUT = seconds (X)
     Create a ‘duration’ X seconds long, or get the seconds in a
     ‘duration’ X.

     If input is numeric, returns a ‘duration’ array that is that many
     seconds in time.

     If input is a ‘duration’, converts the ‘duration’ to a number of
     seconds.

     Returns an array the same size as X.


File: tablicious.info,  Node: size2str,  Next: splitapply,  Prev: seconds,  Up: API Alphabetically

10.2.53 size2str
----------------

 -- Function: OUT = size2str (SZ)

     Format an array size for display.

     Formats the given array size SZ as a string for human-readable
     display.  It will be in the format “d1-by-d2-...-by-dN”, for the N
     dimensions represented by SZ.

     SZ is an array of dimension sizes, in the format returned by the
     ‘size’ function.

     Returns a charvec.

     Examples:
          str = size2str (size (magic (4)))


File: tablicious.info,  Node: splitapply,  Next: standardizeMissing,  Prev: size2str,  Up: API Alphabetically

10.2.54 splitapply
------------------

 -- Function: OUT = splitapply (FUNC, X, G)
 -- Function: OUT = splitapply (FUNC, X1, ..., XN, G)
 -- Function: [Y1, ..., YM] = splitapply (...)

     Split data into groups and apply function.

     FUNC is a function handle to call on each group of inputs in turn.

     X, X1, ..., XN are the input variables that are split into groups
     for the function calls.  If X is a ‘table’, then its contained
     variables are “popped out” and considered to be the X1 ... XN input
     variables.

     G is the grouping variable vector.  It contains a list of integers
     that identify which group each element of the X input variables
     belongs to.  NaNs in G mean that element is ignored.

     Vertically concatenates the function outputs for each of the groups
     and returns them in as many variables as you capture.

     Returns the concatenated outputs of applying FUNC to each group.

     See also: *note table.groupby::, *note table.splitapply::


File: tablicious.info,  Node: standardizeMissing,  Next: startsWith,  Prev: splitapply,  Up: API Alphabetically

10.2.55 standardizeMissing
--------------------------

 -- Function: OUT = standardizeMissing (X, INDICATOR)

     Insert standard missing values.

     Standardizes missing values in X by replacing the values listed in
     INDICATOR with the standard missing values for the type of X.

     Standard missing values depend on the data type: * NaN for double,
     single, duration, and calendarDuration * NaT for datetime * ‘' '’
     for char * ‘{''}’ for cellstrs * Integer numeric types have no
     standard missing value; they are never considered missing.  *
     Structs are never considered missing.  * Logicals are never
     considered missing.

     See also: *note table.standardizeMissing::


File: tablicious.info,  Node: startsWith,  Next: string,  Prev: standardizeMissing,  Up: API Alphabetically

10.2.56 startsWith
------------------

 -- Function: OUT = startsWith (STR, PATTERN)
 -- Function: OUT = startsWith (..., ‘'IgnoreCase'’, IGNORECASE)

     Test if strings start with a pattern.

     Tests whether the given strings start with the given pattern(s).

     STR (char, cellstr, or string) is a list of strings to compare
     against PATTERN.

     PATTERN (char, cellstr, or string) is a list of patterns to match.
     These are literal plain string patterns, not regex patterns.  If
     more than one pattern is supplied, the return value is true if the
     string matched any of them.

     Returns a logical array of the same size as the string array
     represented by STR.


File: tablicious.info,  Node: string,  Next: struct2table,  Prev: startsWith,  Up: API Alphabetically

10.2.57 string
--------------

 -- Class: string

     A string array of Unicode strings.

     A string array is an array of strings, where each array element is
     a single string.

     The string class represents strings, where: - Each element of a
     string array is a single string - A single string is a
     1-dimensional row vector of Unicode characters - Those characters
     are encoded in UTF-8

     This should correspond pretty well to what people think of as
     strings, and is pretty compatible with people’s typical notion of
     strings in Octave.

     String arrays also have a special “missing” value, that is like the
     string equivalent of NaN for doubles or “undefined” for
     categoricals, or SQL NULL.

     This is a slightly higher-level and more strongly-typed way of
     representing strings than cellstrs are.  (A cellstr array is of
     type cell, not a text- specific type, and allows assignment of
     non-string data into it.)

     Be aware that while string arrays interconvert with Octave chars
     and cellstrs, Octave char elements represent 8-bit UTF-8 code
     units, not Unicode code points.

     This class really serves three roles.  - It is an object wrapper
     around Octave’s base primitive character types.  - It adds
     ismissing() semantics.  - And it introduces Unicode support.  Not
     clear whether it’s a good fit to have the Unicode support wrapped
     up in this.  Maybe it should just be a simple object wrapper
     wrapper, and defer Unicode semantics to when core Octave adopts
     them for char and cellstr.  On the other hand, because Octave chars
     are UTF-8, not UCS-2, some methods like strlength() and reverse()
     are just going to be wrong if they delegate straight to chars.

     “Missing” string values work like NaNs.  They are never considered
     equal, less than, or greater to any other string, including other
     missing strings.  This applies to set membership and other
     equivalence tests.

     The current implementation depends on Java for its Unicode and
     encoding support.  This means your Octave session must be running
     Java to call those methods.  This should be changed in the future
     to use a native C/C++ library and avoid the Java dependency,
     especially before this class is merged into core Octave.

     TODO: Need to decide how far to go with Unicode semantics, and how
     much to just make this an object wrapper over cellstr and defer to
     Octave’s existing char/string-handling functions.

     TODO: demote_strings should probably be static or global, so that
     other functions can use it to hack themselves into being
     string-aware.

* Menu:

* string.string::
* string.isstring::
* string.dispstrs::
* string.sizeof::
* string.ismissing::
* string.isnannish::
* string.cellstr::
* string.cell::
* string.char::
* string.encode::
* string.strlength_bytes::
* string.strlength::
* string.reverse_bytes::
* string.reverse::
* string.strcat::
* string.lower::
* string.upper::
* string.erase::
* string.strrep::
* string.strfind::
* string.regexprep::
* string.strcmp::
* string.cmp::
* string.missing::
* string.decode::


File: tablicious.info,  Node: string.string,  Next: string.isstring,  Up: string

10.2.57.1 string.string
.......................

 -- Constructor: OBJ = string ()
 -- Constructor: OBJ = string (IN)

     Construct a new string array.

     The zero-argument constructor creates a new scalar string array
     whose value is the empty string.  TODO: Determine if this should
     actually return a “missing” string instead.

     The other constructors construct a new string array by converting
     various types of inputs.  - chars and cellstrs are converted via
     cellstr() - numerics are converted via num2str() - datetimes are
     converted via datestr()


File: tablicious.info,  Node: string.isstring,  Next: string.dispstrs,  Prev: string.string,  Up: string

10.2.57.2 string.isstring
.........................

 -- Method: OUT = isstring (OBJ)

     Test if input is a string array.

     ‘isstring’ is always true for ‘string’ inputs.

     Returns a scalar logical.


File: tablicious.info,  Node: string.dispstrs,  Next: string.sizeof,  Prev: string.isstring,  Up: string

10.2.57.3 string.dispstrs
.........................

 -- Method: OUT = dispstrs (OBJ)

     Display strings for array elements.

     Gets display strings for all the elements in OBJ.  These display
     strings will either be the string contents of the element, enclosed
     in ‘"..."’, and with CR/LF characters replaced with ‘'\r'’ and
     ‘'\n'’ escape sequences, or ‘"<missing>"’ for missing values.

     Returns a cellstr of the same size as OBJ.


File: tablicious.info,  Node: string.sizeof,  Next: string.ismissing,  Prev: string.dispstrs,  Up: string

10.2.57.4 string.sizeof
.......................

 -- Method: OUT = sizeof (OBJ)

     Size of array in bytes.


File: tablicious.info,  Node: string.ismissing,  Next: string.isnannish,  Prev: string.sizeof,  Up: string

10.2.57.5 string.ismissing
..........................

 -- Method: OUT = ismissing (OBJ)

     Test whether array elements are missing.

     For ‘string’ arrays, only the special “missing” value is considered
     missing.  Empty strings are not considered missing, the way they
     are with cellstrs.

     Returns a logical array the same size as ‘obj’.


File: tablicious.info,  Node: string.isnannish,  Next: string.cellstr,  Prev: string.ismissing,  Up: string

10.2.57.6 string.isnannish
..........................

 -- Method: OUT = isnannish (OBJ)

     Test whether array elements are NaN-like.

     Missing values are considered nannish; any other string value is
     not.

     Returns a logical array of the same size as OBJ.


File: tablicious.info,  Node: string.cellstr,  Next: string.cell,  Prev: string.isnannish,  Up: string

10.2.57.7 string.cellstr
........................

 -- Method: OUT = cellstr (OBJ)

     Convert to cellstr.

     Converts OBJ to a cellstr.  Missing values are converted to ‘''’.

     Returns a cellstr array of the same size as OBJ.


File: tablicious.info,  Node: string.cell,  Next: string.char,  Prev: string.cellstr,  Up: string

10.2.57.8 string.cell
.....................

 -- Method: OUT = cell (OBJ)

     Convert to cell array.

     Converts this to a cell, which will be a cellstr.  Missing values
     are converted to ‘''’.

     This method returns the same values as ‘cellstr(obj)’; it is just
     provided for interface compatibility purposes.

     Returns a cell array of the same size as OBJ.


File: tablicious.info,  Node: string.char,  Next: string.encode,  Prev: string.cell,  Up: string

10.2.57.9 string.char
.....................

 -- Method: OUT = char (OBJ)

     Convert to char array.

     Converts OBJ to a 2-D char array.  It will have as many rows as OBJ
     has elements.

     It is an error to convert missing-valued ‘string’ arrays to char.
     (NOTE: This may change in the future; it may be more appropriate)
     to convert them to space-padded empty strings.)

     Returns 2-D char array.


File: tablicious.info,  Node: string.encode,  Next: string.strlength_bytes,  Prev: string.char,  Up: string

10.2.57.10 string.encode
........................

 -- Method: OUT = encode (OBJ, CHARSETNAME)

     Encode string in a given character encoding.

     OBJ must be scalar.

     CHARSETNAME (charvec) is the name of a character encoding.  (TODO:
     Document what determines the set of valid encoding names.)

     Returns the encoded string as a ‘uint8’ vector.

     See also: *note string.decode::.


File: tablicious.info,  Node: string.strlength_bytes,  Next: string.strlength,  Prev: string.encode,  Up: string

10.2.57.11 string.strlength_bytes
.................................

 -- Method: OUT = strlength_bytes (OBJ)

     String length in bytes.

     Gets the length of each string in OBJ, counted in Unicode UTF-8
     code units (bytes).  This is the same as ‘numel(str)’ for the
     corresponding Octave char vector for each string, but may not be
     what you actually want to use.  You may want ‘strlength’ instead.

     Returns double array of the same size as OBJ.  Returns NaNs for
     missing strings.

     See also: *note string.strlength::


File: tablicious.info,  Node: string.strlength,  Next: string.reverse_bytes,  Prev: string.strlength_bytes,  Up: string

10.2.57.12 string.strlength
...........................

 -- Method: OUT = strlength (OBJ)

     String length in characters.

     Gets the length of each string, counted in Unicode characters (code
     points).  This is the string length method you probably want to
     use, not ‘strlength_bytes’.

     Returns double array of the same size as OBJ.  Returns NaNs for
     missing strings.

     See also: *note string.strlength_bytes::


File: tablicious.info,  Node: string.reverse_bytes,  Next: string.reverse,  Prev: string.strlength,  Up: string

10.2.57.13 string.reverse_bytes
...............................

 -- Method: OUT = reverse_bytes (OBJ)

     Reverse string, byte-wise.

     Reverses the bytes in each string in OBJ.  This operates on bytes
     (Unicode code units), not characters.

     This may well produce invalid strings as a result, because
     reversing a UTF-8 byte sequence does not necessarily produce
     another valid UTF-8 byte sequence.

     You probably do not want to use this method.  You probably want to
     use ‘string.reverse’ instead.

     Returns a string array the same size as OBJ.

     See also: *note string.reverse::


File: tablicious.info,  Node: string.reverse,  Next: string.strcat,  Prev: string.reverse_bytes,  Up: string

10.2.57.14 string.reverse
.........................

 -- Method: OUT = reverse (OBJ)

     Reverse string, character-wise.

     Reverses the characters in each string in OBJ.  This operates on
     Unicode characters (code points), not on bytes, so it is guaranteed
     to produce valid UTF-8 as its output.

     Returns a string array the same size as OBJ.


File: tablicious.info,  Node: string.strcat,  Next: string.lower,  Prev: string.reverse,  Up: string

10.2.57.15 string.strcat
........................

 -- Method: OUT = strcat (VARARGIN)

     String concatenation.

     Concatenates the corresponding elements of all the input arrays,
     string-wise.  Inputs that are not string arrays are converted to
     string arrays.

     The semantics of concatenating missing strings with non-missing
     strings has not been determined yet.

     Returns a string array the same size as the scalar expansion of its
     inputs.


File: tablicious.info,  Node: string.lower,  Next: string.upper,  Prev: string.strcat,  Up: string

10.2.57.16 string.lower
.......................

 -- Method: OUT = lower (OBJ)

     Convert to lower case.

     Converts all the characters in all the strings in OBJ to lower
     case.

     This currently delegates to Octave’s own ‘lower()’ function to do
     the conversion, so whatever character class handling it has, this
     has.

     Returns a string array of the same size as OBJ.


File: tablicious.info,  Node: string.upper,  Next: string.erase,  Prev: string.lower,  Up: string

10.2.57.17 string.upper
.......................

 -- Method: OUT = upper (OBJ)

     Convert to upper case.

     Converts all the characters in all the strings in OBJ to upper
     case.

     This currently delegates to Octave’s own ‘upper()’ function to do
     the conversion, so whatever character class handling it has, this
     has.

     Returns a string array of the same size as OBJ.


File: tablicious.info,  Node: string.erase,  Next: string.strrep,  Prev: string.upper,  Up: string

10.2.57.18 string.erase
.......................

 -- Method: OUT = erase (OBJ, MATCH)

     Erase matching substring.

     Erases the substrings in OBJ which match the MATCH input.

     Returns a string array of the same size as OBJ.


File: tablicious.info,  Node: string.strrep,  Next: string.strfind,  Prev: string.erase,  Up: string

10.2.57.19 string.strrep
........................

 -- Method: OUT = strrep (OBJ, MATCH, REPLACEMENT)
 -- Method: OUT = strrep (..., VARARGIN)

     Replace occurrences of pattern with other string.

     Replaces matching substrings in OBJ with a given replacement
     string.

     VARARGIN is passed along to the core Octave ‘strrep’ function.
     This supports whatever options it does.  TODO: Maybe document what
     those options are.

     Returns a string array of the same size as OBJ.


File: tablicious.info,  Node: string.strfind,  Next: string.regexprep,  Prev: string.strrep,  Up: string

10.2.57.20 string.strfind
.........................

 -- Method: OUT = strfind (OBJ, PATTERN)
 -- Method: OUT = strfind (..., VARARGIN)

     Find pattern in string.

     Finds the locations where PATTERN occurs in the strings of OBJ.

     TODO: It’s ambiguous whether a scalar this should result in a
     numeric out or a cell array out.

     Returns either an index vector, or a cell array of index vectors.


File: tablicious.info,  Node: string.regexprep,  Next: string.strcmp,  Prev: string.strfind,  Up: string

10.2.57.21 string.regexprep
...........................

 -- Method: OUT = regexprep (OBJ, PAT, REPSTR)
 -- Method: OUT = regexprep (..., VARARGIN)

     Replace based on regular expression matching.

     Replaces all the substrings matching a given regexp pattern PAT
     with the given replacement text REPSTR.

     Returns a string array of the same size as OBJ.


File: tablicious.info,  Node: string.strcmp,  Next: string.cmp,  Prev: string.regexprep,  Up: string

10.2.57.22 string.strcmp
........................

 -- Method: OUT = strcmp (A, B)

     String comparison.

     Tests whether each element in A is exactly equal to the
     corresponding element in B. Missing values are not considered equal
     to each other.

     This does the same comparison as ‘A == B’, but is not polymorphic.
     Generally, there is no reason to use ‘strcmp’ instead of ‘==’ or
     ‘eq’ on string arrays, unless you want to be compatible with
     cellstr inputs as well.

     Returns logical array the size of the scalar expansion of A and B.


File: tablicious.info,  Node: string.cmp,  Next: string.missing,  Prev: string.strcmp,  Up: string

10.2.57.23 string.cmp
.....................

 -- Method: [OUT, OUTA, OUTB] = cmp (A, B)

     Value ordering comparison, returning -1/0/+1.

     Compares each element of A and B, returning for each element ‘i’
     whether ‘A(i)’ was less than (-1), equal to (0), or greater than
     (1) the corresponding ‘B(i)’.

     TODO: What to do about missing values?  Should missings sort to the
     end (preserving total ordering over the full domain), or should
     their comparisons result in a fourth "null"/"undef" return value,
     probably represented by NaN? FIXME: The current implementation does
     not handle missings.

     Returns a numeric array OUT of the same size as the scalar
     expansion of A and B.  Each value in it will be -1, 0, or 1.

     Also returns scalar-expanded copies of A and B as OUTA and OUTB, as
     a programming convenience.


File: tablicious.info,  Node: string.missing,  Next: string.decode,  Prev: string.cmp,  Up: string

10.2.57.24 string.missing
.........................

 -- Static Method: OUT = string.missing (SZ)

     Missing string value.

     Creates a string array of all-missing values of the specified size
     SZ.  If SZ is omitted, creates a scalar missing string.

     Returns a string array of size SZ.


File: tablicious.info,  Node: string.decode,  Prev: string.missing,  Up: string

10.2.57.25 string.decode
........................

 -- Static Method: OUT = string.decode (BYTES, CHARSETNAME)

     Decode encoded text from bytes.

     Decodes the given encoded text in BYTES according to the specified
     encoding, given by CHARSETNAME.

     Returns a scalar string.

     See also: *note string.encode::


File: tablicious.info,  Node: struct2table,  Next: table,  Prev: string,  Up: API Alphabetically

10.2.58 struct2table
--------------------

 -- Function: OUT = struct2table (S)
 -- Function: OUT = struct2table (..., ‘'AsArray'’, ASARRAY)

     Convert struct to a table.

     Converts the input struct S to a ‘table’.

     S may be a scalar struct or a nonscalar struct array.

     The ASARRAY option is not implemented yet.

     Returns a ‘table’.


File: tablicious.info,  Node: table,  Next: tableOuterFillValue,  Prev: struct2table,  Up: API Alphabetically

10.2.59 table
-------------

 -- Class: table

     Tabular data array containing multiple columnar variables.

     A ‘table’ is a tabular data structure that collects multiple
     parallel named variables.  Each variable is treated like a column.
     (Possibly a multi-columned column, if that makes sense.)  The types
     of variables may be heterogeneous.

     A table object is like an SQL table or resultset, or a relation, or
     a DataFrame in R or Pandas.

     A table is an array in itself: its size is NROWS-by-NVARIABLES, and
     you can index along the rows and variables by indexing into the
     table along dimensions 1 and 2.

     A note on accessing properties of a ‘table’ array: Because
     .-indexing is used to access the variables inside the array, it
     can’t also be directly used to access properties as well.  Instead,
     do ‘t.Properties.<property>’ for a table ‘t’.  That will give you a
     property instead of a variable.  (And due to this mechanism, it
     will cause problems if you have a ‘table’ with a variable named
     ‘Properties’.  Try to avoid that.)

 -- Instance Variable of table: ‘cellstr’ VariableNames

     The names of the variables in the table, as a cellstr row vector.

 -- Instance Variable of table: ‘cell’ VariableValues

     A cell vector containing the values for each of the variables.
     ‘VariableValues(i)’ corresponds to ‘VariableNames(i)’.

 -- Instance Variable of table: ‘cellstr’ RowNames

     An optional list of row names that identify each row in the table.
     This is a cellstr column vector, if present.

* Menu:

* table.table::
* table.summary::
* table.prettyprint::
* table.table2cell::
* table.table2struct::
* table.table2array::
* table.varnames::
* table.istable::
* table.size::
* table.length::
* table.ndims::
* table.squeeze::
* table.sizeof::
* table.height::
* table.rows::
* table.width::
* table.columns::
* table.numel::
* table.isempty::
* table.ismatrix::
* table.isrow::
* table.iscol::
* table.isvector::
* table.isscalar::
* table.hasrownames::
* table.vertcat::
* table.horzcat::
* table.repmat::
* table.repelem::
* table.setVariableNames::
* table.setDimensionNames::
* table.setRowNames::
* table.resolveVarRef::
* table.subsetrows::
* table.subsetvars::
* table.removevars::
* table.movevars::
* table.setvar::
* table.addvars::
* table.convertvars::
* table.mergevars::
* table.splitvars::
* table.stack::
* table.head::
* table.tail::
* table.join::
* table.innerjoin::
* table.outerjoin::
* table.outerfillvals::
* table.semijoin::
* table.antijoin::
* table.cartesian::
* table.groupby::
* table.grpstats::
* table.splitapply::
* table.rows2vars::
* table.congruentize::
* table.union::
* table.intersect::
* table.setxor::
* table.setdiff::
* table.ismember::
* table.ismissing::
* table.rmmissing::
* table.standardizeMissing::
* table.varfun::
* table.rowfun::
* table.findgroups::
* table.evalWithVars::
* table.restrict::


File: tablicious.info,  Node: table.table,  Next: table.summary,  Up: table

10.2.59.1 table.table
.....................

 -- Constructor: OBJ = table ()

     Constructs a new empty (0 rows by 0 variables) table.

 -- Constructor: OBJ = table (VAR1, VAR2, ..., VARN)

     Constructs a new table from the given variables.  The variables
     passed as inputs to this constructor become the variables of the
     table.  Their names are automatically detected from the input
     variable names that you used.

 -- Constructor: OBJ = table (‘'Size'’, SZ, ‘'VariableTypes'’, VARTYPES)

     Constructs a new table of the given size, and with the given
     variable types.  The variables will contain the default value for
     elements of that type.

 -- Constructor: OBJ = table (..., ‘'VariableNames'’, VARNAMES)
 -- Constructor: OBJ = table (..., ‘'RowNames'’, ROWNAMES)

     Specifies the variable names or row names to use in the constructed
     table.  Overrides the implicit names garnered from the input
     variable names.


File: tablicious.info,  Node: table.summary,  Next: table.prettyprint,  Prev: table.table,  Up: table

10.2.59.2 table.summary
.......................

 -- Method: summary (OBJ)

     Summary of table’s data.

     Displays a summary of data in the input table.  This will contain
     some statistical information on each of its variables.


File: tablicious.info,  Node: table.prettyprint,  Next: table.table2cell,  Prev: table.summary,  Up: table

10.2.59.3 table.prettyprint
...........................

 -- Method: prettyprint (OBJ)

     Display table’s values in tabular format.  This prints the contents
     of the table in human-readable, tabular form.

     Variables which contain objects are displayed using the strings
     returned by their ‘dispstrs’ method, if they define one.


File: tablicious.info,  Node: table.table2cell,  Next: table.table2struct,  Prev: table.prettyprint,  Up: table

10.2.59.4 table.table2cell
..........................

 -- Method: C = table2cell (OBJ)

     Converts table to a cell array.  Each variable in OBJ becomes one
     or more columns in the output, depending on how many columns that
     variable has.

     Returns a cell array with the same number of rows as OBJ, and with
     as many or more columns as OBJ has variables.


File: tablicious.info,  Node: table.table2struct,  Next: table.table2array,  Prev: table.table2cell,  Up: table

10.2.59.5 table.table2struct
............................

 -- Method: S = table2struct (OBJ)
 -- Method: S = table2struct (..., ‘'ToScalar'’, TRUEORFALSE)

     Converts OBJ to a scalar structure or structure array.

     Row names are not included in the output struct.  To include them,
     you must add them manually: s = table2struct (tbl, ’ToScalar’,
     true); s.RowNames = tbl.Properties.RowNames;

     Returns a scalar struct or struct array, depending on the value of
     the ‘ToScalar’ option.


File: tablicious.info,  Node: table.table2array,  Next: table.varnames,  Prev: table.table2struct,  Up: table

10.2.59.6 table.table2array
...........................

 -- Method: S = table2struct (OBJ)

     Converts OBJ to a homogeneous array.


File: tablicious.info,  Node: table.varnames,  Next: table.istable,  Prev: table.table2array,  Up: table

10.2.59.7 table.varnames
........................

 -- Method: OUT = varnames (OBJ)

     Get variable names for a table.

     Returns cellstr.


File: tablicious.info,  Node: table.istable,  Next: table.size,  Prev: table.varnames,  Up: table

10.2.59.8 table.istable
.......................

 -- Method: TF = istable (OBJ)

     True if input is a table.


File: tablicious.info,  Node: table.size,  Next: table.length,  Prev: table.istable,  Up: table

10.2.59.9 table.size
....................

 -- Method: SZ = size (OBJ)

     Gets the size of a table.

     For tables, the size is [number-of-rows x number-of-variables].
     This is the same as ‘[height(obj), width(obj)]’.


File: tablicious.info,  Node: table.length,  Next: table.ndims,  Prev: table.size,  Up: table

10.2.59.10 table.length
.......................

 -- Method: OUT = length (OBJ)

     Length along longest dimension

     Use of ‘length’ is not recommended.  Use ‘numel’ or ‘size’ instead.


File: tablicious.info,  Node: table.ndims,  Next: table.squeeze,  Prev: table.length,  Up: table

10.2.59.11 table.ndims
......................

 -- Method: OUT = ndims (OBJ)

     Number of dimensions

     For tables, ‘ndims(obj)’ is always 2.


File: tablicious.info,  Node: table.squeeze,  Next: table.sizeof,  Prev: table.ndims,  Up: table

10.2.59.12 table.squeeze
........................

 -- Method: OBJ = squeeze (OBJ)

     Remove singleton dimensions.

     For tables, this is always a no-op that returns the input
     unmodified, because tables always have exactly 2 dimensions.


File: tablicious.info,  Node: table.sizeof,  Next: table.height,  Prev: table.squeeze,  Up: table

10.2.59.13 table.sizeof
.......................

 -- Method: OUT = sizeof (OBJ)

     Approximate size of array in bytes.  For tables, this returns the
     sume of ‘sizeof’ for all of its variables’ arrays, plus the size of
     the VariableNames and any other metadata stored in OBJ.

     This is currently unimplemented.


File: tablicious.info,  Node: table.height,  Next: table.rows,  Prev: table.sizeof,  Up: table

10.2.59.14 table.height
.......................

 -- Method: OUT = height (OBJ)

     Number of rows in table.


File: tablicious.info,  Node: table.rows,  Next: table.width,  Prev: table.height,  Up: table

10.2.59.15 table.rows
.....................

 -- Method: OUT = rows (OBJ)

     Number of rows in table.


File: tablicious.info,  Node: table.width,  Next: table.columns,  Prev: table.rows,  Up: table

10.2.59.16 table.width
......................

 -- Method: OUT = width (OBJ)

     Number of variables in table.

     Note that this is not the sum of the number of columns in each
     variable.  It is just the number of variables.


File: tablicious.info,  Node: table.columns,  Next: table.numel,  Prev: table.width,  Up: table

10.2.59.17 table.columns
........................

 -- Method: OUT = columns (OBJ)

     Number of variables in table.

     Note that this is not the sum of the number of columns in each
     variable.  It is just the number of variables.


File: tablicious.info,  Node: table.numel,  Next: table.isempty,  Prev: table.columns,  Up: table

10.2.59.18 table.numel
......................

 -- Method: OUT = numel (OBJ)

     Total number of elements in table.

     This is the total number of elements in this table.  This is
     calculated as the sum of numel for each variable.

     NOTE: Those semantics may be wrong.  This may actually need to be
     defined as ‘height(obj) * width(obj)’.  The behavior of ‘numel’ may
     change in the future.


File: tablicious.info,  Node: table.isempty,  Next: table.ismatrix,  Prev: table.numel,  Up: table

10.2.59.19 table.isempty
........................

 -- Method: OUT = isempty (OBJ)

     Test whether array is empty.

     For tables, ‘isempty’ is true if the number of rows is 0 or the
     number of variables is 0.


File: tablicious.info,  Node: table.ismatrix,  Next: table.isrow,  Prev: table.isempty,  Up: table

10.2.59.20 table.ismatrix
.........................

 -- Method: OUT = ismatrix (OBJ)

     Test whether array is a matrix.

     For tables, ‘ismatrix’ is always true, by definition.


File: tablicious.info,  Node: table.isrow,  Next: table.iscol,  Prev: table.ismatrix,  Up: table

10.2.59.21 table.isrow
......................

 -- Method: OUT = isrow (OBJ)

     Test whether array is a row vector.


File: tablicious.info,  Node: table.iscol,  Next: table.isvector,  Prev: table.isrow,  Up: table

10.2.59.22 table.iscol
......................

 -- Method: OUT = iscol (OBJ)

     Test whether array is a column vector.

     For tables, ‘iscol’ is true if the input has a single variable.
     The number of columns within that variable does not matter.


File: tablicious.info,  Node: table.isvector,  Next: table.isscalar,  Prev: table.iscol,  Up: table

10.2.59.23 table.isvector
.........................

 -- Method: OUT = isvector (OBJ)

     Test whether array is a vector.


File: tablicious.info,  Node: table.isscalar,  Next: table.hasrownames,  Prev: table.isvector,  Up: table

10.2.59.24 table.isscalar
.........................

 -- Method: OUT = isscalar (OBJ)

     Test whether array is scalar.


File: tablicious.info,  Node: table.hasrownames,  Next: table.vertcat,  Prev: table.isscalar,  Up: table

10.2.59.25 table.hasrownames
............................

 -- Method: OUT = hasrownames (OBJ)

     True if this table has row names defined.


File: tablicious.info,  Node: table.vertcat,  Next: table.horzcat,  Prev: table.hasrownames,  Up: table

10.2.59.26 table.vertcat
........................

 -- Method: OUT = vertcat (VARARGIN)

     Vertical concatenation.

     Combines tables by vertically concatenating them.

     Inputs that are not tables are automatically converted to tables by
     calling table() on them.

     The inputs must have the same number and names of variables, and
     their variable value types and sizes must be cat-compatible.


File: tablicious.info,  Node: table.horzcat,  Next: table.repmat,  Prev: table.vertcat,  Up: table

10.2.59.27 table.horzcat
........................

 -- Method: OUT = horzcat (VARARGIN)

     Horizontal concatenation.

     Combines tables by horizontally concatenating them.  Inputs that
     are not tables are automatically converted to tables by calling
     table() on them.  Inputs must have all distinct variable names.

     Output has the same RowNames as ‘varargin{1}’.  The variable names
     and values are the result of the concatenation of the variable
     names and values lists from the inputs.


File: tablicious.info,  Node: table.repmat,  Next: table.repelem,  Prev: table.horzcat,  Up: table

10.2.59.28 table.repmat
.......................

 -- Method: OUT = repmat (OBJ, SZ)

     Replicate matrix.

     Repmats a table by repmatting each of its variables vertically.

     For tables, repmatting is only supported along dimension 1.  That
     is, the values of sz(2:end) must all be exactly 1.

     Returns a new table with the same variable names and types as tbl,
     but with a possibly different row count.


File: tablicious.info,  Node: table.repelem,  Next: table.setVariableNames,  Prev: table.repmat,  Up: table

10.2.59.29 table.repelem
........................

 -- Method: OUT = repelem (OBJ, R)
 -- Method: OUT = repelem (OBJ, R_1, R_2)

     Replicate elements of matrix.

     Replicates elements of this table matrix by applying repelem to
     each of its variables.

     Only two dimensions are supported for ‘repelem’ on tables.


File: tablicious.info,  Node: table.setVariableNames,  Next: table.setDimensionNames,  Prev: table.repelem,  Up: table

10.2.59.30 table.setVariableNames
.................................

 -- Method: OUT = setVariableNames (OBJ, NAMES)
 -- Method: OUT = setVariableNames (OBJ, IX, NAMES)

     Set variable names.

     Sets the ‘VariableNames’ for this table to a new list of names.

     NAMES is a char or cellstr vector.  It must have the same number of
     elements as the number of variable names being assigned.

     IX is an index vector indicating which variable names to set.  If
     omitted, it sets all of them present in OBJ.

     This method exists because the ‘obj.Properties.VariableNames = ...’
     assignment form does not work, possibly due to an Octave bug.


File: tablicious.info,  Node: table.setDimensionNames,  Next: table.setRowNames,  Prev: table.setVariableNames,  Up: table

10.2.59.31 table.setDimensionNames
..................................

 -- Method: OUT = setDimensionNames (OBJ, NAMES)
 -- Method: OUT = setDimensionNames (OBJ, IX, NAMES)

     Set dimension names.

     Sets the ‘DimensionNames’ for this table to a new list of names.

     NAMES is a char or cellstr vector.  It must have the same number of
     elements as the number of dimension names being assigned.

     IX is an index vector indicating which dimension names to set.  If
     omitted, it sets all two of them.  Since there are always two
     dimension, the indexes in IX may never be higher than 2.

     This method exists because the ‘obj.Properties.DimensionNames =
     ...’ assignment form does not work, possibly due to an Octave bug.


File: tablicious.info,  Node: table.setRowNames,  Next: table.resolveVarRef,  Prev: table.setDimensionNames,  Up: table

10.2.59.32 table.setRowNames
............................

 -- Method: OUT = setRowNames (OBJ, NAMES)

     Set row names.

     Sets the row names on OBJ to NAMES.

     NAMES is a cellstr column vector, with the same number of rows as
     OBJ has.


File: tablicious.info,  Node: table.resolveVarRef,  Next: table.subsetrows,  Prev: table.setRowNames,  Up: table

10.2.59.33 table.resolveVarRef
..............................

 -- Method: [IXVAR, VARNAMES] = resolveVarRef (OBJ, VARREF)
 -- Method: [IXVAR, VARNAMES] = resolveVarRef (OBJ, VARREF, STRICTNESS)

     Resolve a variable reference against this table.

     A VARREF is a numeric or char/cellstr indicator of which variables
     within OBJ are being referenced.

     STRICTNESS controls what to do when the given variable references
     could not be resolved.  It may be ’strict’ (the default) or
     ’lenient’.

     Returns: IXVAR - the indexes of the variables in OBJ VARNAMES - a
     cellstr of the names of the variables in OBJ

     Raises an error if any of the specified variables could not be
     resolved, unless strictness is ’lenient’, in which case it will
     return 0 for the index and ” for the name for each variable which
     could not be resolved.


File: tablicious.info,  Node: table.subsetrows,  Next: table.subsetvars,  Prev: table.resolveVarRef,  Up: table

10.2.59.34 table.subsetrows
...........................

 -- Method: OUT = subsetrows (OBJ, IXROWS)

     Subset table by rows.

     Subsets this table by rows.

     IXROWS may be a numeric or logical index into the rows of OBJ.


File: tablicious.info,  Node: table.subsetvars,  Next: table.removevars,  Prev: table.subsetrows,  Up: table

10.2.59.35 table.subsetvars
...........................

 -- Method: OUT = subsetvars (OBJ, IXVARS)

     Subset table by variables.

     Subsets table OBJ by subsetting it along its variables.

     ixVars may be: - a numeric index vector - a logical index vector -
     ":" - a cellstr vector of variable names

     The resulting table will have its variables reordered to match
     ixVars.


File: tablicious.info,  Node: table.removevars,  Next: table.movevars,  Prev: table.subsetvars,  Up: table

10.2.59.36 table.removevars
...........................

 -- Method: OUT = removevars (OBJ, VARS)

     Remove variables from table.

     Deletes the variables specified by VARS from OBJ.

     VARS may be a char, cellstr, numeric index vector, or logical index
     vector.


File: tablicious.info,  Node: table.movevars,  Next: table.setvar,  Prev: table.removevars,  Up: table

10.2.59.37 table.movevars
.........................

 -- Method: OUT = movevars (OBJ, VARS, RELLOCATION, LOCATION)

     Move around variables in a table.

     VARS is a list of variables to move, specified by name or index.

     RELLOCATION is ‘'Before'’ or ‘'After'’.

     LOCATION indicates a single variable to use as the target location,
     specified by name or index.  If it is specified by index, it is the
     index into the list of *unmoved* variables from OBJ, not the
     original full list of variables in OBJ.

     Returns a table with the same variables as OBJ, but in a different
     order.


File: tablicious.info,  Node: table.setvar,  Next: table.addvars,  Prev: table.movevars,  Up: table

10.2.59.38 table.setvar
.......................

 -- Method: OUT = setvar (OBJ, VARREF, VALUE)

     Set value for a variable in table.

     This sets (adds or replaces) the value for a variable in OBJ.  It
     may be used to change the value of an existing variable, or add a
     new variable.

     VARREF is a variable reference, either the index or name of a
     variable.  If you are adding a new variable, it must be a name, and
     not an index.

     VALUE is the value to set the variable to.  If it is scalar or a
     single string as charvec, it is scalar-expanded to match the number
     of rows in OBJ.


File: tablicious.info,  Node: table.addvars,  Next: table.convertvars,  Prev: table.setvar,  Up: table

10.2.59.39 table.addvars
........................

 -- Method: OUT = addvars (OBJ, VAR1, ..., VARN)
 -- Method: OUT = addvars (..., ‘'Before'’, BEFORE)
 -- Method: OUT = addvars (..., ‘'After'’, AFTER)
 -- Method: OUT = addvars (..., ‘'NewVariableNames'’, NEWVARIABLENAMES)

     Add variables to table

     Adds the specified variables to a table.


File: tablicious.info,  Node: table.convertvars,  Next: table.mergevars,  Prev: table.addvars,  Up: table

10.2.59.40 table.convertvars
............................

 -- Method: OUT = convertvars (OBJ, VARS, DATATYPE)

     Convert variables to specified data type.

     Converts the variables in OBJ specified by VARS to the specified
     data type.

     VARS is a cellstr or numeric vector specifying which variables to
     convert.

     DATATYPE specifies the data type to convert those variables to.  It
     is either a char holding the name of the data type, or a function
     handle which will perform the conversion.  If it is the name of the
     data type, there must either be a one-arg constructor of that type
     which accepts the specified variables’ current types as input, or a
     conversion method of that name defined on the specified variables’
     current type.

     Returns a table with the same variable names as OBJ, but with
     converted types.


File: tablicious.info,  Node: table.mergevars,  Next: table.splitvars,  Prev: table.convertvars,  Up: table

10.2.59.41 table.mergevars
..........................

 -- Method: OUT = mergevars (OBJ, VARS)
 -- Method: OUT = mergevars (..., ‘'NewVariableName'’, NEWVARIABLENAME)
 -- Method: OUT = mergevars (..., ‘'MergeAsTable'’, MERGEASTABLE)

     Merge table variables into a single variable.


File: tablicious.info,  Node: table.splitvars,  Next: table.stack,  Prev: table.mergevars,  Up: table

10.2.59.42 table.splitvars
..........................

 -- Method: OUT = splitvars (OBJ)
 -- Method: OUT = splitvars (OBJ, VARS)
 -- Method: OUT = splitvars (..., ‘'NewVariableNames'’,
          NEWVARIABLENAMES)

     Split multicolumn table variables.

     Splits multicolumn table variables into new single-column
     variables.  If VARS is supplied, splits only those variables.  If
     VARS is not supplied, splits all multicolumn variables.


File: tablicious.info,  Node: table.stack,  Next: table.head,  Prev: table.splitvars,  Up: table

10.2.59.43 table.stack
......................

 -- Method: OUT = stack (OBJ, VARS)
 -- Method: OUT = stack (..., ‘'NewDataVariableName'’,
          NEWDATAVARIABLENAME)
 -- Method: OUT = stack (..., ‘'IndexVariableName'’, INDEXVARIABLENAME)

     Stack multiple table variables into a single variable.


File: tablicious.info,  Node: table.head,  Next: table.tail,  Prev: table.stack,  Up: table

10.2.59.44 table.head
.....................

 -- Method: OUT = head (OBJ)
 -- Method: OUT = head (OBJ, K)

     Get first K rows of table.

     Returns the first K rows of OBJ, as a table.

     K defaults to 8.

     If there are less than K rows in OBJ, returns all rows.


File: tablicious.info,  Node: table.tail,  Next: table.join,  Prev: table.head,  Up: table

10.2.59.45 table.tail
.....................

 -- Method: OUT = tail (OBJ)
 -- Method: OUT = tail (OBJ, K)

     Get last K rows of table.

     Returns the last K rows of OBJ, as a table.

     K defaults to 8.

     If there are less than K rows in OBJ, returns all rows.


File: tablicious.info,  Node: table.join,  Next: table.innerjoin,  Prev: table.tail,  Up: table

10.2.59.46 table.join
.....................

 -- Method: [C, IB] = join (A, B)
 -- Method: [C, IB] = join (A, B, ...)

     Combine two tables by rows using key variables, in a restricted
     form.

     This is not a "real" relational join operation.  It has the
     restrictions that: 1) The key values in B must be unique.  2) Every
     key value in A must map to a key value in B. These are restrictions
     inherited from the Matlab definition of table.join.

     You probably don’t want to use this method.  You probably want to
     use innerjoin or outerjoin instead.

     See also: *note table.innerjoin::, *note table.outerjoin::


File: tablicious.info,  Node: table.innerjoin,  Next: table.outerjoin,  Prev: table.join,  Up: table

10.2.59.47 table.innerjoin
..........................

 -- Method: [OUT, IXA, IXB] = innerjoin (A, B)
 -- Method: [...] = innerjoin (A, B, ...)

     Combine two tables by rows using key variables.

     Computes the relational inner join between two tables.  “Inner”
     means that only rows which had matching rows in the other input are
     kept in the output.

     TODO: Document options.

     Returns: OUT - A table that is the result of joining A and B IX -
     Indexes into A for each row in out IXB - Indexes into B for each
     row in out


File: tablicious.info,  Node: table.outerjoin,  Next: table.outerfillvals,  Prev: table.innerjoin,  Up: table

10.2.59.48 table.outerjoin
..........................

 -- Method: [OUT, IXA, IXB] = outerjoin (A, B)
 -- Method: [...] = outerjoin (A, B, ...)

     Combine two tables by rows using key variables, retaining unmatched
     rows.

     Computes the relational outer join of tables A and B. This is like
     a regular join, but also includes rows in each input which did not
     have matching rows in the other input; the columns from the missing
     side are filled in with placeholder values.

     TODO: Document options.

     Returns: OUT - A table that is the result of the outer join of A
     and B IXA - indexes into A for each row in out IXB - indexes into B
     for each row in out


File: tablicious.info,  Node: table.outerfillvals,  Next: table.semijoin,  Prev: table.outerjoin,  Up: table

10.2.59.49 table.outerfillvals
..............................

 -- Method: OUT = outerfillvals (OBJ)

     Get fill values for outer join.

     Returns a table with the same variables as this, but containing
     only a single row whose variable values are the values to use as
     fill values when doing an outer join.


File: tablicious.info,  Node: table.semijoin,  Next: table.antijoin,  Prev: table.outerfillvals,  Up: table

10.2.59.50 table.semijoin
.........................

 -- Method: [OUTA, IXA, OUTB, IXB] = semijoin (A, B)

     Natural semijoin.

     Computes the natural semijoin of tables A and B. The semi-join of
     tables A and B is the set of all rows in A which have matching rows
     in B, based on comparing the values of variables with the same
     names.

     This method also computes the semijoin of B and A, for convenience.

     Returns: OUTA - all the rows in A with matching row(s) in B IXA -
     the row indexes into A which produced OUTA OUTB - all the rows in B
     with matching row(s) in A IXB - the row indexes into B which
     produced OUTB


File: tablicious.info,  Node: table.antijoin,  Next: table.cartesian,  Prev: table.semijoin,  Up: table

10.2.59.51 table.antijoin
.........................

 -- Method: [OUTA, IXA, OUTB, IXB] = antijoin (A, B)

     Natural antijoin (AKA “semidifference”).

     Computes the anti-join of A and B. The anti-join is defined as all
     the rows from one input which do not have matching rows in the
     other input.

     Returns: OUTA - all the rows in A with no matching row in B IXA -
     the row indexes into A which produced OUTA OUTB - all the rows in B
     with no matching row in A IXB - the row indexes into B which
     produced OUTB


File: tablicious.info,  Node: table.cartesian,  Next: table.groupby,  Prev: table.antijoin,  Up: table

10.2.59.52 table.cartesian
..........................

 -- Method: [OUT, IXS] = cartesian (A, B)

     Cartesian product of two tables.

     Computes the Cartesian product of two tables.  The Cartesian
     product is each row in A combined with each row in B.

     Due to the definition and structural constraints of table, the two
     inputs must have no variable names in common.  It is an error if
     they do.

     The Cartesian product is seldom used in practice.  If you find
     yourself calling this method, you should step back and re-evaluate
     what you are doing, asking yourself if that is really what you want
     to happen.  If nothing else, writing a function that calls
     cartesian() is usually much less efficient than alternate ways of
     arriving at the same result.

     This implementation does not remove duplicate values.  TODO:
     Determine whether this duplicate-removing behavior is correct.

     The ordering of the rows in the output is not specified, and may be
     implementation- dependent.  TODO: Determine if we can lock this
     behavior down to a fixed, defined ordering, without killing
     performance.


File: tablicious.info,  Node: table.groupby,  Next: table.grpstats,  Prev: table.cartesian,  Up: table

10.2.59.53 table.groupby
........................

 -- Method: [OUT] = groupby (OBJ, GROUPVARS, AGGCALCS)

     Find groups in table data and apply functions to variables within
     groups.

     This works like an SQL ‘"SELECT ... GROUP BY ..."’ statement.

     GROUPVARS (cellstr, numeric) is a list of the grouping variables,
     identified by name or index.

     AGGCALCS is a specification of the aggregate calculations to
     perform on them, in the form ‘{’OUT_VAR‘,’ FCN‘,’ IN_VARS‘; ...}’,
     where: OUT_VAR (char) is the name of the output variable FCN
     (function handle) is the function to apply to produce it IN_VARS
     (cellstr) is a list of the input variables to pass to fcn

     Returns a table.


File: tablicious.info,  Node: table.grpstats,  Next: table.splitapply,  Prev: table.groupby,  Up: table

10.2.59.54 table.grpstats
.........................

 -- Method: [OUT] = grpstats (OBJ, GROUPVAR)
 -- Method: [OUT] = grpstats (..., ‘'DataVars'’, DATAVARS)

     Statistics by group.

     See also: *note table.groupby::.


File: tablicious.info,  Node: table.splitapply,  Next: table.rows2vars,  Prev: table.grpstats,  Up: table

10.2.59.55 table.splitapply
...........................

 -- Method: OUT = splitapply (FUNC, OBJ, G)
 -- Method: [Y1, ..., YM] = splitapply (FUNC, OBJ, G)

     Split table data into groups and apply function.

     Performs a splitapply, using the variables in OBJ as the input X
     variables to the ‘splitapply’ function call.

     See also: *note splitapply::, *note table.groupby::


File: tablicious.info,  Node: table.rows2vars,  Next: table.congruentize,  Prev: table.splitapply,  Up: table

10.2.59.56 table.rows2vars
..........................

 -- Method: OUT = rows2vars (OBJ)
 -- Method: OUT = rows2vars (OBJ, ‘'VariableNamesSource'’,
          VARIABLENAMESSOURCE)
 -- Method: OUT = rows2vars (..., ‘'DataVariables'’, DATAVARIABLES)

     Reorient table, swapping rows and variables dimensions.

     This flips the dimensions of the given table OBJ, swapping the
     orientation of the contained data, and swapping the row
     names/labels and variable names.

     The variable names become a new variable named
     “OriginalVariableNames”.

     The row names are drawn from the column VARIABLENAMESSOURCE if it
     is specified.  Otherwise, if OBJ has row names, they are used.
     Otherwise, new variable names in the form “VarN” are generated.

     If all the variables in OBJ are of the same type, they are
     concatenated and then sliced to create the new variable values.
     Otherwise, they are converted to cells, and the new table has cell
     variable values.


File: tablicious.info,  Node: table.congruentize,  Next: table.union,  Prev: table.rows2vars,  Up: table

10.2.59.57 table.congruentize
.............................

 -- Method: [OUTA, OUTB] = congruentize (A, B)

     Make tables congruent.

     Makes tables congruent by ensuring they have the same variables of
     the same types in the same order.  Congruent tables may be safely
     unioned, intersected, vertcatted, or have other set operations done
     to them.

     Variable names present in one input but not in the other produces
     an error.  Variables with the same name but different types in the
     inputs produces an error.  Inputs must either both have row names
     or both not have row names; it is an error if one has row names and
     the other doesn’t.  Variables in different orders are reordered to
     be in the same order as A.


File: tablicious.info,  Node: table.union,  Next: table.intersect,  Prev: table.congruentize,  Up: table

10.2.59.58 table.union
......................

 -- Method: [C, IA, IB] = union (A, B)

     Set union.

     Computes the union of two tables.  The union is defined to be the
     unique row values which are present in either of the two input
     tables.

     Returns: C - A table containing all the unique row values present
     in A or B. IA - Row indexes into A of the rows from A included in
     C. IB - Row indexes into B of the rows from B included in C.


File: tablicious.info,  Node: table.intersect,  Next: table.setxor,  Prev: table.union,  Up: table

10.2.59.59 table.intersect
..........................

 -- Method: [C, IA, IB] = intersect (A, B)

     Set intersection.

     Computes the intersection of two tables.  The intersection is
     defined to be the unique row values which are present in both of
     the two input tables.

     Returns: C - A table containing all the unique row values present
     in both A and B. IA - Row indexes into A of the rows from A
     included in C. IB - Row indexes into B of the rows from B included
     in C.


File: tablicious.info,  Node: table.setxor,  Next: table.setdiff,  Prev: table.intersect,  Up: table

10.2.59.60 table.setxor
.......................

 -- Method: [C, IA, IB] = setxor (A, B)

     Set exclusive OR.

     Computes the setwise exclusive OR of two tables.  The set XOR is
     defined to be the unique row values which are present in one or the
     other of the two input tables, but not in both.

     Returns: C - A table containing all the unique row values in the
     set XOR of A and B. IA - Row indexes into A of the rows from A
     included in C. IB - Row indexes into B of the rows from B included
     in C.


File: tablicious.info,  Node: table.setdiff,  Next: table.ismember,  Prev: table.setxor,  Up: table

10.2.59.61 table.setdiff
........................

 -- Method: [C, IA] = setdiff (A, B)

     Set difference.

     Computes the set difference of two tables.  The set difference is
     defined to be the unique row values which are present in table A
     that are not in table B.

     Returns: C - A table containing the unique row values in A that
     were not in B. IA - Row indexes into A of the rows from A included
     in C.


File: tablicious.info,  Node: table.ismember,  Next: table.ismissing,  Prev: table.setdiff,  Up: table

10.2.59.62 table.ismember
.........................

 -- Method: [TF, LOC] = ismember (A, B)

     Set membership.

     Finds rows in A that are members of B.

     Returns: TF - A logical vector indicating whether each A(i,:) was
     present in B. LOC - Indexes into B of rows that were found.


File: tablicious.info,  Node: table.ismissing,  Next: table.rmmissing,  Prev: table.ismember,  Up: table

10.2.59.63 table.ismissing
..........................

 -- Method: OUT = ismissing (OBJ)
 -- Method: OUT = ismissing (OBJ, INDICATOR)

     Find missing values.

     Finds missing values in OBJ’s variables.

     If indicator is not supplied, uses the standard missing values for
     each variable’s data type.  If indicator is supplied, the same
     indicator list is applied across all variables.

     All variables in this must be vectors.  (This is due to the
     requirement that ‘size(out) == size(obj)’.)

     Returns a logical array the same size as OBJ.


File: tablicious.info,  Node: table.rmmissing,  Next: table.standardizeMissing,  Prev: table.ismissing,  Up: table

10.2.59.64 table.rmmissing
..........................

 -- Method: [OUT, TF] = rmmissing (OBJ)
 -- Method: [OUT, TF] = rmmissing (OBJ, INDICATOR)
 -- Method: [OUT, TF] = rmmissing (..., ‘'DataVariables'’, VARS)
 -- Method: [OUT, TF] = rmmissing (..., ‘'MinNumMissing'’,
          MINNUMMISSING)

     Remove rows with missing values.

     Removes the rows from OBJ that have missing values.

     If the ’DataVariables’ option is given, only the data in the
     specified variables is considered.

     Returns: OUT - A table the same as OBJ, but with rows with missing
     values removed.  TF - A logical index vector indicating which rows
     were removed.


File: tablicious.info,  Node: table.standardizeMissing,  Next: table.varfun,  Prev: table.rmmissing,  Up: table

10.2.59.65 table.standardizeMissing
...................................

 -- Method: OUT = standardizeMissing (OBJ, INDICATOR)
 -- Method: OUT = standardizeMissing (..., ‘'DataVariables'’, VARS)

     Insert standard missing values.

     Standardizes missing values in variable data.

     If the DATAVARIABLES option is supplied, only the indicated
     variables are standardized.

     INDICATOR is passed along to ‘standardizeMissing’ when it is called
     on each of the data variables in turn.  The same indicator is used
     for all variables.  You can mix and match indicator types by just
     passing in mixed indicator types in a cell array; indicators that
     don’t match the type of the column they are operating on are just
     ignored.

     Returns a table with same variable names and types as OBJ, but with
     variable values standardized.


File: tablicious.info,  Node: table.varfun,  Next: table.rowfun,  Prev: table.standardizeMissing,  Up: table

10.2.59.66 table.varfun
.......................

 -- Method: OUT = varfun (FCN, OBJ)
 -- Method: OUT = varfun (..., ‘'OutputFormat'’, OUTPUTFORMAT)
 -- Method: OUT = varfun (..., ‘'InputVariables'’, VARS)
 -- Method: OUT = varfun (..., ‘'ErrorHandler'’, ERRORFCN)

     Apply function to table variables.

     Applies the given function FCN to each variable in OBJ, collecting
     the output in a table, cell array, or array of another type.


File: tablicious.info,  Node: table.rowfun,  Next: table.findgroups,  Prev: table.varfun,  Up: table

10.2.59.67 table.rowfun
.......................

 -- Method: OUT = varfun (FUNC, OBJ)
 -- Method: OUT = varfun (..., ‘'OptionName'’, OPTIONVALUE, ...)

     Apply function to rows in table and collect outputs.

     This applies the function FUNC to the elements of each row of OBJ’s
     variables, and collects the concatenated output(s) into the
     variable(s) of a new table.

     FUNC is a function handle.  It should take as many inputs as there
     are variables in OBJ.  Or, it can take a single input, and you must
     specify ‘'SeparateInputs', false’ to have the input variables
     concatenated before being passed to FUNC.  It may return multiple
     argouts, but to capture those past the first one, you must
     explicitly specify the ‘'NumOutputs'’ or ‘'OutputVariableNames'’
     options.

     Supported name/value options:
     ‘'OutputVariableNames'’
          Names of table variables to store combined function output
          arguments in.
     ‘'NumOutputs'’
          Number of output arguments to call function with.  If omitted,
          defaults to number of items in OUTPUTVARIABLENAMES if it is
          supplied, otherwise defaults to 1.
     ‘'SeparateInputs'’
          If true, input variables are passed as separate input
          arguments to FUNC.  If false, they are concatenated together
          into a row vector and passed as a single argument.  Defaults
          to true.
     ‘'ErrorHandler'’
          A function to call as a fallback when calling FUNC results in
          an error.  It is passed the caught exception, along with the
          original inputs passed to FUNC, and it has a “second chance”
          to compute replacement values for that row.  This is useful
          for converting raised errors to missing-value fill values, or
          logging warnings.
     ‘'ExtractCellContents'’
          Whether to “pop out” the contents of the elements of cell
          variables in OBJ, or to leave them as cells.  True/false;
          default is false.  If you specify this option, then OBJ may
          not have any multi-column cell-valued variables.
     ‘'InputVariables'’
          If specified, only these variables from OBJ are used as the
          function inputs, instead of using all variables.
     ‘'GroupingVariables'’
          Not yet implemented.
     ‘'OutputFormat'’
          The format of the output.  May be ‘'table'’ (the default),
          ‘'uniform'’, or ‘'cell'’.  If it is ‘'uniform'’ or ‘'cell'’,
          the output variables are returned in multiple output arguments
          from ‘'rowfun'’.

     Returns a ‘table’ whose variables are the collected output
     arguments of FUNC if OUTPUTFORMAT is ‘'table'’.  Otherwise, returns
     multiple output arguments of whatever type FUNC returned (if
     OUTPUTFORMAT is ‘'uniform'’) or cells (if OUTPUTFORMAT is
     ‘'cell'’).


File: tablicious.info,  Node: table.findgroups,  Next: table.evalWithVars,  Prev: table.rowfun,  Up: table

10.2.59.68 table.findgroups
...........................

 -- Method: [G, TID] = findgroups (OBJ)

     Find groups within a table’s row values.

     Finds groups within a table’s row values and get group numbers.  A
     group is a set of rows that have the same values in all their
     variable elements.

     Returns: G - A double column vector of group numbers created from
     OBJ.  TID - A table containing the row values corresponding to the
     group numbers.


File: tablicious.info,  Node: table.evalWithVars,  Next: table.restrict,  Prev: table.findgroups,  Up: table

10.2.59.69 table.evalWithVars
.............................

 -- Method: OUT = evalWithVars (OBJ, EXPR)

     Evaluate an expression against table’s variables.

     Evaluates the M-code expression EXPR in a workspace where all of
     OBJ’s variables have been assigned to workspace variables.

     EXPR is a charvec containing an Octave expression.

     As an implementation detail, the workspace will also contain some
     variables that are prefixed and suffixed with "__".  So try to
     avoid those in your table variable names.

     Returns the result of the evaluation.

     Examples:

          [s,p,sp] = table_examples.SpDb
          tmp = join (sp, p);
          shipment_weight = evalWithVars (tmp, "Qty .* Weight")


File: tablicious.info,  Node: table.restrict,  Prev: table.evalWithVars,  Up: table

10.2.59.70 table.restrict
.........................

 -- Method: OUT = restrict (OBJ, EXPR)
 -- Method: OUT = restrict (OBJ, IX)

     Subset rows using variable expression or index.

     Subsets a table row-wise, using either an index vector or an
     expression involving OBJ’s variables.

     If the argument is a numeric or logical vector, it is interpreted
     as an index into the rows of this.  (Just as with ‘subsetrows
     (this, index)‘.)

     If the argument is a char, then it is evaulated as an M-code
     expression, with all of this’ variables available as workspace
     variables, as with ‘evalWithVars’.  The output of expr must be a
     numeric or logical index vector (This form is a shorthand for ‘out
     = subsetrows (this, evalWithVars (this, expr))’.)

     TODO: Decide whether to name this to "where" to be more like SQL
     instead of relational algebra.

     Examples:
          [s,p,sp] = table_examples.SpDb;
          prettyprint (restrict (p, 'Weight >= 14 & strcmp(Color, "Red")'))


File: tablicious.info,  Node: tableOuterFillValue,  Next: timezones,  Prev: table,  Up: API Alphabetically

10.2.60 tableOuterFillValue
---------------------------

 -- Function: OUT = tableOuterFillValue (X)

     Outer fill value for variable within a table.

     Determines the fill value to usse for a given variable value X when
     that value is used as a variable in a table that is involved in an
     outer join.

     The default implementation for ‘tableOuterFillValue’ has support
     for all Octave primitive types, plus cellstrs, datetime & friends,
     strings, and ‘table’-valued variables.

     This function may become private to table before version 1.0.  It
     is currently global to make debugging more convenient.  It (or an
     equivalent) will remain global if we want to allow user-defined
     classes to customize their fill value.  It also has default logic
     that will determine the fill value for an arbitrary type by
     detecting the value used to fill elements during array expansion
     operations.  This will be appropriate for most data types.

     Returns a 1-by-ncols value of the same type as x, which may be any
     type, where ncols is the number of columns in the input.


File: tablicious.info,  Node: timezones,  Next: vartype,  Prev: tableOuterFillValue,  Up: API Alphabetically

10.2.61 timezones
-----------------

 -- Function: OUT = timezones ()
 -- Function: OUT = timezones (AREA)

     List all the time zones defined on this system.

     This lists all the time zones that are defined in the IANA time
     zone database used by this Octave.  (On Linux and macOS, that will
     generally be the system time zone database from
     ‘/usr/share/zoneinfo’.  On Windows, it will be the database
     redistributed with the Chrono package.

     If the return is captured, the output is returned as a table if
     your Octave has table support, or a struct if it does not.  It will
     have fields/variables containing column vectors:

     ‘Name’
          The IANA zone name, as cellstr.
     ‘Area’
          The geographical area the zone is in, as cellstr.

     Compatibility note: Matlab also includes UTCOffset and DSTOffset
     fields in the output; these are currently unimplemented.


File: tablicious.info,  Node: vartype,  Next: vecfun,  Prev: timezones,  Up: API Alphabetically

10.2.62 vartype
---------------

 -- Function: OUT = vartype (TYPE)

     Filter by variable type for use in suscripting.

     Creates an object that can be used for subscripting into the
     variables dimension of a table and filtering on variable type.

     TYPE is the name of a type as charvec.  This may be anything that
     the ‘isa’ function accepts, or ‘'cellstr'’ to select cellstrs, as
     determined by ‘iscellstr’.

     Returns an object of an opaque type.  Don’t worry about what type
     it is; just pass it into the second argument of a subscript into a
     ‘table’ object.


File: tablicious.info,  Node: vecfun,  Next: years,  Prev: vartype,  Up: API Alphabetically

10.2.63 vecfun
--------------

 -- Function: OUT = vecfun (FCN, X, DIM)

     Apply function to vectors in array along arbitrary dimension.

     This function is not implemented yet.

     Applies a given function to the vector slices of an N-dimensional
     array, where those slices are along a given dimension.

     FCN is a function handle to apply.

     X is an array of arbitrary type which is to be sliced and passed in
     to FCN.

     DIM is the dimension along which the vector slices lay.

     Returns the collected output of the FCN calls, which will be the
     same size as X, but not necessarily the same type.


File: tablicious.info,  Node: years,  Prev: vecfun,  Up: API Alphabetically

10.2.64 years
-------------

 -- Function File: OUT = years (X)
     Create a ‘duration’ X years long, or get the years in a ‘duration’
     X.

     If input is numeric, returns a ‘duration’ array in units of
     fixed-length years of 365.2425 days each.

     If input is a ‘duration’, converts the ‘duration’ to a number of
     fixed-length years as double.

     Note: ‘years’ creates fixed-length years, which may not be what you
     want.  To create a duration of calendar years (which account for
     actual leap days), use ‘calyears’.

     *Note calyears::.


File: tablicious.info,  Node: Copying,  Prev: API Reference,  Up: Top

11 Copying
**********

11.1 Package Copyright
======================

Tablicious for Octave is covered by the GNU GPLv3.

   All the code in the package is GNU GPLv3.

   The Fisher Iris dataset is Public Domain.

11.2 Manual Copyright
=====================

This manual is for Tablicious, version 0.1.0+.

   Copyright © 2019 Andrew Janke

     Permission is granted to make and distribute verbatim copies of
     this manual provided the copyright notice and this permission
     notice are preserved on all copies.

     Permission is granted to copy and distribute modified versions of
     this manual under the conditions for verbatim copying, provided
     that the entire resulting derived work is distributed under the
     terms of a permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
     manual into another language, under the same conditions as for
     modified versions.



Tag Table:
Node: Top773
Node: Introduction1160
Node: Getting Started2524
Node: Table Representation3340
Node: table Class3603
Node: Date Representation3915
Node: datetime Class4175
Node: datenum Compatibility5008
Node: Time Zones6552
Node: Defined Time Zones9389
Node: Durations10364
Node: duration Class10546
Node: calendarDuration Class11301
Node: Validation Functions12206
Node: Example Data Sets14498
Node: Missing Functionality15908
Node: API Reference17379
Node: API by Category17570
Node: API Alphabetically22900
Node: array2table27177
Node: calendarDuration28115
Node: calendarDuration.calendarDuration30049
Node: calendarDuration.sizeof30562
Node: calendarDuration.isnat30844
Node: calendarDuration.uminus31171
Node: calendarDuration.plus31456
Node: calendarDuration.times32067
Node: calendarDuration.minus32430
Node: calendarDuration.dispstrs32781
Node: calendarDuration.isnan33127
Node: calmonths33533
Node: calyears34124
Node: categorical34470
Node: categorical.undefined36772
Node: categorical.categorical37281
Node: categorical.sizeof38566
Node: categorical.categories38818
Node: categorical.iscategory39218
Node: categorical.isordinal39666
Node: categorical.string40037
Node: categorical.cellstr40486
Node: categorical.dispstrs40927
Node: categorical.summary41385
Node: categorical.addcats41840
Node: categorical.removecats42270
Node: categorical.mergecats42914
Node: categorical.renamecats43571
Node: categorical.reordercats43990
Node: categorical.setcats44527
Node: categorical.isundefined44975
Node: categorical.ismissing45495
Node: categorical.isnannish45907
Node: categorical.squeezecats46387
Node: cell2table46759
Node: colvecfun47501
Node: contains48227
Node: datetime49016
Node: datetime.datetime51410
Node: datetime.ofDatenum52234
Node: datetime.ofDatestruct52596
Node: datetime.NaT53101
Node: datetime.posix2datenum53868
Node: datetime.datenum2posix54347
Node: datetime.sizeof54751
Node: datetime.proxyKeys54986
Node: datetime.ymd55625
Node: datetime.hms56017
Node: datetime.ymdhms56414
Node: datetime.timeofday56859
Node: datetime.week57281
Node: datetime.dispstrs57543
Node: datetime.datestr57844
Node: datetime.datestrs58238
Node: datetime.datestruct58661
Node: datetime.posixtime59465
Node: datetime.datenum60001
Node: datetime.gmtime60320
Node: datetime.localtime60763
Node: datetime.isnat61487
Node: datetime.isnan61770
Node: datetime.lt62143
Node: datetime.le62576
Node: datetime.ne63018
Node: datetime.eq63452
Node: datetime.ge63882
Node: datetime.gt64328
Node: datetime.plus64763
Node: datetime.minus65261
Node: datetime.diff65908
Node: datetime.isbetween66290
Node: datetime.linspace66780
Node: datetime.convertDatenumTimeZone67395
Node: days68051
Node: discretize68519
Node: dispstrs69418
Node: duration70204
Node: duration.ofDays71411
Node: duration.sizeof71902
Node: duration.years72104
Node: duration.hours72506
Node: duration.minutes72881
Node: duration.seconds73272
Node: duration.milliseconds73639
Node: duration.dispstrs74051
Node: duration.char74366
Node: duration.linspace74798
Node: endsWith75411
Node: eqn76196
Node: fillmissing77286
Node: hours78139
Node: iscategorical78628
Node: isdatetime78916
Node: isduration79197
Node: isfile79471
Node: isfolder80583
Node: ismissing81552
Node: isnannish83845
Node: isstring84898
Node: localdate85164
Node: localdate.localdate86488
Node: localdate.NaT87026
Node: localdate.ymd87916
Node: localdate.dispstrs88222
Node: localdate.datestr88528
Node: localdate.datestrs88928
Node: localdate.datestruct89357
Node: localdate.posixtime90289
Node: localdate.datenum90862
Node: localdate.isnat91192
Node: localdate.isnan91481
Node: milliseconds91841
Node: minutes92378
Node: missing92638
Node: missing.missing93680
Node: missing.dispstrs93996
Node: missing.ismissing94395
Node: missing.isnan94762
Node: missing.isnannish95103
Node: mustBeA95439
Node: mustBeCellstr96018
Node: mustBeCharvec96655
Node: mustBeFinite97557
Node: mustBeInteger98099
Node: mustBeMember98746
Node: mustBeNonempty99576
Node: mustBeNumeric100127
Node: mustBeReal100674
Node: mustBeSameSize101205
Node: mustBeScalar101845
Node: mustBeScalarLogical102394
Node: mustBeVector102989
Node: NaT103531
Node: octave.chrono.dummy_function104378
Node: octave.chrono.DummyClass104912
Node: octave.chrono.DummyClass.DummyClass105717
Node: octave.chrono.DummyClass.foo106190
Node: octave.chrono.DummyClass.bar106731
Node: octave.dataset107228
Node: octave.dataset.AirPassengers108064
Node: octave.dataset.ChickWeight108785
Node: octave.dataset.airmiles110205
Node: octave.dataset.airquality110993
Node: octave.dataset.anscombe113085
Node: octave.dataset.attenu115052
Node: octave.dataset.attitude116491
Node: octave.dataset.austres117721
Node: octave.dataset.beavers118614
Node: octave.dataset.cupcake119757
Node: octave.dataset.iris120722
Node: octave.dataset.mtcars122238
Node: octave.datasets123944
Node: octave.datasets.list124468
Node: octave.datasets.load124978
Node: octave.datasets.description125411
Node: octave.examples.plot_pairs125993
Node: pp127114
Node: rmmissing127778
Node: scalarexpand128817
Node: seconds129743
Node: size2str130244
Node: splitapply130818
Node: standardizeMissing131943
Node: startsWith132772
Node: string133584
Node: string.string136898
Node: string.isstring137570
Node: string.dispstrs137897
Node: string.sizeof138478
Node: string.ismissing138698
Node: string.isnannish139179
Node: string.cellstr139564
Node: string.cell139911
Node: string.char140400
Node: string.encode140927
Node: string.strlength_bytes141445
Node: string.strlength142120
Node: string.reverse_bytes142689
Node: string.reverse143429
Node: string.strcat143903
Node: string.lower144483
Node: string.upper144987
Node: string.erase145490
Node: string.strrep145829
Node: string.strfind146436
Node: string.regexprep146961
Node: string.strcmp147439
Node: string.cmp148134
Node: string.missing149115
Node: string.decode149519
Node: struct2table149931
Node: table150400
Node: table.table153510
Node: table.summary154564
Node: table.prettyprint154910
Node: table.table2cell155371
Node: table.table2struct155861
Node: table.table2array156498
Node: table.varnames156747
Node: table.istable157001
Node: table.size157215
Node: table.length157546
Node: table.ndims157847
Node: table.squeeze158100
Node: table.sizeof158449
Node: table.height158882
Node: table.rows159092
Node: table.width159295
Node: table.columns159628
Node: table.numel159968
Node: table.isempty160490
Node: table.ismatrix160816
Node: table.isrow161107
Node: table.iscol161327
Node: table.isvector161689
Node: table.isscalar161917
Node: table.hasrownames162149
Node: table.vertcat162401
Node: table.horzcat162924
Node: table.repmat163546
Node: table.repelem164074
Node: table.setVariableNames164517
Node: table.setDimensionNames165312
Node: table.setRowNames166199
Node: table.resolveVarRef166574
Node: table.subsetrows167578
Node: table.subsetvars167925
Node: table.removevars168434
Node: table.movevars168821
Node: table.setvar169551
Node: table.addvars170278
Node: table.convertvars170747
Node: table.mergevars171737
Node: table.splitvars172142
Node: table.stack172702
Node: table.head173113
Node: table.tail173484
Node: table.join173852
Node: table.innerjoin174600
Node: table.outerjoin175263
Node: table.outerfillvals176072
Node: table.semijoin176507
Node: table.antijoin177278
Node: table.cartesian177932
Node: table.groupby179202
Node: table.grpstats180055
Node: table.splitapply180390
Node: table.rows2vars180893
Node: table.congruentize182020
Node: table.union182891
Node: table.intersect183465
Node: table.setxor184075
Node: table.setdiff184712
Node: table.ismember185251
Node: table.ismissing185655
Node: table.rmmissing186341
Node: table.standardizeMissing187135
Node: table.varfun188127
Node: table.rowfun188696
Node: table.findgroups191784
Node: table.evalWithVars192371
Node: table.restrict193223
Node: tableOuterFillValue194354
Node: timezones195593
Node: vartype196640
Node: vecfun197355
Node: years198084
Node: Copying198763

End Tag Table


Local Variables:
coding: utf-8
End:
