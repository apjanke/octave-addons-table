This is Tablicious.info, produced by makeinfo version 6.6 from
Tablicious.texi.

This manual is for Tablicious, version 0.1.0.

   Copyright © 2019 Andrew Janke

     Permission is granted to make and distribute verbatim copies of
     this manual provided the copyright notice and this permission
     notice are preserved on all copies.

     Permission is granted to copy and distribute modified versions of
     this manual under the conditions for verbatim copying, provided
     that the entire resulting derived work is distributed under the
     terms of a permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
     manual into another language, under the same conditions as for
     modified versions.


File: Tablicious.info,  Node: Top,  Next: Introduction

Tablicious for GNU Octave
*************************

This manual is for Tablicious, version 0.1.0.

* Menu:

* Introduction::
* Getting Started::
* Table Representation::
* Date Representation::
* Time Zones::
* Durations::
* Missing Functionality::
* API Reference::
* Copying::


File: Tablicious.info,  Node: Introduction,  Next: Getting Started,  Up: Top

1 Introduction
**************

     Time is an illusion.  Lunchtime doubly so.

                           — _Douglas Adams_

   This is the manual for the Tablicious package version 0.1.0 for GNU
Octave.

   Tablicious provides Matlab-compatible tabular data and date/time
support for GNU Octave.  This includes a ‘table’ class with support for
filtering and join operations; ‘datetime’, ‘duration’, and related
classes; Missing Data support; ‘string’ and ‘categorical’ data types;
and other miscellaneous things.

   This document is a work in progress.  You are invited to help improve
it and submit patches.

   Tablicious’s classes are designed to be convenient to use while still
being efficient.  The data representations used by Tablicious are
designed to be efficient and suitable for working with large-ish data
sets.  A “large-ish” data set is one that can have millions of elements
or rows, but still fits in main computer memory.  Tablicious’s main
relational and arithmetic operations are all implemented using
vectorized operations on primitive Octave data types.

   Tablicious was written by Andrew Janke <<floss@apjanke.net>>.
Support can be found on the Tablicious project GitHub page
(https://github.com/apjanke/octave-tablicious).


File: Tablicious.info,  Node: Getting Started,  Next: Table Representation,  Prev: Introduction,  Up: Top

2 Getting Started
*****************

The easiest way to obtain Tablicious is by using Octave’s ‘pkg’ package
manager.  To install the development prerelease of Tablicious, run this
in Octave:

     pkg install https://github.com/apjanke/octave-tablicious/releases/download/v0.1.0/tablicious-0.1.0.tar.gz

   (Check the releases page at
<https://github.com/apjanke/octave-tablicious/releases> to find out what
the actual latest release number is.)

   For development, you can obtain the source code for Tablicious from
the project repo on GitHub at
<https://github.com/apjanke/octave-tablicious>.  Make a local clone of
the repo.  Then add the ‘inst’ directory in the repo to your Octave
path.


File: Tablicious.info,  Node: Table Representation,  Next: Date Representation,  Prev: Getting Started,  Up: Top

3 Table Representation
**********************

Tablicious provides the ‘table’ class for representing tabular data.

* Menu:

* table Class::


File: Tablicious.info,  Node: table Class,  Up: Table Representation

3.1 ‘table’ Class
=================

A ‘table’ is an array object that represents a tabular data structure.
It holds multiple named “variables”, each of which is a column vector,
or a 2-D matrix whose rows are read as records.


File: Tablicious.info,  Node: Date Representation,  Next: Time Zones,  Prev: Table Representation,  Up: Top

4 Date Representation
*********************

Chrono provides the ‘datetime’ class for representing points in time.

* Menu:

* datetime Class::


File: Tablicious.info,  Node: datetime Class,  Up: Date Representation

4.1 ‘datetime’ Class
====================

A ‘datetime’ is an array object that represents points in time in the
familiar Gregorian calendar.

   This is an attempt to reproduce the functionality of Matlab’s
‘datetime’.  It also contains some Octave-specific extensions.

   The underlying representation is that of a datenum (a ‘double’
containing the number of days since the Matlab epoch), but encapsulating
it in an object provides several benefits: friendly human-readable
display, type safety, automatic type conversion, and time zone support.
In addition to the underlying datenum array, a ‘datetime’ inclues an
optional ‘TimeZone’ property indicating what time zone the datetimes are
in.

* Menu:

* datenum Compatibility::


File: Tablicious.info,  Node: datenum Compatibility,  Up: datetime Class

4.1.1 ‘datenum’ Compatibility
-----------------------------

While the underlying data representation of ‘datetime’ is compatible
with (in fact, identical to) that of datenums, you cannot directly
combine them via assignment, concatenation, or most arithmetic
operations.

   This is because of the signature of the ‘datetime’ constructor.  When
combining objects and primitive types like ‘double’, the primitive type
is promoted to an object by calling the other object’s one-argument
constructor on it.  However, the one-argument numeric-input consstructor
for ‘datetime’ does not accept datenums: it interprets its input as
datevecs instead.  This is due to a design decision on Matlab’s part;
for compatibility, Octave does not alter that interface.

   To combine ‘datetime’s with datenums, you can convert the datenums to
‘datetime’s by calling ‘datetime.ofDatenum’ or ‘datetime(x,
'ConvertFrom', 'datenum')’, or you can convert the ‘datetime’s to
datenums by accessing its ‘dnums’ field with ‘x.dnums’.

   Examples:

     dt = datetime('2011-03-04')
     dn = datenum('2017-01-01')
     [dt dn]
         ⇒ error: datenum: expected date vector containing [YEAR, MONTH, DAY, HOUR, MINUTE, SECOND]
     [dt datetime.ofDatenum(dn)]
         ⇒ 04-Mar-2011   01-Jan-2017

   Also, if you have a zoned ‘datetime’, you can’t combine it with a
datenum, because datenums do not carry time zone information.


File: Tablicious.info,  Node: Time Zones,  Next: Durations,  Prev: Date Representation,  Up: Top

5 Time Zones
************

Chrono has support for representing dates in time zones and for
converting between time zones.

   A ‘datetime’ may be "zoned" or "zoneless".  A zoneless ‘datetime’
does not have a time zone associated with it.  This is represented by an
empty ‘TimeZone’ property on the ‘datetime’ object.  A zoneless
‘datetime’ represents the local time in some unknown time zone, and
assumes a continuous time scale (no DST shifts).

   A zoned ‘datetime’ is associated with a time zone.  It is represented
by having the time zone’s IANA zone identifier (e.g.  ‘'UTC'’ or
‘'America/New_York'’) in its ‘TimeZone’ property.  A zoned ‘datetime’
represents the local time in that time zone.

   By default, the ‘datetime’ constructor creates unzoned ‘datetime’s.
To make a zoned ‘datetime’, either pass the ‘'TimeZone'’ option to the
constructor, or set the ‘TimeZone’ property after object creation.
Setting the ‘TimeZone’ property on a zoneless ‘datetime’ declares that
it’s a local time in that time zone.  Setting the ‘TimeZone’ property on
a zoned ‘datetime’ turns it back into a zoneless ‘datetime’ without
changing the local time it represents.

   You can tell a zoned from a zoneless time zone in the object display
because the time zone is included for zoned ‘datetime’s.

     % Create an unzoned datetime
     d = datetime('2011-03-04 06:00:00')
         ⇒  04-Mar-2011 06:00:00

     % Create a zoned datetime
     d_ny = datetime('2011-03-04 06:00:00', 'TimeZone', 'America/New_York')
         ⇒  04-Mar-2011 06:00:00 America/New_York
     % This is equivalent
     d_ny = datetime('2011-03-04 06:00:00');
     d_ny.TimeZone = 'America/New_York'
         ⇒  04-Mar-2011 06:00:00 America/New_York

     % Convert it to Chicago time
     d_chi.TimeZone = 'America/Chicago'
         ⇒  04-Mar-2011 05:00:00 America/Chicago

   When you combine two zoned ‘datetime’s via concatenation, assignment,
or arithmetic, if their time zones differ, they are converted to the
time zone of the left-hand input.

     d_ny = datetime('2011-03-04 06:00:00', 'TimeZone', 'America/New_York')
     d_la = datetime('2011-03-04 06:00:00', 'TimeZone', 'America/Los_Angeles')
     d_la - d_ny
         ⇒ 03:00:00

   You cannot combine a zoned and an unzoned ‘datetime’.  This results
in an error being raised.

     Warning: Normalization of "nonexistent" times (like between 02:00
     and 03:00 on a "spring forward" DST change day) is not implemented
     yet.  The results of converting a zoneless local time into a time
     zone where that local time did not exist are currently undefined.

* Menu:

* Defined Time Zones::


File: Tablicious.info,  Node: Defined Time Zones,  Up: Time Zones

5.1 Defined Time Zones
======================

Chrono’s time zone data is drawn from the IANA Time Zone Database
(https://www.iana.org/time-zones), also known as the “Olson Database”.
Chrono includes a copy of this database in its distribution so it can
work on Windows, which does not supply it like Unix systems do.

   You can use the ‘timezones’ function to list the time zones known to
Chrono.  These will be all the time zones in the IANA database on your
system (for Linux and macOS) or in the IANA time zone database
redistributed with Chrono (for Windows).

     Note: The IANA Time Zone Database only covers dates from about the
     year 1880 to 2038.  Converting time zones for ‘datetime’s outside
     that range is currently unimplemented.  (Chrono needs to add
     support for proleptic POSIX time zone rules, which are used to
     govern behavior outside that date range.)


File: Tablicious.info,  Node: Durations,  Next: Missing Functionality,  Prev: Time Zones,  Up: Top

6 Durations
***********

* Menu:

* duration Class::
* calendarDuration Class::


File: Tablicious.info,  Node: duration Class,  Next: calendarDuration Class,  Up: Durations

6.1 ‘duration’ Class
====================

A ‘duration’ represents a period of time in fixed-length seconds (or
minutes, hours, or whatever you want to measure it in.)

   A ‘duration’ has a resolution of about a nanosecond for typical
dates.  The underlying representation is a ‘double’ representing the
number of days elapsed, similar to a datenum, except it’s interpreted as
relative to some other reference point you provide, instead of being
relative to the Matlab/Octave epoch.

   You can add or subtract a ‘duration’ to a ‘datetime’ to get another
‘datetime’.  You can also add or subtract ‘durations’ to each other.


File: Tablicious.info,  Node: calendarDuration Class,  Prev: duration Class,  Up: Durations

6.2 ‘calendarDuration’ Class
============================

A ‘calendarDuration’ represents a period of time in variable-length
calendar components.  For example, years and months can have varying
numbers of days, and days in time zones with Daylight Saving Time have
varying numbers of hours.  A ‘calendarDuration’ does arithmetic with
"whole" calendar periods.

   ‘calendarDuration’s and ‘duration’s cannot be directly combined,
because they are not semantically equivalent.  (This may be relaxed in
the future to allow ‘duration’s to be interpreted as numbers of days
when combined with ‘calendarDuration’s.)

     d = datetime('2011-03-04 00:00:00')
         ⇒ 04-Mar-2011
     cdur = calendarDuration(1, 3, 0)
         ⇒ 1y 3mo
     d2 = d + cdur
         ⇒ 04-Jun-2012


File: Tablicious.info,  Node: Missing Functionality,  Next: API Reference,  Prev: Durations,  Up: Top

7 Missing Functionality
***********************

Tablicious is based on Matlab’s table and date/time APIs and supports
most of their major functionality.  But not all of it is implemented
yet.  The missing parts are currently:

   • ‘timetable’
   • Moving window methods in ‘fillmissing’
   • ‘summary()’ for ‘table’ and ‘categorical’
   • Assignment to table variables using ‘.’-indexing
   • File I/O like ‘readtable()’ and ‘writetable()’
   • POSIX time zone support for years outside the IANA time zone
     database coverage
   • Week-of-year (ISO calendar) calculations
   • Various ‘'ConvertFrom'’ forms for ‘datetime’ and ‘duration’
   • Support for LDML formatting for ‘datetime’
   • Various functions: ‘between’, ‘caldiff’, ‘dateshift’, ‘week’
   • ‘isdst’, ‘isweekend’
   • ‘calendarDuration.split’
   • ‘duration.Format’ support
   • ‘UTCOffset’ and ‘DSTOffset’ fields in the output of ‘timezones()’
   • Plotting support

   It is the author’s hope that all these will be implemented some day.


File: Tablicious.info,  Node: API Reference,  Next: Copying,  Prev: Missing Functionality,  Up: Top

8 API Reference
***************

* Menu:

* API by Category::
* API Alphabetically::


File: Tablicious.info,  Node: API by Category,  Next: API Alphabetically,  Up: API Reference

8.1 API by Category
===================

8.1.1 Tables
------------

*note table::
     Tabular data array containing multiple columnar variables.

*note array2table::
     Convert an array to a table.

*note cell2table::
     Convert a cell array to a table.

*note struct2table::
     Convert struct to a table.

*note tableOuterFillValue::
     Outer fill value for variable within a table.

8.1.2 Data Types
----------------

*note string::
     A string array of Unicode strings.

*note startsWith::
     Test if strings start with a pattern.

*note endsWith::
     Test if strings end with a pattern.

*note contains::
     Test if strings contain a pattern.

*note categorical::
     Categorical variable array.

*note discretize::
     Group data into discrete bins or categories.

8.1.3 Missing Data
------------------

*note fillmissing::
     Fill missing values.

*note ismissing::
     Find missing values.

*note rmmissing::
     Remove missing values.

*note standardizeMissing::
     Insert standard missing values.

*note missing::
     Generic auto-converting missing value.

*note isnannish::
     Test if elements are NaN or NaN-like

*note eqn::
     Determine element-wise equality, treating NaNs as equal

8.1.4 Miscellaneous
-------------------

*note colvecfun::
     Apply a function to column vectors in array.

*note dispstrs::
     Display strings for array.

*note isfile::
     Test whether file exists and is not a folder.

*note isfolder::
     Test whether file exists and is a folder.

*note pp::
     Alias for prettyprint, for interactive use.

*note vecfun::
     Apply function to vectors in array along arbitrary dimension.


File: Tablicious.info,  Node: API Alphabetically,  Prev: API by Category,  Up: API Reference

8.2 API Alphabetically
======================

* Menu:

* array2table:: Convert an array to a table.
* categorical:: Categorical variable array.
* cell2table::	Convert a cell array to a table.
* colvecfun::	Apply a function to column vectors in array.
* contains::	Test if strings contain a pattern.
* discretize::	Group data into discrete bins or categories.
* dispstrs::	Display strings for array.
* endsWith::	Test if strings end with a pattern.
* eqn:: Determine element-wise equality, treating NaNs as equal
* fillmissing:: Fill missing values.
* isfile::	Test whether file exists and is not a folder.
* isfolder::	Test whether file exists and is a folder.
* ismissing::	Find missing values.
* isnannish::	Test if elements are NaN or NaN-like
* missing::	Generic auto-converting missing value.
* pp::	Alias for prettyprint, for interactive use.
* rmmissing::	Remove missing values.
* standardizeMissing::	Insert standard missing values.
* startsWith::	Test if strings start with a pattern.
* string::	A string array of Unicode strings.
* struct2table::	Convert struct to a table.
* table::	Tabular data array containing multiple columnar variables.
* tableOuterFillValue:: Outer fill value for variable within a table.
* vecfun::	Apply function to vectors in array along arbitrary
		dimension.


File: Tablicious.info,  Node: array2table,  Next: categorical,  Up: API Alphabetically

8.2.1 array2table
-----------------

 -- Function: OUT = array2table (C)
 -- Function: OUT = array2table (..., ‘'VariableNames'’, VARIABLENAMES)
 -- Function: OUT = array2table (..., ‘'RowNames'’, ROWNAMES)

     Convert an array to a table.

     Converts a 2-D array to a table, with columns in the array becoming
     variables in the output table.  This is typically used on numeric
     arrays, but it can be applied to any type of array.

     You may not want to use this on cell arrays, though, because you
     will end up with a table that has all its variables of type cell.
     If you use ‘cell2table’ instead, columns of the cell array which
     can be condensed into primitive arrays will be.  With
     ‘array2table’, they won’t be.

     See also: *note cell2table::, *note table::, *note struct2table::


File: Tablicious.info,  Node: categorical,  Next: cell2table,  Prev: array2table,  Up: API Alphabetically

8.2.2 categorical
-----------------

 -- Class: categorical

     Categorical variable array.

     A ‘categorical’ array represents an array of values of a
     categorical variable.  Each ‘categorical’ array stores the element
     values along with a list of the categories, and indicators of
     whether the categories are ordinal (that is, they have a meaningful
     mathematical ordering), and whether the set of categories is
     protected (preventing new categories from being added to the
     array).

     In addition to the categories defined in the array, a categorical
     array may have elements of "undefined" value.  This is not
     considered a category; rather, it is the absence of any known
     value.  It is analagous to a ‘NaN’ value.

     This class is not fully implemented yet.  Missing stuff: - gt, ge,
     lt, le - Ordinal support in general - countcats - summary

 -- Instance Variable of categorical: ‘uint16’ code

     The numeric codes of the array element values.  These are indexes
     into the ‘cats’ category list.

     This is a planar property.

 -- Instance Variable of categorical: ‘logical’ tfMissing

     A logical mask indicating whether each element of the array is
     missing (that is, undefined).

     This is a planar property.

 -- Instance Variable of categorical: ‘cellstr’ cats

     The names of the categories in this array.  This is the list into
     which the ‘code’ values are indexes.

 -- Instance Variable of categorical: ‘scalar_logical’ isOrdinal

     A scalar logical indicating whether the categories in this array
     have an ordinal relationship.

* Menu:

* categorical.categorical::
* categorical.categories::
* categorical.iscategory::
* categorical.isordinal::
* categorical.string::
* categorical.cellstr::
* categorical.dispstrs::
* categorical.summary::
* categorical.addcats::
* categorical.removecats::
* categorical.mergecats::
* categorical.renamecats::
* categorical.reordercats::
* categorical.setcats::
* categorical.isundefined::
* categorical.ismissing::
* categorical.isnannish::
* categorical.squeezecats::


File: Tablicious.info,  Node: categorical.categorical,  Next: categorical.categories,  Up: categorical

8.2.2.1 categorical.categorical
...............................

 -- Constructor: OBJ = categorical ()

     Constructs a new scalar categorical whose value is undefined.

 -- Constructor: OBJ = categorical (VALS)
 -- Constructor: OBJ = categorical (VALS, VALUESET)
 -- Constructor: OBJ = categorical (VALS, VALUESET, CATEGORY_NAMES)
 -- Constructor: OBJ = categorical (..., ‘'Ordinal'’, ORDINAL)
 -- Constructor: OBJ = categorical (..., ‘'Protected'’, PROTECTED)

     Constructs a new categorical array from the given values.

     VALS is the array of values to convert to categoricals.

     VALUESET is the set of all values from which VALS is drawn.  If
     omitted, it defaults to the unique values in VALS.

     CATEGORY_NAMES is a list of category names corresponding to
     VALUESET.  If omitted, it defaults to VALUESET, converted to
     strings.

     ORDINAL is a logical indicating whether the category values in OBJ
     have a numeric ordering relationship.  Defaults to false.

     PROTECTED indicates whether OBJ should be protected, which prevents
     the addition of new categories to the array.  Defaults to false.


File: Tablicious.info,  Node: categorical.categories,  Next: categorical.iscategory,  Prev: categorical.categorical,  Up: categorical

8.2.2.2 categorical.categories
..............................

 -- Method: OUT = categories (OBJ)

     Get a list of the categories in OBJ.

     Gets a list of the categories in OBJ, identified by their category
     names.

     Returns a cellstr column vector.


File: Tablicious.info,  Node: categorical.iscategory,  Next: categorical.isordinal,  Prev: categorical.categories,  Up: categorical

8.2.2.3 categorical.iscategory
..............................

 -- Method: OUT = iscategory (OBJ, CATNAMES)

     Test whether input is a category on a categorical array.

     CATNAMES is a cellstr listing the category names to check against
     OBJ.

     Returns a logical array the same size as CATNAMES.


File: Tablicious.info,  Node: categorical.isordinal,  Next: categorical.string,  Prev: categorical.iscategory,  Up: categorical

8.2.2.4 categorical.isordinal
.............................

 -- Method: OUT = isordinal (OBJ)

     Whether OBJ is ordinal.

     Returns true if OBJ is ordinal (as determined by its ‘IsOrdinal’
     property), and false otherwise.


File: Tablicious.info,  Node: categorical.string,  Next: categorical.cellstr,  Prev: categorical.isordinal,  Up: categorical

8.2.2.5 categorical.string
..........................

 -- Method: OUT = string (OBJ)

     Convert to string array.

     Converts OBJ to a string array.  The strings will be the category
     names for corresponding values, or <missing> for undefined values.

     Returns a ‘string’ array the same size as OBJ.


File: Tablicious.info,  Node: categorical.cellstr,  Next: categorical.dispstrs,  Prev: categorical.string,  Up: categorical

8.2.2.6 categorical.cellstr
...........................

 -- Method: OUT = cellstr (OBJ)

     Convert to cellstr.

     Converts OBJ to a cellstr array.  The strings will be the category
     names for corresponding values, or ‘''’ for undefined values.

     Returns a cellstr array the same size as OBJ.


File: Tablicious.info,  Node: categorical.dispstrs,  Next: categorical.summary,  Prev: categorical.cellstr,  Up: categorical

8.2.2.7 categorical.dispstrs
............................

 -- Method: OUT = dispstrs (OBJ)

     Display strings.

     Gets display strings for each element in OBJ.  The display strings
     are either the category string, or ‘'<undefined>'’ for undefined
     values.

     Returns a cellstr array the same size as OBJ.


File: Tablicious.info,  Node: categorical.summary,  Next: categorical.addcats,  Prev: categorical.dispstrs,  Up: categorical

8.2.2.8 categorical.summary
...........................

 -- Method: summary (OBJ)

     Display summary of array’s values.

     Displays a summary of the values in this categorical array.  The
     output may contain info like the number of categories, number of
     undefined values, and frequency of each category.


File: Tablicious.info,  Node: categorical.addcats,  Next: categorical.removecats,  Prev: categorical.summary,  Up: categorical

8.2.2.9 categorical.addcats
...........................

 -- Method: OUT = addcats (OBJ, NEWCATS)

     Add categories to categorical array.

     Adds the specified categories to OBJ, without changing any of its
     values.

     NEWCATS is a cellstr listing the category names to add to OBJ.


File: Tablicious.info,  Node: categorical.removecats,  Next: categorical.mergecats,  Prev: categorical.addcats,  Up: categorical

8.2.2.10 categorical.removecats
...............................

 -- Method: OUT = removecats (OBJ)

     Removes all unused categories from OBJ.  This is equivalent to ‘out
     = squeezecats (obj)’.

 -- Method: OUT = removecats (OBJ, OLDCATS)

     Remove categories from categorical array.

     Removes the specified categories from OBJ.  Elements of OBJ whose
     values belonged to those categories are replaced with undefined.

     NEWCATS is a cellstr listing the category names to add to OBJ.


File: Tablicious.info,  Node: categorical.mergecats,  Next: categorical.renamecats,  Prev: categorical.removecats,  Up: categorical

8.2.2.11 categorical.mergecats
..............................

 -- Method: OUT = mergecats (OBJ, OLDCATS)
 -- Method: OUT = mergecats (OBJ, OLDCATS, NEWCAT)

     Merge multiple categories.

     Merges the categories OLDCATS into a single category.  If NEWCAT is
     specified, that new category is added if necessary, and all of
     OLDCATS are merged into it.  NEWCAT must be an existing category in
     OBJ if OBJ is ordinal.

     If NEWCAT is not provided, all of ODCATS are merged into
     ‘oldcats{1}’.


File: Tablicious.info,  Node: categorical.renamecats,  Next: categorical.reordercats,  Prev: categorical.mergecats,  Up: categorical

8.2.2.12 categorical.renamecats
...............................

 -- Method: OUT = renamecats (OBJ, NEWCATS)
 -- Method: OUT = renamecats (OBJ, OLDCATS, NEWCATS)

     Rename categories.

     Renames some or all of the categories in OBJ, without changing any
     of its values.


File: Tablicious.info,  Node: categorical.reordercats,  Next: categorical.setcats,  Prev: categorical.renamecats,  Up: categorical

8.2.2.13 categorical.reordercats
................................

 -- Method: OUT = reordercats (OBJ)
 -- Method: OUT = reordercats (OBJ, NEWCATS)

     Reorder categories.

     Reorders the categories in OBJ to match NEWCATS.

     NEWCATS is a cellstr that must be a reordering of OBJ’s existing
     category list.  If NEWCATS is not supplied, sorts the categories in
     alphabetical order.


File: Tablicious.info,  Node: categorical.setcats,  Next: categorical.isundefined,  Prev: categorical.reordercats,  Up: categorical

8.2.2.14 categorical.setcats
............................

 -- Method: OUT = setcats (OBJ, NEWCATS)

     Set categories for categorical array.

     Sets the categories to use for OBJ.  If any current categories are
     absent from the NEWCATS list, current values of those categories
     become undefined.


File: Tablicious.info,  Node: categorical.isundefined,  Next: categorical.ismissing,  Prev: categorical.setcats,  Up: categorical

8.2.2.15 categorical.isundefined
................................

 -- Method: OUT = isundefined (OBJ)

     Test whether elements are undefined.

     Checks whether each element in OBJ is undefined.  "Undefined" is a
     special value defined by ‘categorical’.  It is equivalent to a
     ‘NaN’ or a ‘missing’ value.

     Returns a logical array the same size as OBJ.


File: Tablicious.info,  Node: categorical.ismissing,  Next: categorical.isnannish,  Prev: categorical.isundefined,  Up: categorical

8.2.2.16 categorical.ismissing
..............................

 -- Method: OUT = ismissing (OBJ)

     Test whether elements are missing.

     For categorical arrays, undefined elements are considered to be
     missing.

     Returns a logical array the same size as OBJ.


File: Tablicious.info,  Node: categorical.isnannish,  Next: categorical.squeezecats,  Prev: categorical.ismissing,  Up: categorical

8.2.2.17 categorical.isnannish
..............................

 -- Method: OUT = isnannish (OBJ)

     Test whethere elements are NaN-ish.

     Checks where each element in OBJ is NaN-ish.  For categorical
     arrays, undefined values are considered NaN-ish; any other value is
     not.

     Returns a logical array the same size as OBJ.


File: Tablicious.info,  Node: categorical.squeezecats,  Prev: categorical.isnannish,  Up: categorical

8.2.2.18 categorical.squeezecats
................................

 -- Method: OUT = squeezecats (OBJ)

     Remove unused categories.

     Removes all categories which have no corresponding values in OBJ’s
     elements.

     This is currently unimplemented.


File: Tablicious.info,  Node: cell2table,  Next: colvecfun,  Prev: categorical,  Up: API Alphabetically

8.2.3 cell2table
----------------

 -- Function: OUT = cell2table (C)
 -- Function: OUT = cell2table (..., ‘'VariableNames'’, VARIABLENAMES)
 -- Function: OUT = cell2table (..., ‘'RowNames'’, ROWNAMES)

     Convert a cell array to a table.

     Converts a 2-dimensional cell matrix into a table.  Each column in
     the input C becomes a variable in OUT.  For columns that contain
     all scalar values of ‘cat’-compatible types, they are “popped out”
     of their cells and condensed into a homogeneous array of the
     contained type.

     See also: *note array2table::, *note table::, *note struct2table::


File: Tablicious.info,  Node: colvecfun,  Next: contains,  Prev: cell2table,  Up: API Alphabetically

8.2.4 colvecfun
---------------

 -- Function: OUT = colvecfun (FCN, X)

     Apply a function to column vectors in array.

     Applies the given function FCN to each column vector in the array
     X, by iterating over the indexes along all dimensions except
     dimension 1.  Collects the function return values in an output
     array.

     FCN must be a function which takes a column vector and returns a
     column vector of the same size.  It does not have to return the
     same type as X.

     Returns the result of applying fcn to each column in x, all
     concatenated together in the same shape as x.


File: Tablicious.info,  Node: contains,  Next: discretize,  Prev: colvecfun,  Up: API Alphabetically

8.2.5 contains
--------------

 -- Function: OUT = colvecfun (STR, PATTERN)
 -- Function: OUT = colvecfun (..., ‘'IgnoreCase'’, IGNORECASE)

     Test if strings contain a pattern.

     Tests whether the given strings contain the given pattern(s).

     STR (char, cellstr, or string) is a list of strings to compare
     against pattern.

     PATTERN (char, cellstr, or string) is a list of patterns to match.
     These are literal plain string patterns, not regex patterns.  If
     more than one pattern is supplied, the return value is true if the
     string matched any of them.

     Returns a logical array of the same size as the string array
     represented by STR.


File: Tablicious.info,  Node: discretize,  Next: dispstrs,  Prev: contains,  Up: API Alphabetically

8.2.6 discretize
----------------

 -- Function: [Y, E] = discretize (X, N)
 -- Function: [Y, E] = discretize (X, EDGES)
 -- Function: [Y, E] = discretize (X, DUR)
 -- Function: [Y, E] = discretize (..., ‘'categorical'’)
 -- Function: [Y, E] = discretize (..., ‘'IncludedEdge'’, INCLUDEDEDGE)

     Group data into discrete bins or categories.

     N is the number of bins to group the values into.

     EDGES is an array of edge values defining the bins.

     DUR is a ‘duration’ value indicating the length of time of each
     bin.

     If ‘'categorical'’ is specified, the resulting values are a
     ‘categorical’ array instead of a numeric array of bin indexes.

     Returns: Y - the bin index or category of each value from X E - the
     list of bin edge values


File: Tablicious.info,  Node: dispstrs,  Next: endsWith,  Prev: discretize,  Up: API Alphabetically

8.2.7 dispstrs
--------------

 -- Function: OUT = dispstrs (X)

     Display strings for array.

     Gets the display strings for each element of X.  The display
     strings should be short, one-line, human-presentable strings
     describing the value of that element.

     The default implementation of ‘dispstrs’ can accept input of any
     type, and has decent implementations for Octave’s standard built-in
     types, but will have opaque displays for most user-defined objects.

     This is a polymorphic method that user-defined classes may override
     with their own custom display that is more informative.

     Returns a cell array the same size as X.


File: Tablicious.info,  Node: endsWith,  Next: eqn,  Prev: dispstrs,  Up: API Alphabetically

8.2.8 endsWith
--------------

 -- Function: OUT = endsWith (STR, PATTERN)
 -- Function: OUT = endsWith (..., ‘'IgnoreCase'’, IGNORECASE)

     Test if strings end with a pattern.

     Tests whether the given strings end with the given pattern(s).

     STR (char, cellstr, or string) is a list of strings to compare
     against PATTERN.

     PATTERN (char, cellstr, or string) is a list of patterns to match.
     These are literal plain string patterns, not regex patterns.  If
     more than one pattern is supplied, the return value is true if the
     string matched any of them.

     Returns a logical array of the same size as the string array
     represented by STR.


File: Tablicious.info,  Node: eqn,  Next: fillmissing,  Prev: endsWith,  Up: API Alphabetically

8.2.9 eqn
---------

 -- Function: OUT = eqn (A, B)

     Determine element-wise equality, treating NaNs as equal

     out = eqn (A, B)

     ‘eqn’ is just like ‘eq’ (the function that implements the ‘==’
     operator), except that it considers NaN and NaN-like values to be
     equal.  This is the element-wise equivalent of ‘isequaln’.

     ‘eqn’ uses ‘isnannish’ to test for NaN and NaN-like values, which
     means that NaNs and NaTs are considered to be NaN-like, and string
     arrays’ “missing” and categorical objects’ “undefined” values are
     considered equal, because they are NaN-ish.

     Developer’s note: the name “‘eqn’” is a little unfortunate, because
     “eqn” could also be an abbreviation for “equation”.  But this name
     follows the ‘isequaln’ pattern of appending an “n” to the
     corresponding non-NaN-equivocating function.

     See also: ‘eq’, ‘isequaln’, *note isnannish::


File: Tablicious.info,  Node: fillmissing,  Next: isfile,  Prev: eqn,  Up: API Alphabetically

8.2.10 fillmissing
------------------

 -- Function: [OUT, TFFILLED] = fillmissing (X, METHOD)
 -- Function: [OUT, TFFILLED] = fillmissing (X, ‘'constant'’, FILL_VAL)
 -- Function: [OUT, TFFILLED] = fillmissing (X, MOVMETHOD, WINDOW)

     Fill missing values.

     Fills missing values in X according to the method specified by
     METHOD.

     This method is only partially implemented.

     METHOD may be: ‘'constant'’ ‘'previous'’ ‘'next'’ ‘'nearest'’
     ‘'linear'’ ‘'spline'’ ‘'pchip'’ MOVMETHOD may be: ‘'movmean'’
     ‘'movmedian'’

     Returns OUT, which is X but with missing values filled in, and
     TFFILLED, a logical array the same size as X which indicates which
     elements were filled.


File: Tablicious.info,  Node: isfile,  Next: isfolder,  Prev: fillmissing,  Up: API Alphabetically

8.2.11 isfile
-------------

 -- Function: OUT = isfile (FILE)

     Test whether file exists and is not a folder.

     Tests whether the given file path FILE exists on the filesystem,
     and is not a folder (aka “directory”).  Files of any type except
     for directories are considered files by this function.

     TODO: Handling of symlinks is undetermined as of yet.

     FILE is a charvec containing the path to the file to test.  It may
     be an absolute or relative path.

     This is a new, more specific replacement for ‘exist(file, "file")’.
     Unlike ‘exist’, ‘isfile’ will not search the Octave load path for
     files.

     The underlying logic defers to ‘stat(file)’ for determining file
     existence and attributes, so any paths supported by ‘stat’ are also
     supported by ‘isfile’.  In particular, it seems that the ‘~’ alias
     for the home directory is supported, at least on Unix platforms.

     See also: *note isfolder::, ‘exist’


File: Tablicious.info,  Node: isfolder,  Next: ismissing,  Prev: isfile,  Up: API Alphabetically

8.2.12 isfolder
---------------

 -- Function: OUT = isfolder (FILE)

     Test whether file exists and is a folder.

     Tests whether the given file path FILE exists on the filesystem,
     and is a folder (aka “directory”).

     FILE is a charvec containing the path to the file to test.  It may
     be an absolute or relative path.

     This is a new, more specific replacement for ‘exist(file, "dir")’.
     Unlike ‘exist’, ‘isfolder’ will not search the Octave load path for
     files.

     The underlying logic defers to ‘stat(file)’ for determining file
     existence and attributes, so any paths supported by ‘stat’ are also
     supported by ‘isfolder’.  In particular, it seems that the ‘~’
     alias for the home directory is supported, at least on Unix
     platforms.

     See also: *note isfile::, ‘exist’


File: Tablicious.info,  Node: ismissing,  Next: isnannish,  Prev: isfolder,  Up: API Alphabetically

8.2.13 ismissing
----------------

 -- Function: OUT = ismissing (X)
 -- Function: OUT = ismissing (X, INDICATOR)

     Find missing values.

     Determines which elements of X contain missing values.  If an
     indicator input is not provided, standard missing values depending
     on the input type of X are used.

     Standard missing values depend on the data type: * NaN for double,
     single, duration, and calendarDuration * NaT for datetime * ‘' '’
     for char * ‘{''}’ for cellstrs * Integer numeric types have no
     standard missing value; they are never considered missing.  *
     Structs are never considered missing.  * Logicals are never
     considered missing.  * Other types have no standard missing value;
     it is currently an error to call ‘ismissing’ on them without
     providing an indicator.  * This includes cells which are not
     cellstrs; calling ‘ismissing’ on them results in an error.  * TODO:
     Determine whether this should really be an error, or if it should
     default to never considering those types as missing.  * TODO:
     Decide whether, for classdef objects, ‘ismissing’ should
     polymorphically detect isnan()/isnat()/isnannish() methods and use
     those, or whether we should require classes to override ismissing()
     itself.

     If INDICATOR is supplied, it is an array containing multiple
     values, all of which are considered to be missing values.  Only
     indicator values that are type-compatible with the input are
     considered; other indicator value types are silently ignored.  This
     is by design, so you can pass an indicator that holds sentinel
     values for disparate types in to ismissing() used for any type, or
     for compound types like table.

     Indicators are currently not supported for struct or logical
     inputs.  This is probably a bug.

     Table defines its own ismissing() method which respects individual
     variables’ data types; see *note table.ismissing::.


File: Tablicious.info,  Node: isnannish,  Next: missing,  Prev: ismissing,  Up: API Alphabetically

8.2.14 isnannish
----------------

 -- Function: OUT = isnannish (X)

     Test if elements are NaN or NaN-like

     Tests if input elements are NaN, NaT, or otherwise NaN-like.  This
     is true if isnan() or isnat() returns true, and is false for types
     that do not support isnan() or isnat().

     This function only exists because:

     a) Matlab decided to call their NaN values for datetime "NaT"
     instead, and test for them with a different "isnat()" function, and
     b) isnan() errors out for some types that do not support isnan(),
     like cells.

     isnannish() smooths over those differences so you can call it
     polymorphically on any input type.

     Under normal operation, isnannish() should not throw an error for
     any type or value of input.

     See also: ‘isnan’, ‘isnat’, *note ismissing::, *note eqn::,
     ‘isequaln’


File: Tablicious.info,  Node: missing,  Next: pp,  Prev: isnannish,  Up: API Alphabetically

8.2.15 missing
--------------

 -- Class: missing

     Generic auto-converting missing value.

     ‘missing’ is a generic missing value that auto-converts to other
     types.

     A ‘missing’ array indicates a missing value, of no particular type.
     It auto- converts to other types when it is combined with them via
     concatenation or other array combination operations.

     This class is currently EXPERIMENTAL. Use at your own risk.

     Note: This class does not actually work for assignment.  If you do
     this:

            x = 1:5
            x(3) = missing

     It’s supposed to work, but I can’t figure out how to do this in a
     normal classdef object, because there doesn’t seem to be any
     function that’s implicitly called for type conversion in that
     assignment.  Darn it.

* Menu:

* missing.missing::
* missing.dispstrs::
* missing.ismissing::
* missing.isnan::
* missing.isnannish::


File: Tablicious.info,  Node: missing.missing,  Next: missing.dispstrs,  Up: missing

8.2.15.1 missing.missing
........................

 -- Constructor: OBJ = missing ()

     Constructs a scalar ‘missing’ array.

     The constructor takes no arguments, since there’s only one
     ‘missing’ value.


File: Tablicious.info,  Node: missing.dispstrs,  Next: missing.ismissing,  Prev: missing.missing,  Up: missing

8.2.15.2 missing.dispstrs
.........................

 -- Method: OUT = dispstrs (OBJ)

     Display strings.

     Gets display strings for each element in OBJ.

     For ‘missing’, the display strings are always ‘'<missing>'’.

     Returns a cellstr the same size as OBJ.


File: Tablicious.info,  Node: missing.ismissing,  Next: missing.isnan,  Prev: missing.dispstrs,  Up: missing

8.2.15.3 missing.ismissing
..........................

 -- Method: OUT = ismissing (OBJ)

     Test whether elements are missing values.

     ‘ismissing’ is always true for ‘missing’ arrays.

     Returns a logical array the same size as OBJ.


File: Tablicious.info,  Node: missing.isnan,  Next: missing.isnannish,  Prev: missing.ismissing,  Up: missing

8.2.15.4 missing.isnan
......................

 -- Method: OUT = isnan (OBJ)

     Test whether elements are NaN.

     ‘isnan’ is always true for ‘missing’ arrays.

     Returns a logical array the same size as OBJ.


File: Tablicious.info,  Node: missing.isnannish,  Prev: missing.isnan,  Up: missing

8.2.15.5 missing.isnannish
..........................

 -- Method: OUT = isnannish (OBJ)

     Test whether elements are NaN-like.

     ‘isnannish’ is always true for ‘missing’ arrays.

     Returns a logical array the same size as OBJ.


File: Tablicious.info,  Node: pp,  Next: rmmissing,  Prev: missing,  Up: API Alphabetically

8.2.16 pp
---------

 -- Function: pp (X)
 -- Function: pp (A, B, C, ...)
 -- Function: pp (‘'A'’, ‘'B'’, ‘'C'’, ...)
 -- Function: pp ‘A’ ‘B’ ‘C’ ...

     Alias for prettyprint, for interactive use.

     This is an alias for prettyprint(), with additional name-conversion
     magic.

     If you pass in a char, instead of pretty-printing that directly, it
     will grab and pretty-print the variable of that name from the
     caller’s workspace.  This is so you can conveniently run it from
     the command line.


File: Tablicious.info,  Node: rmmissing,  Next: standardizeMissing,  Prev: pp,  Up: API Alphabetically

8.2.17 rmmissing
----------------

 -- Function: [OUT, TF] = rmmissing (X)
 -- Function: [OUT, TF] = rmmissing (X, DIM)
 -- Function: [OUT, TF] = rmmissing (..., ‘'MinNumMissing'’,
          MINNUMMISSING)

     Remove missing values.

     If X is a vector, removes elements with missing values.  If X is a
     matrix, removes rows or columns with missing data elements.

     DIM is the dimension to operate along.  Specifying a dimension
     forces ‘rmmissing’ to operate in matrix instead of vector mode.

     MINNUMMISSING indicates how many missing element values there must
     be in a row or column for it to be considered missing and this
     removed.  This option is only used in matrix mode; it is silently
     ignored in vector mode.

     Returns: OUT - the input, with missing elements or rows or columns
     removed TF - a logical index vector indicating which elements,
     rows, or columns were removed


File: Tablicious.info,  Node: standardizeMissing,  Next: startsWith,  Prev: rmmissing,  Up: API Alphabetically

8.2.18 standardizeMissing
-------------------------

 -- Function: OUT = standardizeMissing (X, INDICATOR)

     Insert standard missing values.

     Standardizes missing values in X by replacing the values listed in
     INDICATOR with the standard missing values for the type of X.

     Standard missing values depend on the data type: * NaN for double,
     single, duration, and calendarDuration * NaT for datetime * ‘' '’
     for char * ‘{''}’ for cellstrs * Integer numeric types have no
     standard missing value; they are never considered missing.  *
     Structs are never considered missing.  * Logicals are never
     considered missing.

     See also: *note table.standardizeMissing::


File: Tablicious.info,  Node: startsWith,  Next: string,  Prev: standardizeMissing,  Up: API Alphabetically

8.2.19 startsWith
-----------------

 -- Function: OUT = startsWith (STR, PATTERN)
 -- Function: OUT = startsWith (..., ‘'IgnoreCase'’, IGNORECASE)

     Test if strings start with a pattern.

     Tests whether the given strings start with the given pattern(s).

     STR (char, cellstr, or string) is a list of strings to compare
     against PATTERN.

     PATTERN (char, cellstr, or string) is a list of patterns to match.
     These are literal plain string patterns, not regex patterns.  If
     more than one pattern is supplied, the return value is true if the
     string matched any of them.

     Returns a logical array of the same size as the string array
     represented by STR.


File: Tablicious.info,  Node: string,  Next: struct2table,  Prev: startsWith,  Up: API Alphabetically

8.2.20 string
-------------

 -- Class: string

     A string array of Unicode strings.

     A string array is an array of strings, where each array element is
     a single string.

     The string class represents strings, where: - Each element of a
     string array is a single string - A single string is a
     1-dimensional row vector of Unicode characters - Those characters
     are encoded in UTF-8

     This should correspond pretty well to what people think of as
     strings, and is pretty compatible with people’s typical notion of
     strings in Octave.

     String arrays also have a special “missing” value, that is like the
     string equivalent of NaN for doubles or “undefined” for
     categoricals, or SQL NULL.

     This is a slightly higher-level and more strongly-typed way of
     representing strings than cellstrs are.  (A cellstr array is of
     type cell, not a text- specific type, and allows assignment of
     non-string data into it.)

     Be aware that while string arrays interconvert with Octave chars
     and cellstrs, Octave char elements represent 8-bit UTF-8 code
     units, not Unicode code points.

     This class really serves three roles.  - It is an object wrapper
     around Octave’s base primitive character types.  - It adds
     ismissing() semantics.  - And it introduces Unicode support.  Not
     clear whether it’s a good fit to have the Unicode support wrapped
     up in this.  Maybe it should just be a simple object wrapper
     wrapper, and defer Unicode semantics to when core Octave adopts
     them for char and cellstr.  On the other hand, because Octave chars
     are UTF-8, not UCS-2, some methods like strlength() and reverse()
     are just going to be wrong if they delegate straight to chars.

     “Missing” string values work like NaNs.  They are never considered
     equal, less than, or greater to any other string, including other
     missing strings.  This applies to set membership and other
     equivalence tests.

     The current implementation depends on Java for its Unicode and
     encoding support.  This means your Octave session must be running
     Java to call those methods.  This should be changed in the future
     to use a native C/C++ library and avoid the Java dependency,
     especially before this class is merged into core Octave.

     TODO: Need to decide how far to go with Unicode semantics, and how
     much to just make this an object wrapper over cellstr and defer to
     Octave’s existing char/string-handling functions.

     TODO: demote_strings should probably be static or global, so that
     other functions can use it to hack themselves into being
     string-aware.

* Menu:

* string.string::
* string.isstring::
* string.dispstrs::
* string.ismissing::
* string.isnannish::
* string.cellstr::
* string.cell::
* string.char::
* string.encode::
* string.strlength_bytes::
* string.strlength::
* string.reverse_bytes::
* string.reverse::
* string.strcat::
* string.lower::
* string.upper::
* string.erase::
* string.strrep::
* string.strfind::
* string.regexprep::
* string.strcmp::
* string.cmp::
* string.missing::
* string.decode::


File: Tablicious.info,  Node: string.string,  Next: string.isstring,  Up: string

8.2.20.1 string.string
......................

 -- Constructor: OBJ = string ()
 -- Constructor: OBJ = string (IN)

     Construct a new string array.

     The zero-argument constructor creates a new scalar string array
     whose value is the empty string.  TODO: Determine if this should
     actually return a “missing” string instead.

     The other constructors construct a new string array by converting
     various types of inputs.  - chars and cellstrs are converted via
     cellstr() - numerics are converted via num2str() - datetimes are
     converted via datestr()


File: Tablicious.info,  Node: string.isstring,  Next: string.dispstrs,  Prev: string.string,  Up: string

8.2.20.2 string.isstring
........................

 -- Method: OUT = isstring (OBJ)

     Test if input is a string array.

     ‘isstring’ is always true for ‘string’ inputs.

     Returns a scalar logical.


File: Tablicious.info,  Node: string.dispstrs,  Next: string.ismissing,  Prev: string.isstring,  Up: string

8.2.20.3 string.dispstrs
........................

 -- Method: OUT = dispstrs (OBJ)

     Display strings for array elements.

     Gets display strings for all the elements in OBJ.  These display
     strings will either be the string contents of the element, enclosed
     in ‘"..."’, and with CR/LF characters replaced with ‘'\r'’ and
     ‘'\n'’ escape sequences, or ‘"<missing>"’ for missing values.

     Returns a cellstr of the same size as OBJ.


File: Tablicious.info,  Node: string.ismissing,  Next: string.isnannish,  Prev: string.dispstrs,  Up: string

8.2.20.4 string.ismissing
.........................

 -- Method: OUT = ismissing (OBJ)

     Test whether array elements are missing.

     For ‘string’ arrays, only the special “missing” value is considered
     missing.  Empty strings are not considered missing, the way they
     are with cellstrs.

     Returns a logical array the same size as ‘obj’.


File: Tablicious.info,  Node: string.isnannish,  Next: string.cellstr,  Prev: string.ismissing,  Up: string

8.2.20.5 string.isnannish
.........................

 -- Method: OUT = isnannish (OBJ)

     Test whether array elements are NaN-like.

     Missing values are considered nannish; any other string value is
     not.

     Returns a logical array of the same size as OBJ.


File: Tablicious.info,  Node: string.cellstr,  Next: string.cell,  Prev: string.isnannish,  Up: string

8.2.20.6 string.cellstr
.......................

 -- Method: OUT = cellstr (OBJ)

     Convert to cellstr.

     Converts OBJ to a cellstr.  Missing values are converted to ‘''’.

     Returns a cellstr array of the same size as OBJ.


File: Tablicious.info,  Node: string.cell,  Next: string.char,  Prev: string.cellstr,  Up: string

8.2.20.7 string.cell
....................

 -- Method: OUT = cell (OBJ)

     Convert to cell array.

     Converts this to a cell, which will be a cellstr.  Missing values
     are converted to ‘''’.

     This method returns the same values as ‘cellstr(obj)’; it is just
     provided for interface compatibility purposes.

     Returns a cell array of the same size as OBJ.


File: Tablicious.info,  Node: string.char,  Next: string.encode,  Prev: string.cell,  Up: string

8.2.20.8 string.char
....................

 -- Method: OUT = char (OBJ)

     Convert to char array.

     Converts OBJ to a 2-D char array.  It will have as many rows as OBJ
     has elements.

     It is an error to convert missing-valued ‘string’ arrays to char.
     (NOTE: This may change in the future; it may be more appropriate)
     to convert them to space-padded empty strings.)

     Returns 2-D char array.


File: Tablicious.info,  Node: string.encode,  Next: string.strlength_bytes,  Prev: string.char,  Up: string

8.2.20.9 string.encode
......................

 -- Method: OUT = encode (OBJ, CHARSETNAME)

     Encode string in a given character encoding.

     OBJ must be scalar.

     CHARSETNAME (charvec) is the name of a character encoding.  (TODO:
     Document what determines the set of valid encoding names.)

     Returns the encoded string as a ‘uint8’ vector.

     See also: *note string.decode::.


File: Tablicious.info,  Node: string.strlength_bytes,  Next: string.strlength,  Prev: string.encode,  Up: string

8.2.20.10 string.strlength_bytes
................................

 -- Method: OUT = strlength_bytes (OBJ)

     String length in bytes.

     Gets the length of each string in OBJ, counted in Unicode UTF-8
     code units (bytes).  This is the same as ‘numel(str)’ for the
     corresponding Octave char vector for each string, but may not be
     what you actually want to use.  You may want ‘strlength’ instead.

     Returns double array of the same size as OBJ.  Returns NaNs for
     missing strings.

     See also: *note string.strlength::


File: Tablicious.info,  Node: string.strlength,  Next: string.reverse_bytes,  Prev: string.strlength_bytes,  Up: string

8.2.20.11 string.strlength
..........................

 -- Method: OUT = strlength (OBJ)

     String length in characters.

     Gets the length of each string, counted in Unicode characters (code
     points).  This is the string length method you probably want to
     use, not ‘strlength_bytes’.

     Returns double array of the same size as OBJ.  Returns NaNs for
     missing strings.

     See also: *note string.strlength_bytes::


File: Tablicious.info,  Node: string.reverse_bytes,  Next: string.reverse,  Prev: string.strlength,  Up: string

8.2.20.12 string.reverse_bytes
..............................

 -- Method: OUT = reverse_bytes (OBJ)

     Reverse string, byte-wise.

     Reverses the bytes in each string in OBJ.  This operates on bytes
     (Unicode code units), not characters.

     This may well produce invalid strings as a result, because
     reversing a UTF-8 byte sequence does not necessarily produce
     another valid UTF-8 byte sequence.

     You probably do not want to use this method.  You probably want to
     use ‘string.reverse’ instead.

     Returns a string array the same size as OBJ.

     See also: *note string.reverse::


File: Tablicious.info,  Node: string.reverse,  Next: string.strcat,  Prev: string.reverse_bytes,  Up: string

8.2.20.13 string.reverse
........................

 -- Method: OUT = reverse (OBJ)

     Reverse string, character-wise.

     Reverses the characters in each string in OBJ.  This operates on
     Unicode characters (code points), not on bytes, so it is guaranteed
     to produce valid UTF-8 as its output.

     Returns a string array the same size as OBJ.


File: Tablicious.info,  Node: string.strcat,  Next: string.lower,  Prev: string.reverse,  Up: string

8.2.20.14 string.strcat
.......................

 -- Method: OUT = strcat (VARARGIN)

     String concatenation.

     Concatenates the corresponding elements of all the input arrays,
     string-wise.  Inputs that are not string arrays are converted to
     string arrays.

     The semantics of concatenating missing strings with non-missing
     strings has not been determined yet.

     Returns a string array the same size as the scalar expansion of its
     inputs.


File: Tablicious.info,  Node: string.lower,  Next: string.upper,  Prev: string.strcat,  Up: string

8.2.20.15 string.lower
......................

 -- Method: OUT = lower (OBJ)

     Convert to lower case.

     Converts all the characters in all the strings in OBJ to lower
     case.

     This currently delegates to Octave’s own ‘lower()’ function to do
     the conversion, so whatever character class handling it has, this
     has.

     Returns a string array of the same size as OBJ.


File: Tablicious.info,  Node: string.upper,  Next: string.erase,  Prev: string.lower,  Up: string

8.2.20.16 string.upper
......................

 -- Method: OUT = upper (OBJ)

     Convert to upper case.

     Converts all the characters in all the strings in OBJ to upper
     case.

     This currently delegates to Octave’s own ‘upper()’ function to do
     the conversion, so whatever character class handling it has, this
     has.

     Returns a string array of the same size as OBJ.


File: Tablicious.info,  Node: string.erase,  Next: string.strrep,  Prev: string.upper,  Up: string

8.2.20.17 string.erase
......................

 -- Method: OUT = erase (OBJ, MATCH)

     Erase matching substring.

     Erases the substrings in OBJ which match the MATCH input.

     Returns a string array of the same size as OBJ.


File: Tablicious.info,  Node: string.strrep,  Next: string.strfind,  Prev: string.erase,  Up: string

8.2.20.18 string.strrep
.......................

 -- Method: OUT = strrep (OBJ, MATCH, REPLACEMENT)
 -- Method: OUT = strrep (..., VARARGIN)

     Replace occurrences of pattern with other string.

     Replaces matching substrings in OBJ with a given replacement
     string.

     VARARGIN is passed along to the core Octave ‘strrep’ function.
     This supports whatever options it does.  TODO: Maybe document what
     those options are.

     Returns a string array of the same size as OBJ.


File: Tablicious.info,  Node: string.strfind,  Next: string.regexprep,  Prev: string.strrep,  Up: string

8.2.20.19 string.strfind
........................

 -- Method: OUT = strfind (OBJ, PATTERN)
 -- Method: OUT = strfind (..., VARARGIN)

     Find pattern in string.

     Finds the locations where PATTERN occurs in the strings of OBJ.

     TODO: It’s ambiguous whether a scalar this should result in a
     numeric out or a cell array out.

     Returns either an index vector, or a cell array of index vectors.


File: Tablicious.info,  Node: string.regexprep,  Next: string.strcmp,  Prev: string.strfind,  Up: string

8.2.20.20 string.regexprep
..........................

 -- Method: OUT = regexprep (OBJ, PAT, REPSTR)
 -- Method: OUT = regexprep (..., VARARGIN)

     Replace based on regular expression matching.

     Replaces all the substrings matching a given regexp pattern PAT
     with the given replacement text REPSTR.

     Returns a string array of the same size as OBJ.


File: Tablicious.info,  Node: string.strcmp,  Next: string.cmp,  Prev: string.regexprep,  Up: string

8.2.20.21 string.strcmp
.......................

 -- Method: OUT = strcmp (A, B)

     String comparison.

     Tests whether each element in A is exactly equal to the
     corresponding element in B. Missing values are not considered equal
     to each other.

     This does the same comparison as ‘A == B’, but is not polymorphic.
     Generally, there is no reason to use ‘strcmp’ instead of ‘==’ or
     ‘eq’ on string arrays, unless you want to be compatible with
     cellstr inputs as well.

     Returns logical array the size of the scalar expansion of A and B.


File: Tablicious.info,  Node: string.cmp,  Next: string.missing,  Prev: string.strcmp,  Up: string

8.2.20.22 string.cmp
....................

 -- Method: [OUT, OUTA, OUTB] = cmp (A, B)

     Value ordering comparison, returning -1/0/+1.

     Compares each element of A and B, returning for each element ‘i’
     whether ‘A(i)’ was less than (-1), equal to (0), or greater than
     (1) the corresponding ‘B(i)’.

     TODO: What to do about missing values?  Should missings sort to the
     end (preserving total ordering over the full domain), or should
     their comparisons result in a fourth "null"/"undef" return value,
     probably represented by NaN? FIXME: The current implementation does
     not handle missings.

     Returns a numeric array OUT of the same size as the scalar
     expansion of A and B.  Each value in it will be -1, 0, or 1.

     Also returns scalar-expanded copies of A and B as OUTA and OUTB, as
     a programming convenience.


File: Tablicious.info,  Node: string.missing,  Next: string.decode,  Prev: string.cmp,  Up: string

8.2.20.23 string.missing
........................

 -- Static Method: OUT = string.missing (SZ)

     Missing string value.

     Creates a string array of all-missing values of the specified size
     SZ.  If SZ is omitted, creates a scalar missing string.

     Returns a string array of size SZ.


File: Tablicious.info,  Node: string.decode,  Prev: string.missing,  Up: string

8.2.20.24 string.decode
.......................

 -- Static Method: OUT = string.decode (BYTES, CHARSETNAME)

     Decode encoded text from bytes.

     Decodes the given encoded text in BYTES according to the specified
     encoding, given by CHARSETNAME.

     Returns a scalar string.

     See also: *note string.encode::


File: Tablicious.info,  Node: struct2table,  Next: table,  Prev: string,  Up: API Alphabetically

8.2.21 struct2table
-------------------

 -- Function: OUT = struct2table (S)
 -- Function: OUT = struct2table (..., ‘'AsArray'’, ASARRAY)

     Convert struct to a table.

     Converts the input struct S to a ‘table’.

     S may be a scalar struct or a nonscalar struct array.

     The ASARRAY option is not implemented yet.

     Returns a ‘table’.


File: Tablicious.info,  Node: table,  Next: tableOuterFillValue,  Prev: struct2table,  Up: API Alphabetically

8.2.22 table
------------

 -- Class: table

     Tabular data array containing multiple columnar variables.

     A ‘table’ is a tabular data structure that collects multiple
     parallel named variables.  Each variable is treated like a column.
     (Possibly a multi-columned column, if that makes sense.)  The types
     of variables may be heterogeneous.

     A table object is like an SQL table or resultset, or a relation, or
     a DataFrame in R or Pandas.

     A table is an array in itself: its size is NROWS-by-NVARIABLES, and
     you can index along the rows and variables by indexing into the
     table along dimensions 1 and 2.

 -- Instance Variable of table: ‘cellstr’ VariableNames

     The names of the variables in the table, as a cellstr row vector.

 -- Instance Variable of table: ‘cell’ VariableValues

     A cell vector containing the values for each of the variables.
     ‘VariableValues(i)’ corresponds to ‘VariableNames(i)’.

 -- Instance Variable of table: ‘cellstr’ RowNames

     An optional list of row names that identify each row in the table.
     This is a cellstr column vector, if present.

* Menu:

* table.table::
* table.summary::
* table.prettyprint::
* table.table2cell::
* table.table2struct::
* table.table2array::
* table.varnames::
* table.istable::
* table.size::
* table.length::
* table.ndims::
* table.squeeze::
* table.sizeof::
* table.height::
* table.rows::
* table.width::
* table.columns::
* table.numel::
* table.isempty::
* table.ismatrix::
* table.isrow::
* table.iscol::
* table.isvector::
* table.isscalar::
* table.hasrownames::
* table.vertcat::
* table.horzcat::
* table.repmat::
* table.setVariableNames::
* table.setRowNames::
* table.resolveVarRef::
* table.subsetRows::
* table.subsetvars::
* table.removevars::
* table.movevars::
* table.setvar::
* table.convertvars::
* table.head::
* table.tail::
* table.join::
* table.innerjoin::
* table.outerjoin::
* table.outerfillvals::
* table.semijoin::
* table.antijoin::
* table.cartesian::
* table.groupby::
* table.grpstats::
* table.union::
* table.intersect::
* table.setxor::
* table.setdiff::
* table.ismember::
* table.ismissing::
* table.rmmissing::
* table.standardizeMissing::
* table.varfun::
* table.rowfun::
* table.findgroups::
* table.evalWithVars::
* table.restrict::


File: Tablicious.info,  Node: table.table,  Next: table.summary,  Up: table

8.2.22.1 table.table
....................

 -- Constructor: OBJ = table ()

     Constructs a new empty (0 rows by 0 variables) table.

 -- Constructor: OBJ = table (VAR1, VAR2, ..., VARN)

     Constructs a new table from the given variables.  The variables
     passed as inputs to this constructor become the variables of the
     table.  Their names are automatically detected from the input
     variable names that you used.

 -- Constructor: OBJ = table (‘'Size'’, SZ, ‘'VariableTypes'’, VARTYPES)

     Constructs a new table of the given size, and with the given
     variable types.  The variables will contain the default value for
     elements of that type.

 -- Constructor: OBJ = table (..., ‘'VariableNames'’, VARNAMES)
 -- Constructor: OBJ = table (..., ‘'RowNames'’, ROWNAMES)

     Specifies the variable names or row names to use in the constructed
     table.  Overrides the implicit names garnered from the input
     variable names.


File: Tablicious.info,  Node: table.summary,  Next: table.prettyprint,  Prev: table.table,  Up: table

8.2.22.2 table.summary
......................

 -- Method: summary (OBJ)
 -- Method: S = summary (OBJ)

     Summary of table’s data.

     Displays or returns a summary of data in the input table.  This
     will contain some statistical information on each of its variables.

     This method is not implemented yet.


File: Tablicious.info,  Node: table.prettyprint,  Next: table.table2cell,  Prev: table.summary,  Up: table

8.2.22.3 table.prettyprint
..........................

 -- Method: prettyprint (OBJ)

     Display table’s values in tabular format.  This prints the contents
     of the table in human-readable, tabular form.

     Variables which contain objects are displayed using the strings
     returned by their ‘dispstrs’ method, if they define one.


File: Tablicious.info,  Node: table.table2cell,  Next: table.table2struct,  Prev: table.prettyprint,  Up: table

8.2.22.4 table.table2cell
.........................

 -- Method: C = table2cell (OBJ)

     Converts table to a cell array.  Each variable in OBJ becomes one
     or more columns in the output, depending on how many columns that
     variable has.

     Returns a cell array with the same number of rows as OBJ, and with
     as many or more columns as OBJ has variables.


File: Tablicious.info,  Node: table.table2struct,  Next: table.table2array,  Prev: table.table2cell,  Up: table

8.2.22.5 table.table2struct
...........................

 -- Method: S = table2struct (OBJ)
 -- Method: S = table2struct (..., ‘'ToScalar'’, TRUEORFALSE)

     Converts OBJ to a scalar structure or structure array.

     Row names are not included in the output struct.  To include them,
     you must add them manually: s = table2struct (tbl, ’ToScalar’,
     true); s.RowNames = tbl.Properties.RowNames;

     Returns a scalar struct or struct array, depending on the value of
     the ‘ToScalar’ option.


File: Tablicious.info,  Node: table.table2array,  Next: table.varnames,  Prev: table.table2struct,  Up: table

8.2.22.6 table.table2array
..........................

 -- Method: S = table2struct (OBJ)

     Converts OBJ to a homogeneous array.


File: Tablicious.info,  Node: table.varnames,  Next: table.istable,  Prev: table.table2array,  Up: table

8.2.22.7 table.varnames
.......................

 -- Method: OUT = varnames (OBJ)

     Get variable names for a table.

     Returns cellstr.


File: Tablicious.info,  Node: table.istable,  Next: table.size,  Prev: table.varnames,  Up: table

8.2.22.8 table.istable
......................

 -- Method: TF = istable (OBJ)

     True if input is a table.


File: Tablicious.info,  Node: table.size,  Next: table.length,  Prev: table.istable,  Up: table

8.2.22.9 table.size
...................

 -- Method: SZ = size (OBJ)

     Gets the size of a table.

     For tables, the size is [number-of-rows x number-of-variables].
     This is the same as ‘[height(obj), width(obj)]’.


File: Tablicious.info,  Node: table.length,  Next: table.ndims,  Prev: table.size,  Up: table

8.2.22.10 table.length
......................

 -- Method: OUT = length (OBJ)

     Length along longest dimension

     Use of ‘length’ is not recommended.  Use ‘numel’ or ‘size’ instead.


File: Tablicious.info,  Node: table.ndims,  Next: table.squeeze,  Prev: table.length,  Up: table

8.2.22.11 table.ndims
.....................

 -- Method: OUT = ndims (OBJ)

     Number of dimensions

     For tables, ‘ndims(obj)’ is always 2.


File: Tablicious.info,  Node: table.squeeze,  Next: table.sizeof,  Prev: table.ndims,  Up: table

8.2.22.12 table.squeeze
.......................

 -- Method: OBJ = squeeze (OBJ)

     Remove singleton dimensions.

     For tables, this is always a no-op that returns the input
     unmodified, because tables always have exactly 2 dimensions.


File: Tablicious.info,  Node: table.sizeof,  Next: table.height,  Prev: table.squeeze,  Up: table

8.2.22.13 table.sizeof
......................

 -- Method: OUT = sizeof (OBJ)

     Approximate size of array in bytes.  For tables, this returns the
     sume of ‘sizeof’ for all of its variables’ arrays, plus the size of
     the VariableNames and any other metadata stored in OBJ.

     This is currently unimplemented.


File: Tablicious.info,  Node: table.height,  Next: table.rows,  Prev: table.sizeof,  Up: table

8.2.22.14 table.height
......................

 -- Method: OUT = height (OBJ)

     Number of rows in table.


File: Tablicious.info,  Node: table.rows,  Next: table.width,  Prev: table.height,  Up: table

8.2.22.15 table.rows
....................

 -- Method: OUT = rows (OBJ)

     Number of rows in table.


File: Tablicious.info,  Node: table.width,  Next: table.columns,  Prev: table.rows,  Up: table

8.2.22.16 table.width
.....................

 -- Method: OUT = width (OBJ)

     Number of variables in table.

     Note that this is not the sum of the number of columns in each
     variable.  It is just the number of variables.


File: Tablicious.info,  Node: table.columns,  Next: table.numel,  Prev: table.width,  Up: table

8.2.22.17 table.columns
.......................

 -- Method: OUT = columns (OBJ)

     Number of variables in table.

     Note that this is not the sum of the number of columns in each
     variable.  It is just the number of variables.


File: Tablicious.info,  Node: table.numel,  Next: table.isempty,  Prev: table.columns,  Up: table

8.2.22.18 table.numel
.....................

 -- Method: OUT = numel (OBJ)

     Total number of elements in table.

     This is the total number of elements in this table.  This is
     calculated as the sum of numel for each variable.

     NOTE: Those semantics may be wrong.  This may actually need to be
     defined as ‘height(obj) * width(obj)’.  The behavior of ‘numel’ may
     change in the future.


File: Tablicious.info,  Node: table.isempty,  Next: table.ismatrix,  Prev: table.numel,  Up: table

8.2.22.19 table.isempty
.......................

 -- Method: OUT = isempty (OBJ)

     Test whether array is empty.

     For tables, ‘isempty’ is true if the number of rows is 0 or the
     number of variables is 0.


File: Tablicious.info,  Node: table.ismatrix,  Next: table.isrow,  Prev: table.isempty,  Up: table

8.2.22.20 table.ismatrix
........................

 -- Method: OUT = ismatrix (OBJ)

     Test whether array is a matrix.

     For tables, ‘ismatrix’ is always true, by definition.


File: Tablicious.info,  Node: table.isrow,  Next: table.iscol,  Prev: table.ismatrix,  Up: table

8.2.22.21 table.isrow
.....................

 -- Method: OUT = isrow (OBJ)

     Test whether array is a row vector.


File: Tablicious.info,  Node: table.iscol,  Next: table.isvector,  Prev: table.isrow,  Up: table

8.2.22.22 table.iscol
.....................

 -- Method: OUT = iscol (OBJ)

     Test whether array is a column vector.

     For tables, ‘iscol’ is true if the input has a single variable.
     The number of columns within that variable does not matter.


File: Tablicious.info,  Node: table.isvector,  Next: table.isscalar,  Prev: table.iscol,  Up: table

8.2.22.23 table.isvector
........................

 -- Method: OUT = isvector (OBJ)

     Test whether array is a vector.


File: Tablicious.info,  Node: table.isscalar,  Next: table.hasrownames,  Prev: table.isvector,  Up: table

8.2.22.24 table.isscalar
........................

 -- Method: OUT = isscalar (OBJ)

     Test whether array is scalar.


File: Tablicious.info,  Node: table.hasrownames,  Next: table.vertcat,  Prev: table.isscalar,  Up: table

8.2.22.25 table.hasrownames
...........................

 -- Method: OUT = hasrownames (OBJ)

     True if this table has row names defined.


File: Tablicious.info,  Node: table.vertcat,  Next: table.horzcat,  Prev: table.hasrownames,  Up: table

8.2.22.26 table.vertcat
.......................

 -- Method: OUT = vertcat (VARARGIN)

     Vertical concatenation.

     Combines tables by vertically concatenating them.

     Inputs that are not tables are automatically converted to tables by
     calling table() on them.

     The inputs must have the same number and names of variables, and
     their variable value types and sizes must be cat-compatible.


File: Tablicious.info,  Node: table.horzcat,  Next: table.repmat,  Prev: table.vertcat,  Up: table

8.2.22.27 table.horzcat
.......................

 -- Method: OUT = horzcat (VARARGIN)

     Horizontal concatenation.

     Combines tables by horizontally concatenating them.  Inputs that
     are not tables are automatically converted to tables by calling
     table() on them.  Inputs must have all distinct variable names.

     Output has the same RowNames as ‘varargin{1}’.  The variable names
     and values are the result of the concatenation of the variable
     names and values lists from the inputs.


File: Tablicious.info,  Node: table.repmat,  Next: table.setVariableNames,  Prev: table.horzcat,  Up: table

8.2.22.28 table.repmat
......................

 -- Method: OUT = repmat (OBJ, SZ)

     Replicate matrix.

     Repmats a table by repmatting each of its variables vertically.

     For tables, repmatting is only supported along dimension 1.  That
     is, the values of sz(2:end) must all be exactly 1.

     Returns a new table with the same variable names and types as tbl,
     but with a possibly different row count.


File: Tablicious.info,  Node: table.setVariableNames,  Next: table.setRowNames,  Prev: table.repmat,  Up: table

8.2.22.29 table.setVariableNames
................................

 -- Method: OUT = setVariableNames (OBJ, NAMES)

     Set variable names.

     Sets the ‘VariableNames’ for this table to a new list of names.

     NAMES is a cellstr vector.  It must have the same number of
     elements as the number of variables in OBJ.


File: Tablicious.info,  Node: table.setRowNames,  Next: table.resolveVarRef,  Prev: table.setVariableNames,  Up: table

8.2.22.30 table.setRowNames
...........................

 -- Method: OUT = setRowNames (OBJ, NAMES)

     Set row names.

     Sets the row names on OBJ to NAMES.

     NAMES is a cellstr column vector, with the same number of rows as
     OBJ has.


File: Tablicious.info,  Node: table.resolveVarRef,  Next: table.subsetRows,  Prev: table.setRowNames,  Up: table

8.2.22.31 table.resolveVarRef
.............................

 -- Method: [IXVAR, VARNAMES] = resolveVarREf (OBJ, VARREF)

     Resolve a variable reference against this table.

     A VARREF is a numeric or char/cellstr indicator of which variables
     within OBJ are being referenced.

     Returns: IXVAR - the indexes of the variables in OBJ VARNAMES - a
     cellstr of the names of the variables in OBJ

     Raises an error if any of the specified variables could not be
     resolved.


File: Tablicious.info,  Node: table.subsetRows,  Next: table.subsetvars,  Prev: table.resolveVarRef,  Up: table

8.2.22.32 table.subsetRows
..........................

 -- Method: OUT = subsetRows (OBJ, IXROWS)

     Subset table by rows.

     Subsets this table by rows.

     IXROWS may be a numeric or logical index into the rows of OBJ.


File: Tablicious.info,  Node: table.subsetvars,  Next: table.removevars,  Prev: table.subsetRows,  Up: table

8.2.22.33 table.subsetvars
..........................

 -- Method: OUT = subsetvars (OBJ, IXVARS)

     Subset table by variables.

     Subsets table OBJ by subsetting it along its variables.

     ixVars may be: - a numeric index vector - a logical index vector -
     ":" - a cellstr vector of variable names

     The resulting table will have its variables reordered to match
     ixVars.


File: Tablicious.info,  Node: table.removevars,  Next: table.movevars,  Prev: table.subsetvars,  Up: table

8.2.22.34 table.removevars
..........................

 -- Method: OUT = removevars (OBJ, VARS)

     Remove variables from table.

     Deletes the variables specified by VARS from OBJ.

     VARS may be a char, cellstr, numeric index vector, or logical index
     vector.


File: Tablicious.info,  Node: table.movevars,  Next: table.setvar,  Prev: table.removevars,  Up: table

8.2.22.35 table.movevars
........................

 -- Method: OUT = movevars (OBJ, VARS, RELLOCATION, LOCATION)

     Move around variables in a table.

     VARS is a list of variables to move, specified by name or index.

     RELLOCATION is ‘'Before'’ or ‘'After'’.

     LOCATION indicates a single variable to use as the target location,
     specified by name or index.  If it is specified by index, it is the
     index into the list of *unmoved* variables from OBJ, not the
     original full list of variables in OBJ.

     Returns a table with the same variables as OBJ, but in a different
     order.


File: Tablicious.info,  Node: table.setvar,  Next: table.convertvars,  Prev: table.movevars,  Up: table

8.2.22.36 table.setvar
......................

 -- Method: OUT = setvar (OBJ, VARREF, VALUE)

     Set value for a variable in table.

     This sets (replaces) the value for a variable that already exists
     in OBJ.  It cannot be used to add a new variable.


File: Tablicious.info,  Node: table.convertvars,  Next: table.head,  Prev: table.setvar,  Up: table

8.2.22.37 table.convertvars
...........................

 -- Method: OUT = convertvars (OBJ, VARS, DATATYPE)

     Convert variables to specified data type.

     Converts the variables in OBJ specified by VARS to the specified
     data type.

     VARS is a cellstr or numeric vector specifying which variables to
     convert.

     DATATYPE specifies the data type to convert those variables to.  It
     is either a char holding the name of the data type, or a function
     handle which will perform the conversion.  If it is the name of the
     data type, there must either be a one-arg constructor of that type
     which accepts the specified variables’ current types as input, or a
     conversion method of that name defined on the specified variables’
     current type.

     Returns a table with the same variable names as OBJ, but with
     converted types.


File: Tablicious.info,  Node: table.head,  Next: table.tail,  Prev: table.convertvars,  Up: table

8.2.22.38 table.head
....................

 -- Method: OUT = head (OBJ)
 -- Method: OUT = head (OBJ, K)

     Get first K rows of table.

     Returns the first K rows of OBJ, as a table.

     K defaults to 8.

     If there are less than K rows in OBJ, returns all rows.


File: Tablicious.info,  Node: table.tail,  Next: table.join,  Prev: table.head,  Up: table

8.2.22.39 table.tail
....................

 -- Method: OUT = tail (OBJ)
 -- Method: OUT = tail (OBJ, K)

     Get last K rows of table.

     Returns the last K rows of OBJ, as a table.

     K defaults to 8.

     If there are less than K rows in OBJ, returns all rows.


File: Tablicious.info,  Node: table.join,  Next: table.innerjoin,  Prev: table.tail,  Up: table

8.2.22.40 table.join
....................

 -- Method: [C, IB] = join (A, B)
 -- Method: [C, IB] = join (A, B, ...)

     Combine two tables by rows using key variables, in a restricted
     form.

     This is not a "real" relational join operation.  It has the
     restrictions that: 1) The key values in B must be unique.  2) Every
     key value in A must map to a key value in B. These are restrictions
     inherited from the Matlab definition of table.join.

     You probably don’t want to use this method.  You probably want to
     use innerjoin or outerjoin instead.

     See also: *note table.innerjoin::, *note table.outerjoin::


File: Tablicious.info,  Node: table.innerjoin,  Next: table.outerjoin,  Prev: table.join,  Up: table

8.2.22.41 table.innerjoin
.........................

 -- Method: [OUT, IXA, IXB] = innerjoin (A, B)
 -- Method: [...] = innerjoin (A, B, ...)

     Combine two tables by rows using key variables.

     Computes the relational inner join between two tables.  “Inner”
     means that only rows which had matching rows in the other input are
     kept in the output.

     TODO: Document options.

     Returns: OUT - A table that is the result of joining A and B IX -
     Indexes into A for each row in out IXB - Indexes into B for each
     row in out


File: Tablicious.info,  Node: table.outerjoin,  Next: table.outerfillvals,  Prev: table.innerjoin,  Up: table

8.2.22.42 table.outerjoin
.........................

 -- Method: [OUT, IXA, IXB] = outerjoin (A, B)
 -- Method: [...] = outerjoin (A, B, ...)

     Combine two tables by rows using key variables, retaining unmatched
     rows.

     Computes the relational outer join of tables A and B. This is like
     a regular join, but also includes rows in each input which did not
     have matching rows in the other input; the columns from the missing
     side are filled in with placeholder values.

     TODO: Document options.

     Returns: OUT - A table that is the result of the outer join of A
     and B IXA - indexes into A for each row in out IXB - indexes into B
     for each row in out


File: Tablicious.info,  Node: table.outerfillvals,  Next: table.semijoin,  Prev: table.outerjoin,  Up: table

8.2.22.43 table.outerfillvals
.............................

 -- Method: OUT = outerfillvals (OBJ)

     Get fill values for outer join.

     Returns a table with the same variables as this, but containing
     only a single row whose variable values are the values to use as
     fill values when doing an outer join.


File: Tablicious.info,  Node: table.semijoin,  Next: table.antijoin,  Prev: table.outerfillvals,  Up: table

8.2.22.44 table.semijoin
........................

 -- Method: [OUTA, IXA, OUTB, IXB] = semijoin (A, B)

     Natural semijoin.

     Computes the natural semijoin of tables A and B. The semi-join of
     tables A and B is the set of all rows in A which have matching rows
     in B, based on comparing the values of variables with the same
     names.

     This method also computes the semijoin of B and A, for convenience.

     Returns: OUTA - all the rows in A with matching row(s) in B IXA -
     the row indexes into A which produced OUTA OUTB - all the rows in B
     with matching row(s) in A IXB - the row indexes into B which
     produced OUTB


File: Tablicious.info,  Node: table.antijoin,  Next: table.cartesian,  Prev: table.semijoin,  Up: table

8.2.22.45 table.antijoin
........................

 -- Method: [OUTA, IXA, OUTB, IXB] = antijoin (A, B)

     Natural antijoin (AKA “semidifference”).

     Computes the anti-join of A and B. The anti-join is defined as all
     the rows from one input which do not have matching rows in the
     other input.

     Returns: OUTA - all the rows in A with no matching row in B IXA -
     the row indexes into A which produced OUTA OUTB - all the rows in B
     with no matching row in A IXB - the row indexes into B which
     produced OUTB


File: Tablicious.info,  Node: table.cartesian,  Next: table.groupby,  Prev: table.antijoin,  Up: table

8.2.22.46 table.cartesian
.........................

 -- Method: [OUT, IXS] = cartesian (A, B)

     Cartesian product of two tables.

     Computes the Cartesian product of two tables.  The Cartesian
     product is each row in A combined with each row in B.

     Due to the definition and structural constraints of table, the two
     inputs must have no variable names in common.  It is an error if
     they do.

     The Cartesian product is seldom used in practice.  If you find
     yourself calling this method, you should step back and re-evaluate
     what you are doing, asking yourself if that is really what you want
     to happen.  If nothing else, writing a function that calls
     cartesian() is usually much less efficient than alternate ways of
     arriving at the same result.

     This implementation does not remove duplicate values.  TODO:
     Determine whether this duplicate-removing behavior is correct.

     The ordering of the rows in the output is not specified, and may be
     implementation- dependent.  TODO: Determine if we can lock this
     behavior down to a fixed, defined ordering, without killing
     performance.


File: Tablicious.info,  Node: table.groupby,  Next: table.grpstats,  Prev: table.cartesian,  Up: table

8.2.22.47 table.groupby
.......................

 -- Method: [OUT] = groupby (OBJ, GROUPVARS, AGGCALCS)

     Find groups in table data and apply functions to variables within
     groups.

     This works like an SQL ‘"SELECT ... GROUP BY ..."’ statement.

     GROUPVARS (cellstr, numeric) is a list of the grouping variables,
     identified by name or index.

     AGGCALCS is a specification of the aggregate calculations to
     perform on them, in the form ‘{’OUT_VAR‘,’ FCN‘,’ IN_VARS‘; ...}’,
     where: OUT_VAR (char) is the name of the output variable FCN
     (function handle) is the function to apply to produce it IN_VARS
     (cellstr) is a list of the input variables to pass to fcn

     Returns a table.


File: Tablicious.info,  Node: table.grpstats,  Next: table.union,  Prev: table.groupby,  Up: table

8.2.22.48 table.grpstats
........................

 -- Method: [OUT] = grpstats (OBJ, GROUPVAR)
 -- Method: [OUT] = grpstats (..., ‘'DataVars'’, DATAVARS)

     Statistics by group.

     See also: *note table.groupby::.


File: Tablicious.info,  Node: table.union,  Next: table.intersect,  Prev: table.grpstats,  Up: table

8.2.22.49 table.union
.....................

 -- Method: [C, IA, IB] = union (A, B)

     Set union.

     Computes the union of two tables.  The union is defined to be the
     unique row values which are present in either of the two input
     tables.

     Returns: C - A table containing all the unique row values present
     in A or B. IA - Row indexes into A of the rows from A included in
     C. IB - Row indexes into B of the rows from B included in C.


File: Tablicious.info,  Node: table.intersect,  Next: table.setxor,  Prev: table.union,  Up: table

8.2.22.50 table.intersect
.........................

 -- Method: [C, IA, IB] = intersect (A, B)

     Set intersection.

     Computes the intersection of two tables.  The intersection is
     defined to be the unique row values which are present in both of
     the two input tables.

     Returns: C - A table containing all the unique row values present
     in both A and B. IA - Row indexes into A of the rows from A
     included in C. IB - Row indexes into B of the rows from B included
     in C.


File: Tablicious.info,  Node: table.setxor,  Next: table.setdiff,  Prev: table.intersect,  Up: table

8.2.22.51 table.setxor
......................

 -- Method: [C, IA, IB] = setxor (A, B)

     Set exclusive OR.

     Computes the setwise exclusive OR of two tables.  The set XOR is
     defined to be the unique row values which are present in one or the
     other of the two input tables, but not in both.

     Returns: C - A table containing all the unique row values in the
     set XOR of A and B. IA - Row indexes into A of the rows from A
     included in C. IB - Row indexes into B of the rows from B included
     in C.


File: Tablicious.info,  Node: table.setdiff,  Next: table.ismember,  Prev: table.setxor,  Up: table

8.2.22.52 table.setdiff
.......................

 -- Method: [C, IA] = setdiff (A, B)

     Set difference.

     Computes the set difference of two tables.  The set difference is
     defined to be the unique row values which are present in table A
     that are not in table B.

     Returns: C - A table containing the unique row values in A that
     were not in B. IA - Row indexes into A of the rows from A included
     in C.


File: Tablicious.info,  Node: table.ismember,  Next: table.ismissing,  Prev: table.setdiff,  Up: table

8.2.22.53 table.ismember
........................

 -- Method: [TF, LOC] = ismember (A, B)

     Set membership.

     Finds rows in A that are members of B.

     Returns: TF - A logical vector indicating whether each A(i,:) was
     present in B. LOC - Indexes into B of rows that were found.


File: Tablicious.info,  Node: table.ismissing,  Next: table.rmmissing,  Prev: table.ismember,  Up: table

8.2.22.54 table.ismissing
.........................

 -- Method: OUT = ismissing (OBJ)
 -- Method: OUT = ismissing (OBJ, INDICATOR)

     Find missing values.

     Finds missing values in OBJ’s variables.

     If indicator is not supplied, uses the standard missing values for
     each variable’s data type.  If indicator is supplied, the same
     indicator list is applied across all variables.

     All variables in this must be vectors.  (This is due to the
     requirement that ‘size(out) == size(obj)’.)

     Returns a logical array the same size as OBJ.


File: Tablicious.info,  Node: table.rmmissing,  Next: table.standardizeMissing,  Prev: table.ismissing,  Up: table

8.2.22.55 table.rmmissing
.........................

 -- Method: [OUT, TF] = rmmissing (OBJ)
 -- Method: [OUT, TF] = rmmissing (OBJ, INDICATOR)
 -- Method: [OUT, TF] = rmmissing (..., ‘'DataVariables'’, VARS)
 -- Method: [OUT, TF] = rmmissing (..., ‘'MinNumMissing'’,
          MINNUMMISSING)

     Remove rows with missing values.

     Removes the rows from OBJ that have missing values.

     If the ’DataVariables’ option is given, only the data in the
     specified variables is considered.

     Returns: OUT - A table the same as OBJ, but with rows with missing
     values removed.  TF - A logical index vector indicating which rows
     were removed.


File: Tablicious.info,  Node: table.standardizeMissing,  Next: table.varfun,  Prev: table.rmmissing,  Up: table

8.2.22.56 table.standardizeMissing
..................................

 -- Method: OUT = standardizeMissing (OBJ, INDICATOR)
 -- Method: OUT = standardizeMissing (..., ‘'DataVariables'’, VARS)

     Insert standard missing values.

     Standardizes missing values in variable data.

     If the DATAVARIABLES option is supplied, only the indicated
     variables are standardized.

     INDICATOR is passed along to ‘standardizeMissing’ when it is called
     on each of the data variables in turn.  The same indicator is used
     for all variables.  You can mix and match indicator types by just
     passing in mixed indicator types in a cell array; indicators that
     don’t match the type of the column they are operating on are just
     ignored.

     Returns a table with same variable names and types as OBJ, but with
     variable values standardized.


File: Tablicious.info,  Node: table.varfun,  Next: table.rowfun,  Prev: table.standardizeMissing,  Up: table

8.2.22.57 table.varfun
......................

 -- Method: OUT = varfun (FCN, OBJ)
 -- Method: OUT = varfun (..., ‘'OutputFormat'’, OUTPUTFORMAT)
 -- Method: OUT = varfun (..., ‘'InputVariables'’, VARS)
 -- Method: OUT = varfun (..., ‘'ErrorHandler'’, ERRORFCN)

     Apply function to table variables.

     Applies the given function FCN to each variable in OBJ, collecting
     the output in a table, cell array, or array of another type.


File: Tablicious.info,  Node: table.rowfun,  Next: table.findgroups,  Prev: table.varfun,  Up: table

8.2.22.58 table.rowfun
......................

 -- Method: OUT = varfun (FCN, OBJ)
 -- Method: OUT = varfun (..., ‘'OptionName'’, OPTIONVALUE, ...)

     This method is currently unimplemented.  Sorry.


File: Tablicious.info,  Node: table.findgroups,  Next: table.evalWithVars,  Prev: table.rowfun,  Up: table

8.2.22.59 table.findgroups
..........................

 -- Method: [G, TID] = findgroups (OBJ)

     Find groups within a table’s row values.

     Finds groups within a table’s row values and get group numbers.  A
     group is a set of rows that have the same values in all their
     variable elements.

     Returns: G - A double column vector of group numbers created from
     OBJ.  TID - A table containing the row values corresponding to the
     group numbers.


File: Tablicious.info,  Node: table.evalWithVars,  Next: table.restrict,  Prev: table.findgroups,  Up: table

8.2.22.60 table.evalWithVars
............................

 -- Method: OUT = evalWithVars (OBJ, EXPR)

     Evaluate an expression against table’s variables.

     Evaluates the M-code expression EXPR in a workspace where all of
     OBJ’s variables have been assigned to workspace variables.

     EXPR is a charvec containing an Octave expression.

     As an implementation detail, the workspace will also contain some
     variables that are prefixed and suffixed with "__".  So try to
     avoid those in your table variable names.

     Returns the result of the evaluation.

     Examples:

          [s,p,sp] = table_examples.SpDb
          tmp = join (sp, p);
          shipment_weight = evalWithVars (tmp, "Qty .* Weight")


File: Tablicious.info,  Node: table.restrict,  Prev: table.evalWithVars,  Up: table

8.2.22.61 table.restrict
........................

 -- Method: OUT = restrict (OBJ, EXPR)
 -- Method: OUT = restrict (OBJ, IX)

     Subset rows using variable expression or index.

     Subsets a table row-wise, using either an index vector or an
     expression involving OBJ’s variables.

     If the argument is a numeric or logical vector, it is interpreted
     as an index into the rows of this.  (Just as with ‘subsetRows
     (this, index)‘.)

     If the argument is a char, then it is evaulated as an M-code
     expression, with all of this’ variables available as workspace
     variables, as with ‘evalWithVars’.  The output of expr must be a
     numeric or logical index vector (This form is a shorthand for ‘out
     = subsetRows (this, evalWithVars (this, expr))’.)

     TODO: Decide whether to name this to "where" to be more like SQL
     instead of relational algebra.

     Examples:
          [s,p,sp] = table_examples.SpDb;
          prettyprint (restrict (p, 'Weight >= 14 & strcmp(Color, "Red")'))


File: Tablicious.info,  Node: tableOuterFillValue,  Next: vecfun,  Prev: table,  Up: API Alphabetically

8.2.23 tableOuterFillValue
--------------------------

 -- Function: OUT = tableOuterFillValue (X)

     Outer fill value for variable within a table.

     Determines the fill value to usse for a given variable value X when
     that value is used as a variable in a table that is involved in an
     outer join.

     The default implementation for ‘tableOuterFillValue’ has support
     for all Octave primitive types, plus cellstrs, datetime & friends,
     strings, and ‘table’-valued variables.

     This function may become private to table before version 1.0.  It
     is currently global to make debugging more convenient.  It (or an
     equivalent) will remain global if we want to allow user-defined
     classes to customize their fill value.  It also has default logic
     that will determine the fill value for an arbitrary type by
     detecting the value used to fill elements during array expansion
     operations.  This will be appropriate for most data types.

     Returns a 1-by-ncols value of the same type as x, which may be any
     type, where ncols is the number of columns in the input.


File: Tablicious.info,  Node: vecfun,  Prev: tableOuterFillValue,  Up: API Alphabetically

8.2.24 vecfun
-------------

 -- Function: OUT = vecfun (FCN, X, DIM)

     Apply function to vectors in array along arbitrary dimension.

     This function is not implemented yet.

     Applies a given function to the vector slices of an N-dimensional
     array, where those slices are along a given dimension.

     FCN is a function handle to apply.

     X is an array of arbitrary type which is to be sliced and passed in
     to FCN.

     DIM is the dimension along which the vector slices lay.

     Returns the collected output of the FCN calls, which will be the
     same size as X, but not necessarily the same type.


File: Tablicious.info,  Node: Copying,  Prev: API Reference,  Up: Top

9 Copying
*********

9.1 Package Copyright
=====================

Tablicious for Octave is covered by the GNU GPLv3.

   All the code in the package is GNU GPLv3.

   The Fisher Iris dataset is Public Domain.

9.2 Manual Copyright
====================

This manual is for Tablicious, version 0.1.0.

   Copyright © 2019 Andrew Janke

     Permission is granted to make and distribute verbatim copies of
     this manual provided the copyright notice and this permission
     notice are preserved on all copies.

     Permission is granted to copy and distribute modified versions of
     this manual under the conditions for verbatim copying, provided
     that the entire resulting derived work is distributed under the
     terms of a permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
     manual into another language, under the same conditions as for
     modified versions.



Tag Table:
Node: Top772
Node: Introduction1111
Node: Getting Started2474
Node: Table Representation3288
Node: table Class3551
Node: Date Representation3863
Node: datetime Class4123
Node: datenum Compatibility4956
Node: Time Zones6500
Node: Defined Time Zones9337
Node: Durations10312
Node: duration Class10495
Node: calendarDuration Class11250
Node: Missing Functionality12155
Node: API Reference13396
Node: API by Category13585
Node: API Alphabetically15345
Node: array2table16741
Node: categorical17672
Node: categorical.categorical19926
Node: categorical.categories21183
Node: categorical.iscategory21586
Node: categorical.isordinal22032
Node: categorical.string22401
Node: categorical.cellstr22848
Node: categorical.dispstrs23287
Node: categorical.summary23743
Node: categorical.addcats24194
Node: categorical.removecats24620
Node: categorical.mergecats25262
Node: categorical.renamecats25917
Node: categorical.reordercats26334
Node: categorical.setcats26869
Node: categorical.isundefined27315
Node: categorical.ismissing27833
Node: categorical.isnannish28243
Node: categorical.squeezecats28721
Node: cell2table29091
Node: colvecfun29831
Node: contains30555
Node: discretize31344
Node: dispstrs32243
Node: endsWith33025
Node: eqn33806
Node: fillmissing34892
Node: isfile35744
Node: isfolder36855
Node: ismissing37822
Node: isnannish39932
Node: missing40914
Node: missing.missing41951
Node: missing.dispstrs42265
Node: missing.ismissing42662
Node: missing.isnan43027
Node: missing.isnannish43366
Node: pp43700
Node: rmmissing44343
Node: standardizeMissing45386
Node: startsWith46212
Node: string47022
Node: string.string50316
Node: string.isstring50986
Node: string.dispstrs51311
Node: string.ismissing51893
Node: string.isnannish52374
Node: string.cellstr52757
Node: string.cell53102
Node: string.char53589
Node: string.encode54114
Node: string.strlength_bytes54628
Node: string.strlength55301
Node: string.reverse_bytes55868
Node: string.reverse56606
Node: string.strcat57078
Node: string.lower57656
Node: string.upper58158
Node: string.erase58659
Node: string.strrep58996
Node: string.strfind59601
Node: string.regexprep60124
Node: string.strcmp60600
Node: string.cmp61293
Node: string.missing62272
Node: string.decode62674
Node: struct2table63084
Node: table63551
Node: table.table65995
Node: table.summary67047
Node: table.prettyprint67474
Node: table.table2cell67933
Node: table.table2struct68421
Node: table.table2array69056
Node: table.varnames69303
Node: table.istable69555
Node: table.size69767
Node: table.length70096
Node: table.ndims70395
Node: table.squeeze70646
Node: table.sizeof70993
Node: table.height71424
Node: table.rows71632
Node: table.width71833
Node: table.columns72164
Node: table.numel72502
Node: table.isempty73022
Node: table.ismatrix73346
Node: table.isrow73635
Node: table.iscol73853
Node: table.isvector74213
Node: table.isscalar74439
Node: table.hasrownames74669
Node: table.vertcat74919
Node: table.horzcat75440
Node: table.repmat76060
Node: table.setVariableNames76595
Node: table.setRowNames77041
Node: table.resolveVarRef77413
Node: table.subsetRows78023
Node: table.subsetvars78368
Node: table.removevars78875
Node: table.movevars79260
Node: table.setvar79988
Node: table.convertvars80357
Node: table.head81339
Node: table.tail81714
Node: table.join82080
Node: table.innerjoin82826
Node: table.outerjoin83487
Node: table.outerfillvals84294
Node: table.semijoin84727
Node: table.antijoin85496
Node: table.cartesian86148
Node: table.groupby87416
Node: table.grpstats88267
Node: table.union88595
Node: table.intersect89163
Node: table.setxor89771
Node: table.setdiff90406
Node: table.ismember90943
Node: table.ismissing91345
Node: table.rmmissing92029
Node: table.standardizeMissing92821
Node: table.varfun93811
Node: table.rowfun94378
Node: table.findgroups94689
Node: table.evalWithVars95274
Node: table.restrict96124
Node: tableOuterFillValue97253
Node: vecfun98487
Node: Copying99212

End Tag Table


Local Variables:
coding: utf-8
End:
